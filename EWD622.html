<!DOCTYPE html>
<html>
<head>
  <title>On making solutions more and more fine-grained</title>
  <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
  <link href="assets/common.css" rel="stylesheet">
  <link href="assets/transcriptions.css" rel="stylesheet">
  <meta name="generator" content="convertArticle.pl">
</head>
<body>
<div class="metabar">
  <a href="index.html">HOME</a>
</div>
<h1>On making solutions more and more fine-grained</h1>
<div class='body'>
        <hr />
<p class="noindent">NOTE: This transcription was contributed by Martin P.M. van der Burgt, who has devised a process for producing 
transcripts automatically. Although its markup is incomplete, we believe it serves a useful purpose by virtue of its searchability and its 
accessibility to text-reading software. It will be replaced by a fully marked-up version when time permits. &mdash;HR</p>
<hr />
           <p class="noindent">
<table> <tr> <td colspan = 3>
<b>Copyright Notice  </b>                                                             </td> </tr> <tr> <td colspan = 3>
The following manuscript                                                              </td> </tr> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
     EWD 622: On making solutions more and more fine-grained (In gratitude dedicated  </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
           to C.A.R.Hoare, D.E.Knuth, and J.F.Traub.)                                 </td> </tr> <tr> <td colspan = 3>
is held in copyright by Springer-Verlag New York.                                     </td> </tr> <tr> <td colspan = 3>
The manuscript was published as pages 292307 of                                      </td> </tr> <tr> <td></td> <td colspan = 2>
     Edsger W. Dijkstra, Selected Writings on Computing: A Personal Perspective,      </td> </tr> <tr> <td></td> <td colspan = 2>
     Springer-Verlag, 1982. ISBN 0387906525.                                       </td> </tr> <tr> <td colspan = 3>
<b>Reproduced with permission from Springer-Verlag New York.    </b>                  </td> </tr> <tr> <td colspan = 3>
<b>Any further reproduction is strictly prohibited.        </b>                       </td> </tr>
</table>
<p class=noindent>5 May 1977 
<p>In gratitude dedicated to C.A.R.Hoare, D.E.Knuth, and J.F.Traub.
<p class=noindent><b>On making solutions more and more fine-grained</b>.
<p>This note deals with a problem that I owe to C.S.Scholten. Today seems
an appropriate day to start writing this note, for yesterday evening I completed
EWD595&rsquo; (the second version of EWD595 which, itself, is the n-th version of our
joint article on the on-the-fly garbage collection): Scholten&rsquo;s problem was 
already with us for a few weeks, before we realized that it had, in a way, the
same flavour as the collector&rsquo;s problem of detecting that the marking had been
completed. Perhaps we shall see one day, that all these solutions, which at
present seem disconnected pieces of logical ingenuity &mdash;not to say: intricacy&mdash;
are all members of the same family.
<p>In the on-the-fly garbage collection the cooperation of mutator and collector
ensured during marking that a stable state &mdash;all reachable nodes black and
all white nodes garbage&mdash; would be reached in a finite number of steps of the
collector&rsquo;s marking cycle: the problem was the design of the detection mechanism
for the collector that, indeed, the stable state had been reached. Scholten&rsquo;s
problem poses such a detection problem for N machines.
<p>In the following y denotes a vector of N components y[i] for 0 &le; i &lt; N.
With the function f we shall denote a vector-valued function of a vector 
argument, and the algorithms we shall study solve the equation
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
y = f(y)</td><td align=right>(1)
</td>  </tr>  </table>
or, introducing f0 , f1 , f2 , ... for the components of f
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
y[i] = fi(y) for 0 &le; i &lt; N .</td><td align=right>(2)
</td>  </tr>  </table>
<p>It is assumed that the initial value of y and the function f are such
that the repeated assignments of the form
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
&lt;y[i]:= fi(y) &gt;</td><td align=right>(3)
</td>  </tr>  </table>
will lead in a finite number of steps to y being a solution of (1). In (3)
we have used Lamport&rsquo;s notation of the angle brackets: they enclose &ldquo;atomic
actions&rdquo; which can be implemented by ensuring mutual exclusion in time (when
they are considered &ldquo;to take time&rdquo;). The sequence of i-values for which the
assignments are carried out must be one of some sort of &ldquo;fair random order&rdquo;
in which, for instance, a finite upper bound is given for the maximum number of
consecutive assignments &mdash;i.e.: i-values&mdash; in which a given j (0 &le; j &lt; N)
  
does not occur: in other words, we assume the absence of individual starvation
guaranteed.
<p>Because equation (1) is assumed to have at least one solution, such an
initial value of y always exists: start with y equal to a solution! This
is, of course, not an interesting case; Scholten has formulated more general
conditions (on the domain of the elements of y , on the functions f and on the
initial value for y ) under which convergence in a finite number of steps, and
towards a solution which is uniquely determined by the initial value of y , can
be guaranteed. These conditions do not interest us here: we shall study the
more general situation in which in a finite number of steps a not-necessarily
unique solution of (1) will be reached. (In passing we note that also the
marking in the garbage collection had that characteristic of nondeterminacy.)
<p class=noindent><b>Note 1</b>. The mechanisms we shall design will even &ldquo;operate&rdquo; when no solution of
(1) is reached within a finite number of steps: then they will fail to terminate.
In this sense our programs can be considered as a multi-dimensional 
generalization of the Linear Search. (End of note 1.)
<p>We consider solutions consisting of N repetitive processes of the form:
<table width=100%>
<tr><td valign=top width=10%> prog.i: </td><td valign=top>
<b>do</b> ... &rarr; &lt;y[i]:= fi(y) &gt; <b>od</b></td><td align=right>PR0
</td>  </tr>  </table>
but the problem is, of course, what to fill in for the dots. The roughest sketch
would be
<table width=100%>
<tr><td valign=top width=10%> prog-i: </td><td valign=top>
<b>do</b> &lt;<u>E</u> j: &le; 0 &lt; N: y[j] &ne; f(y) &gt; &rarr; y[i]:= fi(y) &gt; <b>od</b></td><td align=right>PR1
</td>  </tr>  </table>
but this version is rejected for two reasons: firstly, the guard is an 
unacceptably large grain of action, secondly and more important, we want the construction
of prog.i to be independent of fj for j &ne; i . We can remove the second
objection and reduce the first one by introducing a global array e with the
boolean elements e[i] for 0 &le; i &lt; N , and maintaining
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(<u>A</u> i: 0 &le; i &lt; N: e[i] &rArr; (y[i] = fi(y))) .</td><td align=right>(4)
</td>  </tr>  </table>
<p>Because (4) is trivially satisfied by all e[i] false, we assume that
initialization. with the convention that j ranges over 0 &le; j &lt; N , we can
now write (with some more notational liberties that will be explained later)

<table width=100%>
<tr><td valign=top width=10%> prog.i: </td><td valign=top>
&nbsp;</td><td align=right>PR2
</td>  </tr>  </table>
<table> <tr> <td>&nbsp; &nbsp; </td> <td colspan = 6>
  do &lt; <u>E</u> j: <b>non</b> e[j] &gt; &rarr;              </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 4>
          &lt; <b>if</b> y[i] = fi(y) &rarr; e[i]:= true &gt;  </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
              &#x25af; y[i] &ne; fi61) &rarr; y[i]:= fi(y);    </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                              (<u>A</u> j: e[j]:= false) &gt;  </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td colspan = 3>
           <b>fi</b>                                           </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; </td> <td colspan = 5>
    <b>od</b>                                                  </td> </tr> <tr> <td colspan = 7>
                                                               </td> </tr>
</table>
<p class=noindent><b>Note 2.</b> I have used the abbreviation (<u>A</u> j: e[j]:= false) for the program that
performs the assignments e[0]:= false through e[N-1]:= false in some order.
Because here it is part of an atomic action, the undefinedness of the order is
still irrelevant. (End of note 2.)
<p class=noindent><b>Note 3.</b> In PR2 , the whole alternative construct is effectively a single
atomic action. In view of later needs, however, I have given each alternative
its own closing angle bracket. (End of note 3.)
<p class=noindent><b>Note 4.</b> In the first alternative of PR2 , the superfluous assignment to y[i]
has been suppressed. (End of note 4.)
<p class=noindent><b>Note 5</b>. In a more abstract version we could have introduced a set E of those
processes j for which y[j] = fj(y) is guaranteed to hold. In that case
(<u>A</u> j: e[j]:= false) would have been coded as E:= &#x2205; . Honesty forces me to
mention that during more abstract explorations I have, indeed, used such a
notation, and to admit that the reason that I don&rsquo;t do so now could very well be,
that the symbols of set theory are not on my typewriter. The boolean array can
be regarded as the characteristic function for E; the problem, of course, is
that we can also regard the value of E as a coding for the value of e . (End
of note 5.)
<p>It is clear that both alternatives in PR2 leave (4) invariant. It is
also clear that y = f(y) is a stable state as far as y is concerned. 
Termination of one of the processes implies (<u>A</u> j: e[j]) , from which, together
with (4), y = f(y) can be deduced, i.e. that the stable state has been reached,
and that all other programs will terminate as well.
<p class=noindent><b>Note 6</b>. If we really want to spell this out, we would have to <b>show</b> the invariance
of, say,

<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      (<u>A</u> j: e[j]) <b>and</b> y = f(y)  . </td> </tr>
</table>
As we have more difficult problems ahead of us, I shall not waste my time on that
demonstration: it is really trivial. (End of note 6.)
<p align="center" class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>*</p> 
<p>One of the ways in which we could try to chop up the large grain of action
in PR2 would be to separate inspection of y , computation of fi , and 
modification of y[i] . with a local vector vi and a local &ldquo;scalar qi we
could try:
<table width=100%>
<tr><td valign=top width=10%> prog.i: </td><td valign=top>
&nbsp;</td><td align=right>PR3
</td>  </tr>  </table>
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
    do.&lt; <u>E</u> j: <b>non</b> e[j] &gt; &rarr;                                        </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
            &lt; vi:= y &gt; {y[i] = vi[i]};                                               </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
            qi:= fi(vi) {qi = fi(vi)};                                                     </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
            <b>if</b> vi[i] = qi &rarr; &lt; e[i]:= true &gt;                              </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; </td> <td>
             &#x25af; vi[i] &ne; qi &rarr; &lt; y[i]:= qi; (<u>A</u> j: e[j]:= false) &gt; </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
            <b>fi</b>                                                                      </td> </tr> <tr> <td></td> <td colspan = 3>
    <b>od</b>                                                                              </td> </tr>
</table>
<p class=noindent><b>Note 7</b>. We have allowed ourselves vi:= y as an abbreviation for
<u>A</u> j: vi[j]:= y[j]) . Upon its completion the relation &ldquo;y[i] = vi[i]&rdquo; can be
regarded as a local assertion of prog.i , in spite of the fact that it contains
a reference to the global y[i] : we can do so because for j &ne; i , prog.j only
inspects, but never modifies the value of y[i] . (End of note 7.)
<p>The proof of the invariance of (4) , however, fails for the first 
alternative in the following manner. The weakest pre-condition for &lt; e[i]:= true &gt;
to establish (4) is
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
    (4) <b>and</b> y[i] = fi(y) , </td> </tr>
</table>
but we can only guarantee &mdash;see the assertions between braces&mdash;
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
    (4) <b>and</b> y[i] = vi[i] = qi = fi(vi) , </td> </tr>
</table>
and in order to conclude the former from the latter we need the further assumption
y = vi . Program PR3 is, indeed, wrong, but the failure of its correctness proof
indicates how to repair it.
<p>Because the non-destruction of (4) by &lt; e[i]:= true &gt; depends on the
truth of y = vi , we can repair program PR3 by replacing &lt; e[i]:= true &gt; by
                   
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
    &lt; e[i]:= (y = vi) &gt; </td> </tr>
</table>
which is a shorthand notation for
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
    &lt;e[i]:= (<u>A</u> j: y[j] = vi[j]) &gt; . </td> </tr>
</table>
Because &mdash;-specially for large N &mdash; this is again a bulky atomic action, we can
introduce a global array d with boolean elements d[i] for 0 &le; i &lt; N , such
<table width=100%>
<tr><td valign=top width=10%> that </td><td valign=top>
(<u>A</u> i: 0 &le; i &lt; N: d[i] &rArr; (y = vi)) .</td><td align=right>(5)
</td>  </tr>  </table>
If we can keep (5) invariantly true, replacing &lt; e[i]:= true &gt; in PR3 by
&lt; e[i]:= d[i] &gt; ensures that e[i] will not be set to true erroneously, i.e.
so as to destroy the truth of (4) . Assuming all the d[i] initialized to false,
keeping (5) invariant leads to the following program, that is now derived from
PR3 in a straightforward manner:
<table width=100%>
<tr><td valign=top width=10%> prog.i: </td><td valign=top>
&nbsp;</td><td align=right>PR4
</td>  </tr>  </table>
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 6>
     do &lt; <u>E</u> j: <b>non</b> e[j] &gt; &rarr;          </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 4>
            &lt; d[i]:= true; vi:= y &gt; ;                   </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 4>
            qi:= fi(vi);                                      </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 4>
            <b>if</b> vi[i] = qi &rarr; &lt; e[i]:= d[i] &gt; </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td colspan = 3>
             &#x25af; vi[i] &ne; qi &rarr; &lt; y[i]:= qi;    </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                              (<u>A</u> j: d[j]:= false);     </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
                             (<u>A</u> j: e[j]:= false) &gt; </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 4>
            <b>fi</b>                                         </td> </tr> <tr> <td></td> <td>&nbsp; </td> <td colspan = 5>
      <b>od</b>                                               </td> </tr>
</table>
<p align="center" class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>*</p> 
<p>The transition from PR2 to PR4 was motivated by something like the
assumption that the fi-computations were time-consuming. Another way of
chopping up atomic actions in PR2 would be to separate the modification of
y[i] from the false-setting of the e[j]&rsquo;s. In the following program, derived
from PR2 , we have introduced a global ghost-variable ef for reasons that
will become clear in a moment; ef is assumed to be initialized at false,
<table width=100%>
<tr><td valign=top width=10%> prog.i: </td><td valign=top>
&nbsp;</td><td align=right>PR5
</td>  </tr>  </table>
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 5>
     do &lt; <u>E</u> j: <b>non</b> e[j] &gt; &rarr;                            </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
        &lt; <b>if</b> y[i] = fi(y) &rarr;  e[i]:= true &gt;                </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td colspan = 2>
             &#x25af; y[i] &ne; fi(y) &rarr; y[i]:= fi(y); ef:= true &gt;; </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                            &lt; (<u>A</u> j: e[j]:= false); ef:= false &gt;    </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 3>
            <b>fi</b>                                                           </td> </tr> <tr> <td></td> <td>&nbsp; </td> <td colspan = 4>
      <b>od</b>                                                                 </td> </tr>
</table>

<p>The reason for introducing the ghost-variable ef becomes clear as soon
as we realize that y[i]:= fi(y) without setting all the e[j]&rsquo;s to false, might
cause a violation of (4) as a result of the modification of y . The 
introduction of ef enables us to express the temporary violation of (4) by replacing
<table width=100%>
<tr><td valign=top width=10%> it by </td><td valign=top>
(<u>A</u> i: 0 &le; i &lt; N: e[i] &rArr; (y[i] = fi(y))) <b>or</b> ef</td><td align=right>(6)
</td>  </tr>  </table>
<p class=noindent><b>Note 8</b>. The name &ldquo;ef&rdquo; is for me a mnemonic for &ldquo;e-implication false&rdquo;. (End of
note 8.) &rsquo;
<p>Thanks to the introduction of ef , (6) is now clearly an invariant; it is,
however, all by itself too weak to conclude that upon termination y = f(y) holds.
is it stands we can only conclude upon termination
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      y = f(y) <b>or</b> ef , </td> </tr>
</table>
a conclusion that suffices, if we can also show the invariance of
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
ef &rArr; (<u>E</u> j <b>non</b> e[j]) .</td><td align=right>(7)
</td>  </tr>  </table>
for then ef is guaranteed to be false upon termination. It is indeed possible
to show that (7) is invariant as well, and that, therefore, program PR5 is
correct.
<p>Without the introduction of more elaborate ghost-variables, we need for
the demonstration of the invariance of (7) a somewhat different argument. 
Consider an atomic action that causes for ef a transition from false to true;
let this be performed by prog.k . Then, prior to that atomic action we can assert
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
     (6) <b>and</b> <b>non</b> ef <b>and</b> y[k] &ne; fk(y) </td> </tr>
</table>
from which <b>non</b> e[k] can be concluded. Because prog.k is the only one that can
reset e[k] to true and cannot cause this resetting to take place before 
resetting ef to false, e[k] must remain false &mdash;and, hence, (<u>E</u> j: <b>non</b> e[j])
must remain true&mdash; as long as ef remains true.
<p>The operational argument in the preceding paragraph is highly unattractive;
it does, however, show the way out. Introducing a global variable k (0 &le; k &le; N)
we can represent <b>non</b> ef by k = N , and ef by 0 &le; k &lt; N . (In particular:
when k &lt; N , it has been prog.k that lastly caused ef to become true, i.e.
that lastly caused k to become different from N .)
               
<table width=100%>
<tr><td valign=top width=10%> prog.i: </td><td valign=top>
&nbsp;</td><td align=right>PR5&rsquo;
</td>  </tr>  </table>
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 5>
      <b>do</b> &lt; <u>E</u> j: <b>non</b> e[j] &gt; &rarr;                  </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 4>
              &lt;<b>if</b> y[i] = fi(y) &rarr; e[i]:= true &gt;              </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
                 &#x25af; y[i] &ne; fi(y) &rarr; y[i]:= fi(y);                </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
                                  <b>if</b> k &lt; N &rarr; skip              </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td>
                                   &#x25af; k = N &rarr; k:= i                </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td colspan = 2>
                                  <b>fi</b> &gt; ;                            </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td colspan = 2>
                                  &lt; (<u>A</u> j: e[j]:= false); k:= N &gt; </td> </tr> <tr> <td></td> <td></td> <td colspan = 4>
              <b>fi</b>                                                       </td> </tr> <tr> <td></td> <td colspan = 5>
      <b>od</b>                                                               </td> </tr>
</table>
<p>The program has been called PR5&rsquo; because it only differs from PR5 by
the ghost-variable . The ghost-variable k is assumed to have been initialized
= N . It is then easy to prove the invariance of
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
k &lt; N &ne; &rArr; <b>non</b> e[k]</td><td align=right>(7&rsquo;)
</td>  </tr>  </table>
(or, if we don&rsquo;t like undefined righthand sides of implications, k = N <b>cor</b> <b>non</b> e[k]).
To complete the treatment, relation (6) must be rewritten as
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(<u>A</u> i: 0 &le; 1 &lt; N: e[i] &rArr; (y[i] = fi(y))) <b>or</b> k &lt; N .</td><td align=right>(6&rsquo;)
</td>  </tr>  </table>
<p align="center" class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>*</p> 
      
<p>The above three stars stand for as many days of vein struggle, when I
tried to merge the two achievements embodied in PR4 and PR5&rsquo; . Eventually I
had some success when I started from the rejected correction of PR3 . In the
text below, the e[i]&rsquo;s have been renamed for reasons that will become clear
later; initially, all the g[i]&rsquo;s are false.
<table width=100%>
<tr><td valign=top width=10%> prog.i: </td><td valign=top>
&nbsp;</td><td align=right>PR6
</td>  </tr>  </table>
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
    <b>do</b> &lt; <u>E</u> j: <b>non</b> g[j] &gt; &rarr;                                </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
           &lt; vi:= y &gt; {vi[i] = y[i]};                                               </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
           qi:= fi(vi) {qi = fi(vi)};                                                     </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
           <b>if</b> vi[i] = qi &rarr; &lt; g[i]:= (y = vi) &gt;                          </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; </td> <td>
            &#x25af; vi[i] &ne; qi &rarr; &lt; y[i]:= qi; (<u>A</u> j: g[j]:= false) &gt; </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
           <b>fi</b>                                                                      </td> </tr> <tr> <td></td> <td colspan = 3>
    <b>od</b>                                                                             </td> </tr>
</table>
I won&rsquo;t repeat its correctness proof, but proceed immediately to chop up its
last atomic action as in PR5&rsquo;. &rsquo;
                   
Initially, k = N ; for the reformulation of (7&rsquo;) we can assume g[N] to be
constantly false .
<table width=100%>
<tr><td valign=top width=10%> prog.i: </td><td valign=top>
&nbsp;</td><td align=right>PR7
</td>  </tr>  </table>
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 7>
              <b>do</b> &lt; <u>E</u> j: <b>non</b> g[j] &gt; &rarr;  {k &ne; i}     </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 6>
                  L0: &lt; vi:= y &gt; {vi[i] = y[i]};                               </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 5>
                      qi:= fi(vi) {qi = fi(vi)};                                     </td> </tr> <tr> <td></td> <td></td> <td colspan = 6>
                  Ll: <b>if</b> vi[i] = qi &rarr; &lt; g[i]:= (y = vi) &gt;          </td> </tr> <tr> <td></td> <td></td> <td colspan = 6>
                  L2: &nbsp; &#x25af; vi[i] &ne; qi &rarr; &lt; y[i]:= qi;          </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
                                          <b>if</b> k &lt; N &rarr; skip             </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td>
                                           &#x25af; k = N &rarr; k:= i               </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td colspan = 2>
                                          <b>fi</b>  &gt;  ;                         </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
                                  L3: &lt; (<u>A</u> j: g[j]:= false); k:= N &gt;    </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; </td> <td colspan = 4>
                        <b>fi</b> {k &ne; i}                                         </td> </tr> <tr> <td></td> <td colspan = 7>
              <b>od</b>                                                              </td> </tr>
</table>
<p>In the following correctness proof the atomic actions are referred to
by the label on the line of their opening angle bracket.
<p>We first observe that {k &ne; i} is a local assertion for prog.i in isolation,
valid everywhere except between L2 and L3 : L0 and L1 don&rsquo;t assign to k ,
L2 may destroy it, but, because N &ne; 1 , L3 will restore {k &ne; 1} . But,
although k is a global variable, {k &ne; i} also remains true in combination
with the other prog.j&rsquo;s , because neither their assignment k:= j (j &ne; i !),
nor their assignment k:= N (N &ne; i !) can destroy it.
<p>We next observe the invariance of
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(<u>A</u> j: g[j] &rArr; (y[i] = fj(y))) <b>or</b> k &lt; N .</td><td align=right>(8)
</td>  </tr>  </table>
Action L0 does not assign to its variables. Action L1 can only affect
the implication for j = i ; the weakest precondition of L1 for that 
implication is, according to the Axiom of Assignment,
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(y = vi) &rArr; (y[i] = fi(y))</td><td align=right>&nbsp;
</td>  </tr>  </table>
which follows, indeed, from the local assertions and the guard, for
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
y[i] = vi[i] = qi = fi(vi) .</td><td align=right>&nbsp;
</td>  </tr>  </table>
Action L2 establishes (8) on account of its term k &lt; N , and action L3
also establishes (8) because it makes. all implications vacuously true.
                           
<p>The next invariance to be established is
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(<u>A</u> j: g[j] &rArr; (vj = y)) <b>or</b> k &lt; N .</td><td align=right>(9)
</td>  </tr>  </table>
It is, like (8), initially true because then all the g[j] are false; actions
L0&rsquo; and L1 can affect in (9) only the implication for j = i , but make that
implication true, action L2 establishes the truth of (9) on account of its
term k &lt; N , and action L3 , again, makes all implications vacuously true.
<p>The next invariant relation is
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
k &lt; N &rArr; <b>non</b> g[k] .</td><td align=right>(10)
</td>  </tr>  </table>
Action L0 does not affect its variables, action L1 does not do so on
account of the local assertion {k f i}, action L3 makes (10) vacuously true.
Action L2 leaves (10) clearly invariant if, initially, k &lt; N&rsquo;; only if
initially k = N , we need for L2 a more elaborate argument, for we have to
show that then, initially, <b>non</b> g[i] holds. We shall demonstrate this by
deriving a contradiction from the assumption k = N and g[i] . From this 
assumption and (8) we conclude y[i] = fi(y) , from this assumption and (9) we
conclude vi = y , hence y[i] = fi(vi) : from the local assertions and the
guard, however, we derive y[i] = vi[i] &ne; qi = f&rsquo;i(vi) , which gives the
required contradiction. This concludes the demonstration of the invariance
of (10) .
<p>On account of (10) , (<u>A</u> j: g[j]) &rArr; k = N, and hence, on account of (8),(9)
we can conclude that (<u>A</u> j: g[j]) &rArr; (<u>A</u> j: y[j] = fj(y) <b>and</b> vj = y). This
concludes our treatment of PR7.
<p align="center" class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>*</p> 
<p>We now introduce d[i]&rsquo;s and e[i]&rsquo;s, for the time being considered as
ghost-variables. They are initialized as false.
<table width=100%>
<tr><td valign=top width=10%> Prog.i </td><td valign=top>
&nbsp;</td><td align=right>PR8
</td>  </tr>  </table>
<table> <tr> <td>&nbsp; &nbsp; </td> <td colspan = 6>
  <b>do</b> &lt; <u>E</u> j: <b>non</b> g[j] &gt; &rarr;                                                  </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 5>
      L0: &lt; d[i]:= true; vi:= y &gt; ;                                                                 </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 4>
          qi:= fi(vi);                                                                                    </td> </tr> <tr> <td></td> <td></td> <td colspan = 5>
      L1: <b>if</b> vi[i] = qi &rarr; &lt; g[i]:= (y = vi); e[i]:= d[i] &gt;                              </td> </tr> <tr> <td></td> <td></td> <td colspan = 5>
      L2:  &#x25af; vi[i] &ne; qi &rarr; &lt; y[i]:= qi; (<u>A</u> j: d[j]:= false);                      </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td colspan = 2>
                              <b>if</b> k &lt; N &rarr; skip &#x25af; k = N &rarr; k:= i <b>fi</b> &gt; ; </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
                             L3: &lt; (<u>A</u> j: g[j]:= false; e[j]:= false);                           </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                                   k:= N &gt;                                                             </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td colspan = 2>
                              <b>fi</b>                                                                   </td> </tr> <tr> <td></td> <td colspan = 6>
  <b>od</b>                                                                                               </td> </tr>
</table>

<p>In addition to the invariance of (8), (9), and (10) we establish the 
invariance of
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(<u>A</u> j: d[j]&rArr;(vj =y)) .</td><td align=right>(11)
</td>  </tr>  </table>
Relation (11) is true to start with, L0 leaves it invariant, and so do L1, L2
and L3 .
<p>But now we are in a position to establish
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(<u>A</u> j:&rArr; g[j]) .</td><td align=right>(12)
</td>  </tr>  </table>
because L0, L2, and L3 leave it trivially invariant, and L1 does so on account
of (11) .
<p>From (12) we deduce that (<u>A</u> j: e[j]) &rArr; (<u>A</u> j: g[j]). Hence, the program
is still correct if we turn the e&rsquo;s and the d&rsquo;s into non-ghost-variables, and
replace the outer guard by &lt;<u>E</u> j: <b>non</b> e[j] &gt; . After that replacement, however,
we can regard the g&rsquo;s as ghost-variables! Removing the operations on the g&rsquo;s
and on k , we get
<table width=100%>
<tr><td valign=top width=10%> prog.i: </td><td valign=top>
&nbsp;</td><td align=right>PR9
</td>  </tr>  </table>
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 5>
    <b>do</b> &lt; <u>E</u> j: non e[j] &gt;&rarr;  .                                        </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 4>
            &lt; d[i]:= true ; vi:= y &gt; ;                                                 </td> </tr> <tr> <td></td> <td></td> <td colspan = 4>
            qi:= fi(vi);                                                                     </td> </tr> <tr> <td></td> <td></td> <td colspan = 4>
            <b>if</b> vi[i] = qi &rarr; &lt; e[i]:= d[i] &gt;                                </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; </td> <td colspan = 3>
             &#x25af; vi[i] &ne; qi &rarr; &lt; y[i]:= qi; (<u>A</u> j: d[j]:= faise) &gt; ; </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
                            &lt; (<u>A</u> j: e[j]:= false) &gt;                             </td> </tr> <tr> <td></td> <td></td> <td colspan = 4>
            <b>fi</b>                                                                        </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                                 .                                                           </td> </tr> <tr> <td></td> <td colspan = 5>
    <b>od</b>                                                                                </td> </tr>
</table>
<p align="center" class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>*</p> 
<p>(Ihe above three stars stand for an interval of about two weeks, during
&rsquo;which I wrote EWD623 through EWD626, while E.S.Scholten continued to think about
his problem. As I have seen his work in the meantime, the following is unavoidably
heavily influenced by his results.)
                   

<p>In my next refinement, I start again from PR5 (or PR5&rdquo;) , but wish
this time to replace the last line, which is effectively
<table width=100%><tr><td valign=top width=10%>
</td><td>&lt;(<u>A</u> j: e[j]:= false) &gt;
</td></tr>
<tr><td valign=top>
by</td><td>(<u>A</u> j: &lt;e[j]:= false &gt;)
</td>  </tr>  </table>
i.e. the single grain that sets all the e[j]&rsquo;s false should be broken up into
N little grains, each setting a single e[j] . The single global ghost-boolean
is no longer sufficient, nor is the single global ghost-integer from PR5&rsquo; .
We propose to introduce for each prog.i a boolean ghost-array ri , with
elements ri[0] through ri[N-1] , all initialized at false, and each ri[j]
representing prog.i&rsquo;s &ldquo;obligation&rdquo; to set e[j]&rsquo;] to false.
<table width=100%>
<tr><td valign=top width=10%> prog.i: </td><td valign=top>
&nbsp;</td><td align=right>PR10
</td>  </tr>  </table>
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 6>
      <b>do</b> &lt; E j: <b>non</b> e[j] &gt; &rarr; {(<u>A</u> j: <b>non</b> ri[j]}     </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 5>
            L0: &lt; <b>if</b> y[i] = fi(y) &rarr; e[i]:= true &gt;                       </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 4>
                  L1: &#x25af; y[i] &ne; fi(y) &rarr; {Ri} y[i]:= fi(y);                  </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                                   (<u>A</u> j: ri[j]:= true) &gt; ;                      </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
                               L2j: (<u>A</u> j: &lt; e[j], ri[j]:= false, false &gt; )   </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
                     <b>fi</b>                                                            </td> </tr> <tr> <td></td> <td colspan = 6>
      <b>od</b>                                                                           </td> </tr> <tr> <td colspan = 7>
                                                                                          </td> </tr>
</table>
<p class=noindent>The first atomic action has two labels, labelling its alternative courses of
action; on the last line we have condensed N labels. It is clear that
(<u>A</u> j: <b>non</b> ri[j]) is an invariant of prog.i&rsquo;s repeatable statement. (Remember
that the ghost-variable ri is local to prog.i .) Again we have to prove that
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(<u>A</u> j: e[j]) &rArr; (<u>A</u> j: y[j] = fj(y)) .</td><td align=right>(13)
</td>  </tr>  </table>
This conclusion (13) is justified, provided we can find N predicates Rj ,
such that
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(<u>A</u> j: (y[j] &ne; fj(y)) &rArr; Rj)</td><td align=right>(14)
</td></tr>
<tr><td valign=top> and </td><td valign=top>
(<u>A</u> j: e[j]) &rArr; (<u>A</u> j: <b>non</b> Rj)</td><td align=right>(15)
</td>  </tr>  </table>
Intuitively &mdash;that is what (14) says&mdash; Rj may be interpreted as &ldquo;it is 
uncertain whether the j-th equation of (2) is satisfied. We shall, however,
define Rj quite differently &mdash; as will be shown in a moment, in a way such
that (15) is obviously satisfied&mdash; and then prove the invariance of (14) .
<p>Because (15),can be rewritten as
            
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(<u>E</u> j: Rj) &rArr; (<u>E</u> j: <b>non</b> e[j])</td><td align=right>, &nbsp;
</td>  </tr>  </table>
an analogy with the marking process of the on-the-fly garbage collection, 
indeed, presents itself. In the latter we had relations like &ldquo;the existence of
a white reachable node implies the existence of a grey node&rdquo;, or more precisely
&ldquo;for each white reachable node, there exists a grey node from which it can be
reached via (what we called) a propagation path.&rdquo; In other words, (15) is
trivially satisfied if we can define Rj to be true if and only if node j
is in some sort of transitive closure starting from the nodes with a false e .
(If all the e&rsquo;s are true, the set of starting points, and therefore the whole
transitive closure is empty.)
<p>A bold guess is to interpret the truth of ri[j] as the presence of an
arrow from node nr.i to node nr.j and to interpret Rj as <b>non</b> e[j] or
reachable via a directed path from another e that is false. In formula
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
Rj = (<b>non</b> e[j] <b>or</b> (<u>E</u> k: Rk <b>and</b> rk[j]))    (see EWD622-18)</td><td align=right>(16)
</td>  </tr>  </table>
from which (15) follows. Because initially all e[j]&rsquo;s are false, all Rj&rsquo;s are
initially true; we have thus established the initial truth of (14), the 
invariance of which will be demonstrated now.
<p>The choice L0 leaves (14) invariant: its implications for j &ne; i are
left unaffected because their antecedents remain (trivially) unaffected, and
because their consequents are left unaffected on account of (16) and the fact
that L0 is executed under the circumstance that node nr.i has no outgoing
arrows (remember (<u>A</u> j: <b>non</b> ri[j]) ). The implication for j = i is and 
remains vacuously true on account of the falsity of its antecedent, as implied
by the guard.
<p>The choice L1 leaves (14) invariant. On account of the guard and the
initial truth of (14) we conclude that it can only be chosen when Ri holds.
Because the truth of Ri is not destroyed by the creation of arrows, and
because of (16)
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(A k, j:(Rk <b>and</b> rk[j]) &rArr;Rj)</td><td align=right>(17)
</td>  </tr>  </table>
L1 establishes Rj for all j , i.e. upon completion each implication of (14)
holds on account of its true consequent.
                       
<p>Also each of the individual actions L2j leaves (14) invariant, because
on account of (16), removal of an incoming arrow of node j , together with
e[j]:= false can never cause for Rj &mdash;and hence for any other Rk&mdash; the
transition from true to false.
<p>This could complete our treatment of PR10. There is, however, a little
bit more that might be worth observing. If it is the sole purpose of the
arrows to propagate from nodes with <b>non</b> e the property R , and,no obviously
redundant arrows are retained, we may hope that even
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(<u>A</u> k, j: rk[j] &rArr; (Rk <b>and</b> Rj))</td><td align=right>(18)
</td>  </tr>  </table>
is invariantly true.
<p>We have already observed that choice L0 cannot affect Rj for j &ne; i .
If, initially, node nr.i has an incoming arrow, i.e. there exists a k such
that rk[i] holds , then k &ne; i because of <b>non</b> ri[i] ; then (18) tells us, that
initially Rk is true. We have just established that Rk then remains true,
and on account of (17), Ri remains true. If node nr. i has no incoming
arrows, Ri becoming false can do no harm to (18) , because it has no 
outgoing arrows either when L0 is executed.
<p>L1 does not violate (18) because it is only executed under the truth
of Ri and all Rj are certainly true upon completion.
<p>L2j does not violate (18) either. Because the ri[j] are local 
ghostvariables of prog.i , the initial truth of ri[j] is obvious; therefore (18)
tells us that Rj holds initially and the assignment e[j]:= false ensures that
Rj holds upon completion. Hence we can conclude that any act L2j leaves all
Rj unchanged. Therefore, all rightnhand sides of (18) are constant; only
one antecedent is strengthened, and thus (18) is indeed an invariant.
<p>Having established that any act L2j leaves all Rj unchanged, that
L1 can only cause for Rj a transition from false to true, and that L0 can
only affect Ri , we see that the truth of Ri is not destroyed by any prog.j
for j &ne; i , and that only L0 of prog.i can set Ri to false.
<p align="center" class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>*</p> 
                    
<p>(The above three stars stand for a two-hour failure to prove the 
correctness of the next version without the introduction of more ghost-variab1es,
followed by a restless night.)
<p>Encouraged by the success of the ri&rsquo;s and the Ri&rsquo;s I shall now try to
combine the introduction of the vi from PR9 with the chopping up of the
false-setting of the e[j]&rsquo;s from PR10 . I think that this text should not
become too repetitive and that I should make a larger jump : in addition I
shall also separate the false-setting of the d[j]&rsquo;s from the assignment to
y[i], and furthermore the false-setting of the d[j]&rsquo;s will be chopped up.
Analogous to the ri[j]&rsquo;s we introduce qi[j]&rsquo;s to record prog.i&rsquo;s &ldquo;obligation&rdquo;
to set d[j] to false. 
<p>In my treatment of PR10 I dislike that the nice relation (18) could
only be derived at the end. In order to derive it earlier, I shall try a
new proof experiment: I intend to strengthen guards of the alternative
construct by adding &ldquo;ghost-constraints&rdquo; and show eventually that the strengthening
was ineffective because the truth of the added term is implied by the truth of
the guard it was supposed to strengthen. The choice of the strengthening is
inspired by my desire to keep the initial proof of the invariance of (18)
simple. (Because the strengthened guards contain ghost-variables, I have
placed them between (temporary) angle brackets.) We consider the following
program, where Ri is defined as by (16) .
<table width=100%>
<tr><td valign=top width=10%> prog.i </td><td valign=top>
&nbsp;</td><td align=right>PR11
</td>  </tr>  </table>
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 6>
    <b>do</b> &lt; <u>E</u> j: <b>non</b> e[j] &gt; &rarr; {<u>A</u> j: <b>non</b> ri[j]}                       PR11 </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 5>
         L0: &lt; d[il:= true; vi:= y &gt; {y[i] = vi[i]};                                                           </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 4>
             qi:= fi(vi) {qi = fi(vi)};                                                                              </td> </tr> <tr> <td></td> <td></td> <td colspan = 5>
         L1: <b>if</b> vi[i] = qi &rarr; {y[i] = fi(vi)} &lt; e[i]:= d[i] &gt;                                       </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td colspan = 3>
              &#x25af; &lt; vi[i] &ne; <b>and</b> Ri &gt; &rarr; {y[i] &ne; fi(vi)}                                  </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td>
                  L2: &lt; y[i]:= qi; (<u>A</u> j: qi[j], ri[j]:= true, true ) &gt; ;                                </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
                 L3j: (<u>A</u> j: {ri[j]} &lt; d[j], qi[j]:= false, faise &gt; );                                   </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td colspan = 2>
                 L4j: (<u>A</u> j: {ri[j]} &lt; e[j], ri[j]:= false, false &gt; )                                    </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 4>
             <b>fi</b>                                                                                               </td> </tr> <tr> <td></td> <td colspan = 6>
    <b>od</b>                                                                                                        </td> </tr>
</table>
<p>L0 and L3j can trivially not affect any Rj. L4j , although it 
removes incoming arrows for node nr.j , can never cause for Rj a transition
                 
from true to false, as it leaves Rj true on account of the final <b>non</b> e[j] .
Action L2, that only adds arrows, cannot effectuate for Rj a transition
from true to false either. Hence, L1 is the only action that can do so. But
because L1 is executed under absence of outgoing arrows, it can only do so for
Ri ; hence all through the second alternative Ri which occurs in the guard
is invariantly true; hence &mdash;on account of (17)&mdash; action L2 makes all Rj
true, and &mdash;as Ri <b>and</b> ri[j] is a pre-condition for L4j - actions L4j
find and leave the Rj&rsquo;s true.
<p>Now we are ready to prove for PR11 the invariance of
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(<u>A</u> k, j: rk[j] &rArr; (Rk <b>and</b> Rj))</td><td align=right>(18)
</td>  </tr>  </table>
L0 and L3j trivially don&rsquo;t effect (18), L4j leaves the consequents unaffected
and only strengthens an antecedent, L2 makes all consequents true and L1 does
not violate (18) either, as it can only set Ri false in the absence of 
incoming arrows &mdash;as the existence of a Rk <b>and</b> rk[i] will keep it true&mdash; and
L1 is executed under the absence of outgoing arrows.
<p>The next step is to draw as quickly as possible the relevant conclusion
for which we need the qi[j]&rsquo;s, and to eliminate them from then onwards from
our consideration. We prove the invariance of
(<u>A</u> j: (vi &ne; y <b>and</b> d[j]) &rArr; (<u>E</u> k: qk[j])) (19)
L0 can only affect the i-th implication, but leaves its antecedent false,
action L1 does affect none, L2 leaves all consequents true, L3j can
only affect the j-th implication, but it leaves its antecedent false, and
L4j&rsquo; affects none. Initially all antecedents are false, and the universal
validity of (19) has been established.
<p>Because &mdash;remember that the ri and qi are local variables of prog.i !&mdash;
it is easily established that (<u>A</u> k, j; qk[j] &rArr; rk[j]) , we can deduce from
(19)
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(<u>A</u> j: (vj &ne; y <b>and</b> d[j]) &rarr;(<u>E</u> k: rk[j]) .</td><td align=right>(20)
</td>  </tr>  </table>
From now on we won&rsquo;t refer to the qi&rsquo;s anymore; we shall need (20) once.
In order to prove the invariance of (14) we may expect &mdash;because such
a circumstance is not unusual at all&mdash; to have to strengthen it. I propose
               
to do so by weakening the antecedents y[j] &ne; fj(y) , because in view of the
local assertions in the alternative clause of PR11 it seems attractive to
replace them by y[j] &ne; fj(vj) <b>or</b> y &ne; vj
<br>(from the negation of which y[j] = fj(y) duly follows). Because we also
expect d[j] to hold eventually, it seems safe to weaken the antecedents still
further by adding the term &ldquo;<b>or</b> <b>non</b> d[j]&rdquo; . Thus we arrive, inspired by (14),
at our tentative invariant relation &mdash;initially trivially true&mdash;
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(<u>A</u> j: (y[j] &ne; fj(vj) <b>or</b> y &ne; vj <b>or</b> <b>non</b> d[j] &rArr; Rj)</td><td align=right>(21)
</td>  </tr>  </table>
<p class=noindent>Action L2 , which sets all consequents true, is harmless, action L3j can
only affect the j-th implication, but is harmless because L3j is executed under
the invariant truth of rifj] and on account of (18) under the invariant truth &rsquo;
of its consequent Rj . Any action L4j is trivially harmless now we have
already established that it leaves the Rj&rsquo;s unaffected. We are left with L0
and L1 .
<p>Action L0 leaves the consequents unchanged and can only affect the
antecedent for j = i : in that case it suffices to show that a false antecedent
remains false, i.e. with P the negation of the antecedent
<table width=100%><tr><td valign=top width=10%>
P:</td><td> y[i] = fi(vi) <b>and</b> y = vi an_d d[i]
</td>  </tr>  </table>
we have to show that
<table width=100%><tr><td valign=top width=10%>
</td><td>P &rArr; wp(&ldquo;&lt; d[i]:= true; vi:= y &gt;&rdquo;, P) .
</td>  </tr>  </table>
The Axiom of Assignment defines this weakest pre-condition as
<table width=100%><tr><td valign=top width=10%>
</td><td>y[i] = fi(y) and y = y and true 
</td>  </tr>  </table>
The last two terms are true all by themselves, the truth of the first term is
implied by the first two terms of P , and hence L0 leaves (21) invariant.
<p>But what about L1 ? We have established that L1 does not affect Rj
for j &ne; i ; for j &ne; i , it cannot affect the antecedents either, so we only
need to worry about the i-th implication of (21). The assignment &lt; e[i]:= d[i] &gt;,
which leaves its antecedent unaffected, can only violate the implication by
making the consequent Ri false while the antecedent remains true . A
necessary initial condition for &lt; e[i]:= d[i] &gt; to make Ri false &mdash;see
                 
(16) and (1a)&mdash; is
<table width=100%><tr><td valign=top width=10%>
</td><td>d[i] <b>and</b> <b>non</b> (E k: rk[i])
</td>  </tr>  </table>
Combined with the truth of the antecedent, we derive
<table width=100%><tr><td valign=top width=10%>
</td><td>(y[i] &ne; fi(vi) <b>or</b> y &ne; vi) <b>and</b> d[i] <b>and</b> <b>non</b> (<u>E</u> k: rk[i])   .
</td>  </tr>  </table>
Combined with the local assertion
y[i] = fi(vi) as derived from the guard,
we get
<table width=100%><tr><td valign=top width=10%>
</td><td> y &ne; vi <b>and</b> d[i] <b>and</b> <b>non</b> (<u>E</u> k: rk[i])  .
</td>  </tr>  </table>
But on account of (20) this is false; also L1 does not destroy the validity
of (21), whose invariance has now been established.
<p>We are left with the obligation to show that the
ghost-guard Ri can
be omitted. The local assertion y[i] &ne; fi(vi)
as derived from the guard 
implies Ri with the help of (21),
of which we regard the invariance as established.
And this completes the correctness
proof of
<table width=100%>
<tr><td valign=top width=10%> prog.i: </td><td valign=top>
&nbsp;</td><td align=right>PR12
</td>  </tr>  </table>
<table> <tr> <td>&nbsp; &nbsp; </td> <td colspan = 4>
  <b>do</b> &lt; <u>E</u> j: <b>non</b> e[j] &gt; &rarr;         </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
          &lt; d[i]:= true; vi:= y &gt; ;                        </td> </tr> <tr> <td></td> <td></td> <td colspan = 3>
          qi:= fi(vi);                                           </td> </tr> <tr> <td></td> <td></td> <td colspan = 3>
          <b>if</b> vi[i] = qi &rarr; &lt; e[i]:= d[i] &gt;      </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; </td> <td colspan = 2>
           &#x25af; vi[i] &ne; qi &rarr; &lt; y[i]:= qi &gt; ;   </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                          (<u>A</u> j: &lt; d[j]:= false &gt; ); </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>
                          (<u>A</u> j: &lt; e[j]:= false &gt; )  </td> </tr> <tr> <td></td> <td></td> <td colspan = 3>
          <b>fi</b>          .                                   </td> </tr> <tr> <td></td> <td colspan = 4>
  <b>od</b>                                                      </td> </tr>
</table>
<b>Remark</b>. C.S.Scholten&rsquo;s proof allows for the further chopping up of the second
line into
<table width=100%><tr><td valign=top width=10%>
</td><td>&lt; d[i]:= true &gt; ; (A j: &lt;&lt;vi[j]:= y[j] &gt; );
</td>  </tr>  </table>
I think that at this stage I leave that last proof as an exercise for the
reader. (End of remark.)
Concluding remarks.
In one respect I consider the way in which 
this report has developed as
a little bit disappointing:  the constructive flavour of its beginning has largely
disappeared from PR10 onwards.  Rather than to verify a posteriori I prefer to
                   
merge and synthesize proof and program developments. In sequential programming
this art has been raised to a considerable height; when I was halfway this report
I saw the same merge and synthesis emerging during multiprogram development.
This observation excited me, as it would raise the Gries/Owicki theory more
clearly to the status of a tool for construction. Perhaps I should not allow
myself to be too much disappointed by the disappearance of the constructive
flavour: there wasn't much program to be invented anymore, and, besides that,
I was of course biased by having seen Scholten&rsquo;s work.
<p>In other respects I am extremely pleased with it. I have discovered at
least two tricks that were new for me: the change of ghost-variables into
non-ghost-variables and vice versa and &mdash;probably more generally applicable
than the first trick&mdash; the temporary strengthening of guards by adding 
&ldquo;ghost-constraints&rdquo;. I feel that the latter has done a great deal in smoothing the
correctness proof for PR12; in any case it seems a very neat way for preventing
circular arguments.
<p>Furthermore we have now at least a workable &mdash;be it partial&mdash; grip on a
canonical problem that I have shunned for at least four years, since the moment
I designed self-stabilizing systems, and that is the general problem of the
detection that in such distributed system the stabilization towards the legitimate
states has been completed.
<p>The development of this report was not easy: quite regularly it has strained
my agility in the propositional calculus, but I guess that I can learn it. (It
was certainly a good training.) In any case it shows &mdash;to my taste even 
convincing1y&mdash; the feasibility of departing from the usual operational arguments, in
which one tries to visualize classes of computational histories; furthermore it
shows the vast superiority of the non-operational arguments &mdash;once they have been
found!&mdash; over the traditional ones.
<p class=noindent><b>Acknowledgements. </b>I am greatly indebted to C.S.Scholten for drawing my attention
again to this problem, and for contributing so much to its solution. (He was
the first to see clearly the analogy with the garbage collector, and to transfer
the notion of &ldquo;reachability via a path&rdquo; into the solution of this problem.) Further
I am &mdash;as usual&mdash; indebted to the regular members of the &ldquo;Tuesday Afternoon Club&rdquo;.
(End of acknowledgements.)
                  
<p class=noindent><b>Explanation</b>. This was the first project I embarked upon, shortly after Hoare,
Knuth and Traub had given me reason to be grateful to them. Hence the dedication,
in great gratitude and not without some pride. (End of explanation.)
<table width=100%><tr><td valign=top width=50%>
26 May 1977</td><td>
</td></tr>
<tr><td valign=top>
Plataanstraat 5</td><td>prof.dr.Edsger W.Dijkstra
</td></tr>
<tr><td valign=top>
5671 AL NUENEN</td><td>Burroughs Research Fellow
</td></tr>
<tr><td valign=top>
The Netherlands</td><td>
</td>  </tr>  </table>
<b>Note added later</b> concerning (16) on page EWD622 - 11.
Relation (16) is correct in as far as that it certainly holds. If we
want to use it to define the Rj as a solution of (16), we must add the
remark that the Rj&rsquo;s then must be the minimal solution, i.e. the solution
with as few Rj&rsquo;s true as possible; this, because the arrows may form cyclic
paths. (End of note added later.)

<hr />
   <p class="noindent"><font size="-1">Transcribed by Martin P.M. van der Burgt<br />
    Last revision
    <csobj format="MedDate" h="13" region="15" t="DateTime" w="90">
      <!-- #BeginDate format:IS1 -->2014-12-15<!-- #EndDate -->
    </csobj>
  .</font></p>
  <p>&nbsp;</p>
</body></html></div>
</body>
</html>
