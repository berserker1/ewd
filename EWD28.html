  <!DOCTYPE html>
  <html>
  <head>
    <title>Substitution Processes</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: Substitution Processes" />
    <meta name="twitter:title" content="Substitution Processes" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>Substitution Processes</h1>
  <div class='body'>
		<p>A machine defines (by its very structure) a language, viz. its input language: conversely, the semantic definition of a language specifies a machine that understands it. In other words: machine and language are two faces of one and the same coin. I am going to describe such a coin. I leave it entirely to you to decide which of these two aspects of the subject matter of my talk you think the most important as it is rather ridiculous in both aspects. The language I am going to sketch is prohibitively difficult for a human user and the machine I am going to describe is of a perverse inefficiency.</p>
		<p>Therefore, if my mental construction, nevertheless, has a right to exist it should derive this from other qualities. My machine derives this, to my taste and judgement at least, from its extreme simplicity and elegance, from the uniform way in which it performs its (at first glance) rather different operations; the justification for my language are its clearness and the unusually high degree of ambiguity, derived from a strict sequential interpretation and an explicit indication in the program to perform operations, which are usually implicitly understood (and therefore apt to misunderstanding). If one wishes to do so one may regard my machine and my language as being conceived for the purpose of clarification.</p>
		<p>Before I really start with my description I should like to warn you for two intentional omissions. The system I am going to present is the result of a careful choice between a great number of &quot;neighbouring possibilities&quot;. I shall not give my motivations for these choices, I shall even leave the consciously rejected alternatives unmentioned. In other words, I refrain from introducing my system at least in some respects as, say, a &quot;local optimum&quot;. As this diminishes the convincing power of my presentation, I personally regret this omission. I have to omit these motivations, however, for the sake of brevity.</p>
		<p>The other question I shall not touch is the question how to implement this system with the aid of a conventional machine. One might even raise the question &mdash;as I did myself to check that I was not thinking nonsense&mdash; whether it can be implemented at all, no matter how crudely. You have to take my word for it that it can be done. I have worked out a method of implementation to a degree that could convince, I think, the most suspicious auditor of the possibility. But it is my intention not to show you the particulars of this implementation, because I had to incorporate too many arbitrary decisions in which, when mentioned, would only divert the attention from the essentials. In particular, the question of storage allocation will remain untouched.</p>
		<p>My Machine operates on (and under control of) units of information which I call &quot;words&quot;. Without loss of generality I can restrict myself to a finite number of different words, each represented by the same number of bits.</p>
		<p>The machine distinguishes between different kinds of words, say numbers, operators, variables and separators. For the time being we shall confine our attention to the first of these, &quot;number words&quot; and &quot;operator words&quot;.</p>
		<p>A normal arithmetical operation, say the addition or multiplication of two numbers, has two number words as input and one word, also representing a number, as output. The rules according to which a numerical value should be attached to (i.e. derived from the bits of) a number word are embodied in the workings of the arithmetic unit, which has the usual property that these same rules apply to both input and output: the output of the arithmetic unit can be fed into it again at some later stage of the process. As we assume that the properties of the arithmetic unit are constant in time, we may say that the number words have &quot;a fixed meaning&quot;. As the fixed interpretation of number words is coupled to the constant properties of the arithmetic unit it is not so surprising that we shall denote the basic arithmetic operations by operator words (&quot;+&quot;, &quot;-&quot;, &quot;*&quot;, &quot;/&quot;, etc.) the meaning of which can also be regarded as fixed.</p>
		<p>The machine works under control of a program which primarily consists of a string of words. For the time being I shall confine myself to pieces of program prescribing the evaluation of arithmetic expressions.</p>
		<p>Let us consider the expression that would normally be written down as</p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;(&nbsp;7&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;3 )&nbsp;&nbsp;&nbsp;&#150;&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;</p>
		<p class="noindent">in the usual postfix notation (also known under the name &quot;Reversed Polish Notation&quot;) this would give rise to the following sequence of numbers and operators (successive items in this sequence for the sake of representation on paper being separated by spaces)</p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&#150;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.</p>
				<p class="noindent">The well known mechanism especially devised for the sequence evaluation of such an expression is what I prefer to call a &quot;stack&quot;. (This device has been invented and generalized independently by so many people that it is known now under a great variety of names, such as &quot;push down list&quot;, &quot;nesting store&quot;, &quot;cellar&quot;, &quot;last-in-first-out-memory&quot; etc.) If we regard the above sequence of numbers and operators as the string of words representing a piece of program, the machine reads this string word by word from left to right. If it reads a number word, this number (i.e. a copy of this number word) is added to the top of the stack, if it reads an operator word, the operation in question is performed at the top of the stack. In illustration I give on successive lines the successive pictures of the top of the stack is at the right hand side of the line.</p>
				<p class="noindent">
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;7<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;2<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;6<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;13<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;3<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;8<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;6<br>
					&nbsp;.....&nbsp;&nbsp;&nbsp;2</p>
				<p class="noindent">and the net result of the execution of this little piece of program is that the value of the expression has been added to the stack.</p>
				<p>As clearly shown in the above example the machine starts by copying the program text word by word into the top of the stack. Sooner or later this has to be interrupted, otherwise our machine would just be a copying machine. In the above system the process of copying is interrupted by the occurrence of an arbitrary operator in the program text. The function of an operator, therefore, is a double one: firstly it indicates that the copying has to be interrupted for a while, because now an operation has to be performed, secondly it specifies this operation. I propose to separate these two completely different functions: from now on arithmetic operators are primarily treated in exactly the same way as numbers are treated, i.e. the operator word is copied into the stack as well. Every time the process of copying has to be interrupted I shall indicate this in the program explicitly by the insertion of a special word, introduced now and represented by &quot;E&quot; (from &quot;Evaluate&quot;). My machine now takes the following form. It reads the program text word by word, from left to right. By &quot;reading&quot; is meant the following: if the word read is unequal to &quot;E&quot; a copy of it is added to the stack, if the word read is equal to &quot;E&quot;, it is not copied but, instead, the operation takes place as specified (primarily) by the top word of the stack.</p>
				<p>According to these rules the program prescribing the evaluation of the expression of our previous example will now consist of the following string of words</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;/&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&#150;&nbsp;&nbsp;&nbsp;E</p>
				<p class="noindent">and under control of this piece of program text (i.e. when this string of words is &quot;read by the machine&quot;) the top of the stack will be in succession as shown in the following lines:</p>
				<p class="noindent">&nbsp;.....&nbsp;&nbsp;&nbsp;5<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;7<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;2<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;3 *&nbsp;<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;6<br>
					&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;6 &nbsp;&nbsp;+<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;13<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;39&nbsp;&nbsp;&nbsp;13 /<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;3<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;+<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;8<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;6<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;8&nbsp;&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&#150;<br>
					
		&nbsp;.....&nbsp;&nbsp;&nbsp;2
</p>
				<p>As said above the machine performs the operation specified by the top word of the stack when it reads the word &quot;E&quot; in the program text. We shall restrict ourselves to such programs that at such a moment the top word of the stack is indeed an operator word (and not, for instance, a number word). Furthermore we shall restrict ourselves to the case that the immediately underlying stack words be in accordance with any requirements that the execution of the operator at the top may set. (For instance, in the case of the binary arithmetic operations illustrated above the two immediately underlying words must be numbers.)</p>
				<p>In other words: if an operand of an arithmetic operation happens to be an expression we substitute for this expression its numerical value before the operation is called into action, thus appealing to the fact that, primarily, the arithmetic operations are defined only when supplied with numerical operands.</p>
		<p>We regard the replacement of a (sub)expression by its numerical value as a &quot;substitution&quot;, and we indicate explicitly when these substitutions have to be performed, although, linguistically speaking, this rather abundant: &quot;3 + 4&quot; will always be equal to &quot;7&quot;, no matter when we perform this addition.</p>
		<p>This situation, however, radically changes as soon as variables &#151;in contrast to constant numbers&#151; are taken into account. (In the following we shall denote variables with small letters, reserving capital letters for &quot;special words&quot;, such as &quot;E&quot; and others, to be introduced below.) Let us assume that we have to compute the value of the expression</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;<var>x</var> + 4&nbsp;&nbsp;&quot;</p>
				<p class="noindent">at a moment that the value of the variable <var>x</var> equals 3. This means that in the above expression we must substitute for &quot;<var>x</var>&quot; its numerical value at that moment; only after having done so we can perform the arithmetic substitution (&quot;&nbsp;3+4&nbsp;&quot; being replaced by &quot;&nbsp;7&nbsp;&quot;). Given something dependent on x (viz. the expression &quot;&nbsp;<var>x</var>+4&nbsp;&quot;) we create a result (viz. &quot;&nbsp;7&nbsp;&quot;) which, thanks to the fact that we have substituted for <var>x</var> its present value, is made <u>in</u>dependent of the future history of <var>x</var>. We have fixed an &quot;instantaneous picture&quot; of the variable <var>x</var>. Obviously I insist upon indicating explicitly <u>when</u> this instantaneous picture of the variable <var>x</var> (which is varying in time!) has to be taken.</p>
				<p>Now we are going to harvest the first fruits of our labor for the mechanism for this explicit indication is already introduced. The piece of program prescribing the evaluation of the expression</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;<var>x</var> + 4&nbsp;&nbsp;&quot;</p>
				<p class="noindent">
		now takes the following form:
</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&quot;</p>
				<p class="noindent">and under the above assumption the successive pictures of the stack are</p>
				<p class="noindent">.....&nbsp;&nbsp;&nbsp;<var>x</var><br>
					
		.....&nbsp;&nbsp;&nbsp;3<br>
					
		.....&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;4<br>
					
		.....&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;+<br>
					
		.....&nbsp;&nbsp;&nbsp;7
</p>
				<p>Our machine invites us to describe the fact that &quot;the value of the variable <var>x</var> equals 3&quot; in slightly other wordings, viz. that the state of the process is such that reading the word &quot;E&quot; at a moment that the top word of the stack is &quot;<var>x</var>&quot; results in the replacement of this top word by the number word &quot;3&quot;. The variable on the top of the stack is thus regarded as a variable operator which, upon evaluation, is replaced by something dependent on the state of the process at that moment; in this case it is an operator the execution of which sets no special requirements to the immediately underlying stack words. (The similarity between operators and variables will be further stressed by our next example.)</p>
				<p>All words read in the text are added to the stack except the word &quot;E&quot; which causes the machine to perform a substitution. For reason to be explained below we should like to have also the possibility of adding the word &quot;E&quot; to the stack. The framework for this extension, however, is already present. We introduce a special operator, denoted by the word &quot;P&quot; (from &quot;Postponement&quot;), which effects upon evaluation a fixed substitution, vis. its replacement by the word &quot;E&quot;. We shall illustrate the use of the operator &quot;P&quot; in the next example.</p>
		<p>In this example we have three variables, named &quot;<var>x</var>&quot;, &quot;<var>y</var>&quot; and &quot;<var>plinus</var>&quot;. Suppose the state of the process to be such that reading &quot;<var>plinus</var> E&quot; generates the word &quot;+&quot; on top of the stack. When reading the text:</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>y</var>&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>plinus</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&quot;</p>
				<p class="noindent">the top of the stack will show in succession</p>
				<p class="noindent">.....&nbsp;&nbsp;&nbsp;<var>x</var><br>
					.....&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;P<br>
					.....&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;E<br>
					.....&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>y</var><br>
					.....&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>y</var>&nbsp;&nbsp;&nbsp;P<br>
					.....&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>y</var>&nbsp;&nbsp;&nbsp;E<br>
					.....&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>y</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;plinus<br>
					.....&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>y</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;+<br>
					.....&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>y</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;P<br>
					.....&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>y</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;E</p>
				<p class="noindent">and the top of the stack thus contains the string of words which, when read as a piece of program, would effectuate the evaluation of the expression &quot; <var>x</var> + <var>y</var> &quot;. If the value of the variable &quot;<var>plinus</var>&quot; would have been &quot;&#150;&quot; we would have generated (the string of words corresponding to) the expression &quot; <var>x</var> &#150; <var>y</var> &quot;.</p>
				<p>What we have done amounts to a partial evaluation of the expression &quot; <var>x</var> <var>plinus</var> <var>y</var> &quot;, the result again being an expression. In our previous examples the final addition to the stack always consisted of a single number. But a number is a trivial example of an expression and generating not only numbers but also more general expressions as intermediate results is therefore an obvious extension of normal practice.</p>
				<p>Up till now we have described the generation of words on top of the stack but not what we are going to do with these words. Furthermore we have assumed that with respect to given variable the process could be in such a state that evaluation of this variable would give rise to a previously defined substitution, but how this definition should take place is not mentioned in the above. These two gaps in our picture will both be filled by the introduction of the assignment operators.</p>
		<p>For the assignment of a single word value, as in &quot; <var>x</var> := 3 &quot; we could write in our program</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;3&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;:=&nbsp;&nbsp;E&nbsp;&nbsp;&quot;</p>
				<p class="noindent">resulting into the stack pictures:</p>
				<p class="noindent">.....&nbsp;&nbsp;&nbsp;3<br>
					.....&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;<var>x</var><br>
					.....&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;:=</p>
				<p>Upon evaluation of the assignment operator &quot;:=&quot; the machine investigates the immediately underlying word. This must be the variable to which an assignment has to take place; the next underlying word is assigned to this variable (a process, about which more below) and the three words on top of the stack (which have now been processed) are removed from the stack. Until further notice &#151;i.e. a new assignment to the variable &quot;<var>x</var>&quot;&#151; the evaluation of this variable will result in the replacement of the top word of the stack by the word &quot;3&quot;.</p>
				<p>But for the interchanging of left and right hand side this is closely analogous to the assignment statement as known in ALGOL 60. But we need more than that for, in general, the assigned value will not consist out of a single word, but out of a string of words and we must therefore have a means of indicating how deep in the stack the assigned value extends. The simplest way to do this is to insert in the stack a marker, say the special word &quot;T&quot; (from &quot;Terminal&quot;) at the bottom side of the assigned value. Furthermore we introduce another assignment operator &quot;:-&quot; (called the &quot;string assignment&quot; in contrast to the &quot;word assignment&quot; introduced in the previous paragraph). Upon evaluation of this operator the machine investigates the top of the stack in downward direction. The first word (immediately under the operator &quot;:-&quot;) must be the variable to which a value has to be assigned. Thereafter the machine continues its word by word investigation in the downward direction until it meets the special marker &quot;T&quot;: the words passed in this way form together the string that acts as the assigned value.</p>
		<p>The simplest way to add a &quot;T&quot; to the stack would be just to insert the word &quot;T&quot; in the proper place in the program under control of which the stack is being filled. This arrangement, however, will not do; for reasons to be explained later we need the possibility of generating a &quot;T&quot; on top of the stack under control of a program that itself does not contain this word. We can do this with the same trick that enabled us to generate an &quot;E&quot; on top of the stack. We introduce a new operator, denoted by the word &quot;S&quot; (say from &quot;Separator&quot; or because it precedes the &quot;T&quot; in the alphabet) which upon evaluation is replaced by the word &quot;T&quot; and we make it a rule that this will be the only way in which words &quot;T&quot; are added to the stack.</p>
		<p>Using all this we have an alternative to write the assignment statement &quot; <var>x</var> := 3 &quot;, viz.</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;:-&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&quot;</p>
				<p class="noindent">giving in the top of the stack in succession:</p>
				<p class="noindent">.....&nbsp;&nbsp;&nbsp;S<br>
					
		.....&nbsp;&nbsp;&nbsp;T<br>
					
		.....&nbsp;&nbsp;&nbsp;T 3<br>
					.....&nbsp;&nbsp;&nbsp;T 3 <var>x</var><br>
					.....&nbsp;&nbsp;&nbsp;T 3 <var>x</var> :-<br>
					
		.....
</p>
				<p>The net effect of this is equivalent to the previous form using the word assignment&nbsp;&quot;:=&quot;.</p>
				<p>Let us use the more powerful assignment in an example which is an extension of one of our earlier ones, viz. the one describing the partial evaluation of the expression &quot; <var>x</var> <var>plinus</var> <var>y</var> &quot;. The result of this partial evaluation was an expression depending on the variables &quot;<var>x</var>&quot; and &quot;<var>y</var>&quot; and suppose that we want to call this expression &quot;<var>z</var>&quot;. For this purpose we write in the program:</p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot; S&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>y</var>&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>plinus</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>z</var>&nbsp;&nbsp;&nbsp;:-&nbsp;&nbsp;&nbsp;E &quot; .</p>
				<p class="noindent">When the last &quot;E&quot; of this string is going to be read the top of the stack will be as follows (under the same assumption with respect to the value of &quot;<var>plinus</var>&quot;:</p>
				<p class="noindent">.....&nbsp;&nbsp;&nbsp;T&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>y</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>z</var>&nbsp;&nbsp;&nbsp;:-</p>
				<p class="noindent">and after the execution of this assignment the above words will have been removed from the stack, the word &quot;T&quot; inclusive. Until further notice the evaluation of the variable &quot;<var>z</var>&quot; will imply the execution (the &quot;reading&quot;) of the string assigned to it. Upon evaluation of the variable &quot;<var>z</var>&quot; the machine therefore must have access to the first word of this string; when it starts reading this string, however, it must detect the last word of this string. We propose that the assignment operator sees to this by adding again an end marker and for this purpose we can use the very same word &quot;T&quot;. Upon evaluation of the variable &quot;<var>z</var>&quot; the string assigned to it will be read as a piece of program, from left to right until the end marker &quot;T&quot; is met. The new situation resulting from the last assignment can conveniently be represented by:</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;<var>z</var>&nbsp;&nbsp;&nbsp;&#x2192;&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>y</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;T&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.</p>
				<p>In exactly the same way our previous assignments</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;:=&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;:-&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;&quot;</p>
				<p class="noindent">
		will both give rise to the situation, represented by
</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;&#x2192;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;T&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.</p>
				<p>One of the most illuminating aspects of this arrangement is that the usual distinction between &quot;numbers&quot; and &quot;instructions&quot; has completely vanished. The value of a variable is defined as a piece of program, evaluation of this variable implies the execution of this piece of program.</p>
		<p>Furthermore we should like to draw attention to a certain form of duality between the assignment on the one hand and reading a text on the other. When the machine reads a piece of program text, the top of the stack is filled under control of this program text. In the assignment &quot;readable text&quot; is created under control of the contents of the stack. The duality can also be illustrated by taking into consideration the accessibility requirements. The words in the stack need only be accessible in the direction from top to bottom. If an assignment statement converts the top of the stack into readable text, however, the consecutive words thereby become accessible in the other direction.</p>
		<p>Finally, the stack is reserved for &quot;anonymous intermediate results&quot;, whereas readable text &#151;in principle, at least&#151; is always &quot;named&quot;, for we create it by assigning it to a variable.</p>
		<p>The attentive reader will have noticed that, along with the representation of the value of a variable, we have silently introduced two more complications in our machine.</p>
		<p>The first one, the occurrence of the word &quot;T&quot; in program text and the machine's &quot;immediate reaction&quot; to it is a relatively simple one. As we have described the organization, the word &quot;T&quot;, when read in the text, is <u>not</u> copied on top of the stack! Instead, it causes the machine to go on reading at the first word following in the string after the &quot;E&quot; that caused this evaluation of the variable in question. In other words, it acts as a &quot;Return&quot; at the end of a closed subroutine.</p>
				<p>But the evaluation of a variable may call for the evaluation of other variables (even for the evaluation of itself): the pragmatic definition of the evaluation of a variable is basically  a recursive one and the mechanisms one needs to follow a recursive definition is ..... another stack! I call this second stack &quot;the stack of activations&quot; in contrast to the first which I call &quot;the anonymous stack&quot;. One of the functions of the stack of activations is to control the reading process. When the evaluation of a variable starts the stack of activations expands, when the corresponding word &quot;T&quot; is read, it shrinks to its previous size. (In the usual terminology of machine structure: the stack of activations contains a stack of &quot;order counter values&quot;, its top element being, by definition, &quot;the present order counter&quot;; in the same terminology its older elements act as a stack containing the &quot;return addresses&quot;.)</p>
				<p class="noindent"><u>Note</u><i>.</i> We could try to merge our two stacks into one. This merging would present itself in a completely natural fashion if the two should expand and shrink &quot;in phase&quot; with one another. In general, however, this is not the case and trying to merge the two stacks into a single one would give a highly unnatural construction.
</p>
				<p>We shall use the stack of activations for yet another purpose, to satisfy a very fundamental need, viz. the creation of new variables. In the above I have used special words (&quot;<var>x</var>&quot;, &quot;<var>y</var>&quot;, &quot;<var>plinus</var>&quot; etc.) to denote variables and I have carefully avoided to use the term &quot;identifier&quot;. I have used the term &quot;variable&quot; in connection with a single, unique object, existing for some period of time and capable of taking on different values in succession. This concept of a variable is to be distinguished carefully from the &quot;identifier&quot; as used in ALGOL 60, because one and the same identifier may be used to point to a host of objects, to a great number of different variables</p>
				<p>First of all we meet the fact that one and the same identifier may play different roles thanks to the fact that it occurs in more than one declaration. A lexicographical rule then tells us which one of these declarations applies everywhere, where the identifier in question may be used. This form of multiple use of one and the same identifier could be removed by a simple process of renaming.</p>
		<p>But there is a much more subtle case of &quot;multiple use of one and the same identifier&quot;, viz. as soon as a certain block occurs in one or more nested activations (as in the case of a a recursive procedure). In other words: one and the same identifier then refers sometimes to this variable, sometimes to another.</p>
		<p>In actual fact: the identifier stands for a variable and in order to indicate clearly for which variable it stands I intend to denote explicitly the moment when a variable has to be substituted for an identifier.</p>
		<p>For the sake of convenience &#151;to be more exact: convenience for the machine and not for the hypothetical user&#151; I intend to use the same identifiers for the local variables of every activation. (What I call &quot;an activation&quot; is closely analogous to a block or procedure body, as known in ALGOL 60.) I use for this purpose the special identifier words &quot;L0&quot;, &quot;L1&quot;,&quot;L2&quot;, etc..</p>
		<p>If the machine starts the evaluation of a variable, the stack of activations increases with one item. At the start this item also contains a note that up till now no local variables have been introduced in this activation.</p>
		<p>If the machine reads the word &quot;E&quot; at a moment that the top of the anonymous stack contains one of the identifier words (say &quot;L2&quot;) then it investigates the top item of the stack of activations. If it is the first time that this identifier has to be evaluated in the present activation the machine creates a new variable for it (and may give this variable an empty value) and makes in the youngest item of the stack of activations a note to this effect. Then it replaces the top word of the anonymous stack by the variable just created for it. At a next evaluation of the same identifier at a moment that the same activation is still (or again) the present one, the machine finds in the top item of the stack of activations the note left there at the first evaluation of this identifier and the top word of the stack is replaced by the same variable.</p>
		<p>Now we can show a more complicated example. Let the values of the variables &quot;<var>x</var>&quot;, &quot;<var>y</var>&quot; and &quot;<var>complus</var>&quot; be as represented by:</p>
		<p>&nbsp;&quot;&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;&#x2192;&nbsp;&nbsp;&nbsp;10&nbsp;&nbsp;&nbsp;23&nbsp;&nbsp;&nbsp;T&nbsp;&nbsp;&nbsp;&quot;</p>
				<p>&nbsp;&quot;&nbsp;&nbsp;&nbsp;<var>y</var>&nbsp;&nbsp;&nbsp;&#x2192;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&#150;2&nbsp;&nbsp;&nbsp;T&nbsp;&nbsp;&nbsp;&quot;</p>
				<p class="noindent">&quot;&nbsp;&nbsp;&nbsp;<var>complus</var>&nbsp;&nbsp;&nbsp;&#x2192;&nbsp;&nbsp;&nbsp;L0&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;:=&nbsp;&nbsp;&nbsp;E
</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L1&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;:=&nbsp;&nbsp;&nbsp;E</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L2&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;:=&nbsp;&nbsp;&nbsp;E</p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L1&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;E</p>
		<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L1&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;L0&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;E</p>
				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;&nbsp;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.</p>
				<p class="noindent">
		If we now read the text
</p>
				<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>&quot;&nbsp;&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>y</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>complus</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>z</var>&nbsp;&nbsp;&nbsp;:-&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;&quot;</p>
				<p class="noindent">the net effect will be that we can represent the new value of &quot;<var>z</var>&quot; by:</p>
				<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt>&quot;&nbsp;&nbsp;&nbsp;<var>z</var>&nbsp;&nbsp;&nbsp;&#x2192;&nbsp;&nbsp;&nbsp;15&nbsp;&nbsp;&nbsp;21&nbsp;&nbsp;&nbsp;T&nbsp;&nbsp;&nbsp;&quot;</p>
				<p class="noindent">
		and what we have done can be interpreted as the addition of two complex numbers.
</p>
				<p>In ALGOL terminology: &quot;complus&quot; is a procedure with four numerical parameters, all called by value. The simple structure of the process allows the first of these to remain anonymous even in the procedure body. Furthermore, it is a kind of &quot;type procedure&quot;, be it one that, syntactically speaking, takes the place of two primaries.</p>
				<p>Let me end with a trivial example. Suppose that we want to write &quot;plus&quot; instead of &quot;+&quot;. After the assignment</p>
				<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> &quot;&nbsp;&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;plus&nbsp;&nbsp;&nbsp;:-&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;&quot;</p>
				<p class="noindent">
		which gives rise to the situation
</p>
				<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> &quot;&nbsp;&nbsp;&nbsp;plus&nbsp;&nbsp;&nbsp;&#x2192;&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;T&nbsp;&nbsp;&nbsp;&quot;</p>
				<p class="noindent">
		the expressions
</p>
				<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> &quot;&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>y</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;plus&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;&quot;</p>
				
		and

				<p><tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> &quot;&nbsp;&nbsp;&nbsp;<var>x</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;<var>y</var>&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;+&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;&quot;</p>
				<p class="noindent">
		are completely equivalent. This example is included to show as clearly as possible the arbitrariness of our primitives.<br>
				</p>
				<p></p>
				<u>Conclusion</u>.
		<p>I am fully aware that the sketch is definitely incomplete. Particularly conditional reaction and some equivalent of the <u>go to</u> statement should be incorporated if one wishes to make a system out of this. For the moment I leave these out and I do so for two reasons. Firstly for the sake of brevity and secondly because I have not decided yet: for I know of several possible ways but none of them fully satisfies me.</p>
		<p>With some versions of these facilities I have made slightly more elaborate programs. They showed me both the power and the weakness of my Language, its power being its flexibility and its unambiguity, its weakness being the fact that using it intelligently proved to be far above at least my powers.</p>
		<p>If nevertheless I claim attention for this project I don't do so only because it charms me and may charm others as well. This report is the condensation of my meditations after we had completed our implementation of ALGOL 60. This implementation was conceived at high speed and the main justification for the numerous decisions taken in those hectic months was the recognition that our conceived constructions would lead to our goal and would do the job, in some way or another. The Machine described in this report, however, represents an extreme of the continuous spectrum of possible implementations of an algorithmic language which (as is the case with ALGOL 60) caters for recursiveness. In this quality it has been very clarifying for me personally: it has helped me a great deal in the appreciation of the various (initially disconnected) tricks we have incorporated intuitively and it has clearly shown us a number of alternative solutions. Therefore the hope is justified that translator construction and machine design in the future will benefit from these considerations.</p>
		<p>Furthermore, the Machine presented here is so ridiculously inefficient that every practical implementation of a practical algorithmic language in all probability can be regarded as an optimization of it, an optimization which is permissible thanks to certain restrictions in the language. It may be useful to compare a proposed language with my language; during the process of language construction it may be helpful in the timely detection of &quot;expensive features&quot;. Whether such an expensive feature will be included or not is more or less a political question but quite apart from how such a question is answered it is nice to know what one is doing.</p>
				<p>Finally the language described in this report (or a language devised along similar lines) may prove to be a suitable means for the formalization of the semantic definition of an algebraic language. The lack of such a rigorous semantic definition is one of the recognized shortcomings of the official &quot;Report on the Algorithmic Language ALGOL 60&quot; and having seen the tremendous amount of trouble caused by this defect, I most sincerely hope that this report will contribute to the effort to avoid this mistake the next time an algorithmic language will be devised.</p>
				<p class="noindent"><u>Acknowledgements</u>.
</p>
				<p>A great number of people have contributed to this, consciously or not. Besides all my colleagues at the Computation Department of the Mathematical Centre, Amsterdam, I should like to mention Dr.M.V.Wilkes and Prof.J.McCarthy, who proved to be inspiring listeners, and in particular Mr.M.Woodger: his judgement and his comments (I remember his lack of enthusiasm for my first trials in this direction now with gratitude) have been a great help for me.</p>
				<p></p>
		<hr>
		<font size="-1">Transcription by Ken Dyck.<br>
			Last revised on <csobj format="MedDate" h="13" region="15" t="DateTime" w="97">Mon, 17 Dec 2007</csobj>.</font>
	</body>

</html></div>
  </body>
  </html>
