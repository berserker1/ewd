  <!DOCTYPE html>
  <html>
  <head>
    <title>The pattern matching problem</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <link href="assets/tweet-selection.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.12.0.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="assets/tweet-selection.js"></script>
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: The pattern matching problem" />
    <meta name="twitter:title" content="The pattern matching problem" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>The pattern matching problem</h1>
  <div class='body'>
<div id="frame" align="right">
<div id="header" align="right"><a href="https://www.cs.utexas.edu/~EWD/ewd04xx/EWD459.PDF" title="Link to the PDF version of EWD459">EWD459</a></div>
</div>
<hr />
<p class="noindent">NOTE: This transcription was contributed by Martin P.M. van der Burgt, who has devised a process for producing transcripts automatically. Although its markup is incomplete, we believe it serves a useful purpose by virtue of its searchability and its accessibility to text-reading software. It will be replaced by a fully marked-up version when time permits. —HR</p>
<hr />
<p class="noindent"></p>
<p class="noindent">(To be inserted after EWD437).</p>
<p><b>The pattern matching problem.</b></p>
<p>The problem that is solved in this chapter is a very famous one, that has been tackled independently by many programmers. Yet we hope that our treatment gives some pleasure to even those of my readers who considered themselves thoroughly familiar with the problem and its various solutions.</p>
<p>We consider as given two sequences of values</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>p(0), p(1), , p(N -1) &nbsp;&nbsp;&nbsp;&nbsp; with N ≥ 1 &nbsp;&nbsp;&nbsp;&nbsp; and</td>
</tr>
<tr>
<td></td>
<td>x(0), x(1), , x(M -1) &nbsp;&nbsp;&nbsp;&nbsp; with M ≥ 0</td>
</tr>
</table>
(usually M is regarded as being many times larger than N). The question to be answered is: how many times occurs the “pattern”, as given by the first sequence, in the second sequence?
<table width="100%">
<tr>
<td valign="top" width="10%">
<p class="noindent">Using</p>
</td>
<td>(<u>N</u> i: 0 ≤ i &lt; m: B(i))</td>
</tr>
</table>
to denote “the number of different values of i in the range 0 ≤ i &lt; m , for which B(i) holds”, a more-precise description of the final relation R that is to be established is
<table width="100%">
<tr>
<td valign="top" width="10%">R:</td>
<td>count = (<u>N</u> i: 0 ≤ i ≤ M - N: match(i))</td>
</tr>
</table>
where the function match(i) is given by
<table width="100%">
<tr>
<td valign="top" width="30%">for 0 ≤ i ≤ M - N:</td>
<td>match(i) = (<u>A</u> j: 0 ≤ j &lt;N: p(j) = x(i + j))</td>
</tr>
<tr>
<td valign="top">for i &lt; 0 <b>or</b> i &gt; M - N:</td>
<td>match(i) = false .</td>
</tr>
</table>
(To define match(i) = false for those further values of i , thus making it a total function, is a matter of convenience.)
<p>If we take as invariant relation</p>
<table width="100%">
<tr>
<td valign="top" width="10%">P1:</td>
<td>count = (<u>N</u> i: 0 ≤ i &lt; r: match(i)) <b>and</b> r ≥ 0</td>
</tr>
</table>
we have one which is trivially established by “count, r:= 0, 0” and, furthermore, is such that
<table width="100%">
<tr>
<td valign="top" width="10%"></td>
<td>(P1 <b>and</b> r &gt; M - N) ⇒ R .</td>
</tr>
</table>
(The “matter of convenience” referred to above is that now the above inequality will do the job.) This gives a sketch for the program:
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>count, r:= 0, 0;</td>
</tr>
<tr>
<td></td>
<td><b>do</b> r ≤ M - N → “increase r under invariance of P1 ” <b>od</b></td>
</tr>
</table>
and the reader is invited to work out for himself the refinement in which r is always increased by 1; worst case the time taken by the execution of that program will be proportional to M * N .
<p>Depending on the pattern,however, much larger increases of r seem sometimes possible: if, for instance, the pattern is (1, 2, 3, 4, 5) and match(r) has been found to hold, “count, r:= count + 1, r + 5” would leave P1 invariant! Considering the invariant relation</p>
<table width="100%">
<tr>
<td valign="top" width="10%">P2:</td>
<td>(<u>A</u> ≤ j &lt; k: p(j) = x(r + j)) and 0 ≤ k ≤ N</td>
</tr>
</table>
(which can be expected to play a role in the repetitive construct computing match(r)), we can investigate, what we can gain by taking that relation outside the repetitive construct, i.e, we consider:
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>count, r, k:= 0, 0, 0;</td>
</tr>
<tr>
<td></td>
<td>do r ≤ M - N → “increase r under invariance of P1 <b>and</b> P2 ” <b>od</b></td>
</tr>
</table>
(relation P2 being vacuously satisfied by k = 0 ).
<p>In view of the validity of relation P2 and the formula for match(r), the most natural thing to start the repeatable statement with is to try to determine match(r) : as the truth of match(r) can be concluded from P2 <b>and</b> k = N we prescribe that k be increased as long as is necessary and possible:</p>
<table width="100%">
<tr>
<td valign="top" width="10%"></td>
<td valign="top"><b>do</b> k = N <b>cand</b> p(k) = x(r+k) → k:= k + 1 <b>od</b></td>
<td align="right">(1)</td>
</tr>
</table>
upon termination of which —and termination is guaranteed— we have
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>P2 <b>and</b> (k = N <b>cor</b> p(k) ≠ x(r + k))</td>
</tr>
</table>
from which we can conclude that match(r) = (k = N) . Thus it is known, whether increasing r by 1 should be accompanied by “count:= count + 1” or not. We would like to know, by how much r can be increased without further increase of count and without taking any further x-values into account. (The taking into account of x-values is done in statement (1): to do so is its specific purpose! Here we are willing to exploit only properties of the —constant— pattern;)
<p>If k = 0, we conclude (because N &gt; 0 ) that match(r) = false : the relation Pl then justifies an increase of r by 1 —leaving P1 invariant by leaving count unchanged— but P2 does not justify any higher increase of r ; and k = 0 —making P2 vacuously true— is maintained.</p>
<p>For general k , however, there is the following argument. Define for 0 &lt; i ≤ k ≤ N the boolean function</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>dif(i, k) = (<u>E</u> j: 0 ≤ j &lt; k - i; p(j) ≠ p(i + j)) .</td>
</tr>
</table>
From this it follows that dif(k, k) = false . If, however, dif(i, k) = true, (we conclude —because 0 ≤ i + j &lt; k— on account of the truth of P2
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(<u>E</u> j: 0 ≤ j &lt; k - i: p(j) ≠ x(r + i + j)) .</td>
</tr>
</table>
that is: dif(i, k) ⇒ <b>non</b> match(r + i) . Therefore, the variable “count” needs no further adjustments —besides the one on account of the value of match(r)— when r is increased by d(k), where d(k) is the <b>minimum</b> solution for i with 0 &lt; i ≤ k of the equation dif(i, k) = false , or:
<table width="100%">
<tr>
<td valign="top" width="10%"></td>
<td valign="top"><u>(A</u> j:0 ≤ j &lt; k - i: p(j) = p(i + j)) .</td>
<td align="right">(2)</td>
</tr>
</table>
<p>The fact that d(k) is a solution of (2) implies</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(<u>A</u> j:0 ≤ j &lt; k - d(k): p(j) = p(d(k) + j)) .</td>
</tr>
</table>
which, with P2 amounts to
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(<u>A</u> j:0 ≤ j &lt; k - d(k): p(j) = x(r + d(k) + j)) .</td>
</tr>
</table>
and as a result —besides the adjustment of “count” as implied by the value of match(r) —both P1 and P2 are kept invariant by “r, kt: r + d(k), k - d(k)”.
<p>Because the minimum solution of (2) depends on k and p only, we find:</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="4"><b>begin</b> <b>glocon</b> p, N, x, M; <b>virvar</b> count; <b>privar</b> r, k; <b>pricon</b> d; . “initialize d”;</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="3">count, r, k := 0, 0, 0; 3 * <b>vir</b> int</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="3"><b>do</b> r ≤ M - N →</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>do</b> k ≠ N <b>cand</b> p(k) = x(r + k) → k:= k + l <b>od</b>;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td colspan="2"><b>if</b> k = N → count:= count + l; r, k := r + d(k), k - d(k)</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td>▯ 0 &lt; k &lt; N → r, k := r + d(k) , k - d(k)</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>▯ k = 0 → r:= r + 1</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td colspan="2"><b>fi</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="3"><b>od</b></td>
</tr>
<tr>
<td></td>
<td colspan="4"><b>end</b></td>
</tr>
</table>
<p>The only job left is the initialization of the array variable d , i.e. to establish for each k satisfying 1≤ k ≤ N the minimum solution for i of (2) . The Linear Search Theorem tells us that we should try i-values in increasing order. It pays, however, to realize that this minimum value for i has to be determined for a whole sequence of k-values. Let k1 &gt; k2 and let d(k1) be the minimum solution for i of (2) with k = k1 . From</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(<u>A</u> j:0 ≤ j &lt; k1 - d(k1): p(j) = p(d(k1) + j)) <b>and</b> k1 &gt; k2</td>
</tr>
</table>
follows:
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(<u>A</u> j:0 ≤ j &lt; k2 - d(k1): p(j) = p(d(k1) + j))</td>
</tr>
</table>
i.e. for k = k2 , d(k1) is also a solution for i of (2) , but not necessarily the smallest! From that we conclude that d(k) is a monotonically non-decreasing function of k. And the algorithm therefore investigates increasing values of i , each time deciding whether for one or more k-values i = d(k) can be concluded (should be established). More precisely: let j(i) (for given value of i be the maximum value ≤ N - i , such that
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(<u>A</u> j: 0 ≤ j &lt;j(i): p(j) = p(i + j)) ;</td>
</tr>
</table>
then d(k) = i for all k such that k - i ≤ j(i) (or: k ≤ j(i)+ i), for which no solution d(k) &lt; i exists. As the values of i will be tried in increasing order and, as soon as existing as minimal solution, will be recorded in the monotonically non-decreasing function d , the condition is
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>d.hib &lt; k ≤ j(i)+ i</td>
</tr>
</table>
and we get the following program:
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="4">“initialize d”:</td>
</tr>
<tr>
<td></td>
<td colspan="4"><b>begin</b> <b>glocon</b> p, N; <b>virvar</b> d; <b>privar</b> i;</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="3">d <b>vir</b> int <b>array</b>, i <b>vir</b> int := (1), 0;</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="3"><b>do</b> d.hib ≠ N →</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>begin</b> <b>glocon</b> p, N; <b>glovar</b> d, i; <b>privar</b> j;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td>j <b>vir</b> int := 0; i:= i + 1;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><b>do</b> j &lt; N - i <b>cand</b> p(j) = p(i + j) → j:= j + l <b>od</b>;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td><b>do</b> d.hib &lt; j + i - d:hiext(i) <b>od</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td colspan="2"><b>end</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="3"><b>od</b></td>
</tr>
<tr>
<td></td>
<td colspan="4"><b>end</b></td>
</tr>
</table>
<p class="noindent"><b>Exercise 1</b>. Give a formal correctness proof for the above initialization. (End of exercise 1.)</p>
<p class="noindent"><b>Exercise 2</b>. With “r, k := r + d(k), r - d(k)” For 0 &lt; k , our algorithm adjusts r and k without changing r + k . Investigate the slight gain that is possible for 0 &lt; k &lt; N if it is known that the x-values are two-valued. (End of exercise 2.)</p>
<p class="noindent"><b>Remark</b>. Our final algorithm is one, the execution time of which I regard as to grow proportional to, M + N . Once one has set oneself the goal to find —if possible— an algorithm with such a performance, its actual development. does not seem to require much more than the usual care; the crucial point seems the refusal to be satisfied (without further investigation) with the obvious M * N -algorithm, the development of which I have left as an exercise to the reader. A slight reformulation of the problem, however, enables us to recognize also here a general design principle, which might be called “The Search for the Small Superset.” Suppose that we had not been asked to count the number of matches, but to generate the sequence of r-values, for which match(r) holds.</p>
<p>When a program has to generate the members of a set A , there are (roughly) only two situations. Either we have simple, straightforward “successor function” by means of which a next member of A can be generated —and then the whole set can be trivially generated by means of repeated application of that successor function— or we do not have a function like that. In the latter case, the usual technique is to generate the members of a set B instead, where<br />
a)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;each member of A is a member of B as well<br />
b)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;there exists a generator for successive members of B<br />
c)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;there exists a test whether a member of B belongs to A as well. The algorithm then generates and inspects all members of B in turn.</p>
<p>If this technique is to lead to a satisfactory performance, three conditions should be satisfied:<br />
1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the members of set B should be reasonably efficient to generate<br />
2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the test whether an element of B belongs to A as well —particularly in the case that it does <b>not</b>, for, usually, B is an order of magnitude larger than A — should be reasonably efficient<br />
3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set B should not be unnecessarily large.</p>
<p>The trained problem solver, aware of the above, will consciously look for a smaller set B than the obvious one. In this example, the set of all r-values satisfying 0 ≤ r ≤ M - N is the obvious one. Note, that in the previous chapter “An exercise attributed to R.W.Hamming” the replacement of the set “qq” by the much smaller set “qqq” was another application of the principle of The Search for the Small Superset. And besides “taking a relation outside the repetitive construct” this illustrates the second strategical similarity between the solutions presented in the current and in the previous chapter. (End of remark.)</p>
<hr />
<p class="noindent"><font size="-1">Transcribed by Martin P.M. van der Burgt<br />
Last revision <!-- #BeginDate format:IS1 -->2014-11-15<!-- #EndDate -->
 .</font></p>
<p>&nbsp;</p>
</div>
  <script>
$('.body').tweetSelection({
  ellipsis: '...',
  quoteLeft: '\'',
  quoteRight: '\'',
  via: 'raboofje'
});
  </script>
  </body>
  </html>
