  <!DOCTYPE html>
  <html>
  <head>
    <title>TITLE</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <link href="assets/tweet-selection.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.12.0.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="assets/tweet-selection.js"></script>
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: TITLE" />
    <meta name="twitter:title" content="TITLE" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>TITLE</h1>
  <div class='body'>﻿<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">  <html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">   <head>     <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1" />     <title>E.W.Dijkstra Archive: TITLE (EWD 503)</title>		<link href="../transcriptions.css" rel="stylesheet" media="screen">		   </head> <BODY> <DIV id=frame> <DIV id=header> <a title="Link to the PDF version of EWD503" href="https://www.cs.utexas.edu/~EWD/ewd05xx/EWD503.PDF">EWD503</a></DIV> 			<DIV id=content> <P style="text-indent: 0"><font size="5"><b>Copyright Notice</b></font></P> <P style="text-indent: 0">The following manuscript</P>  <P>EWD 503: A post-scriptum to EWD501</P>  <P style="text-indent: 0">is held in copyright by Springer-Verlag New York.</P>  <P style="text-indent: 0">The manuscript was published as pages 141-144 of</P>  <P style="text-indent: 0; margin-left: 36">Edsger W. Dijkstra, <I>Selected Writings on Computing: A Personal Perspective</I>,<BR> Springer-Verlag, 1982. ISBN 0-387-90652-5.</P>  <P style="text-indent: 0"><b>Reproduced with permission from Springer-Verlag New York.<BR> Any further reproduction is strictly prohibited.</b></P> 				<hr> 				<P style="text-indent: 0">9th July 1975</P>  <P><U>A post-scriptum to EWD501</U></P>  <P>Dear Tony!</P>  <P>Monday morning I went to XEROX to have a few copies made of EWD 501 andfrom there via the THE home. At the THE I showed Wim Feijen, what I had writtenduring the weekend, and I discussed with him what I intended to write in theafternoon.</P><P>In the afternoon I wrote EWD502 —&quot;On a gauntlet thrown by David Gries&quot;— when that was completed, Wim came along. He had studied EWD501, and his first remark was, that the procedure <code>cons</code> on page EWD501 - 5 (13 - 7 lines from below) can be simplified, thanks to the initial emptyness of the train <code>temp</code>:</P><blockquote><pre><code><u>proc</u> cons(c: integer):    <u>do</u> n < c → con:= (con, me); me:= head(temp) <u>od</u>;    n:= n - c; me:= head(temp)<u>corp</u> cons;</code></pre></blockquote>				<p>Another observation he made was that when, for instance in the procedure <code>acquire</code> on top of page EWD501, the second line			</div>			<div id=content align="center">				<p class="continue"><code>nonbusy:= (nonbusy, me); me:= head(nonbusy)</code></p>			</div>			<div id=content>				<p class="continue">				is omitted, it is still correct, but now implements a last-in-first-outstrategy. I had these remarks in the back of my mind when I designed thereaders and writers monitor and the dischead monitor (see following pages).</p>				<p>Monday evening I was tired —Ria and I went away on the tandem—, Tuesday was my day at the THE. In the morning I had some examinations, in the afternoon we studied EWD501 with the little group and made a first solution to the readers and writers. Tuesday evening I embellished it, and thought about a few linguistic alternatives. This morning I had to write a referee's report, this afternoon I designed the diskhead monitor, and typed both monitors.</p>				<p>It is now early in the evening. Let me describe to you the linguistic alternative I have been thinking about. Up till now we have done as if the monitor only exists after the initialization has been completed. But we could regard the monitor &quot;existing&quot; as soon as the initialization starts, and regard the initialization as performed by an (anonymous) process in monitor state. The one consequence would be that all initializations in the monitors I have written these last days, should end with an additional &quot;<code>me:= nil</code>&quot;. That obligation is hardly a recommendation, in contrast, perhaps, to the now created possibility that after initialization the monitor process can place &quot;me&quot; on the shunting yard, thereby remaining available for activities that would be hard to place otherwise.</p>				<p>In the dischead monitor you will see that the sortprocess, that should insert the new requester —placed in <code>qu1</code>— in the correct position into the train <code>upsweep</code> will fail to do so, when the new requester should be placed at the rear end of <code>upsweep</code> —this &quot;appending&quot; is no insertion—. As a result, requests and releases have to begin with</p>			</div>			<div id=content align="center">				<p class="continue"><code>upsweep:= (upsweep, qu1)</code></p>			</div>			<div id=content>				<p class="continue">just to be on the safe side. (When <code>qu1 = nil</code>, the above shunting has no effect.) This could be regarded as ugly. If the monitor itself could sleep on the shunting yard as well, I think that this could be remedied by attaching the monitor at the rear end of <code>upsweep</code>, before the new requester is placed in the correct position. It gives us the possibility to have some activity inserted after the last one, and that, in general, seems a sound and useful facility.</p>				<pre><code>readers and writers: <u>monitor</u>:<u>begin</u> ar, aw: integer;      readers, writers: train;      <u>proc</u> startread:           readers:= (head(writers), readers, me); me:= head(readers);           <u>do</u> aw ≠ 0 → readers:= (me, readers); me:= nil <u>od</u>;           ar:= ar + 1; me:= head(readers)      <u>corp</u> startread;      <u>proc</u> endread:           <u>if</u> ar &gt; 0 → ar:= ar - 1; me:= head(writers) <u>fi</u>      <u>corp</u> endread;      <u>proc</u> startwrite:           writers:= (writers, me); me:= head(writers);           <u>do</u> ar ≠ 0 <u>or</u> aw ≠ 0 → writers:= (me, writers); me:= nil <u>od</u>;           aw:= 1; me:= nil      <u>corp</u> startwrite;      <u>proc</u> endwrite:           <u>if</u> aw = 1 → aw:= 0; readers:= (readers, head(writers));           	       me:= head(readers)           <u>fi</u>      <u>corp</u> endwrite;      ar:= 0; aw:= 0<u>end</u> readers and writers</code></pre>				<p>This is my version of the readers and the writers, according to your specifications of page 556. (Although I wrote it on Tuesday evening, I should say &quot;our&quot;, as the problem was discussed on Tuesday afternoon at the THE with the usual group; particularly the contribution of Wim Feijen should be acknowledged.</p>				<p>It has, I think, some charming features. The invariance of</p>				<blockquote>					<pre><code>ar ≧ 0 <u>and</u> aw = 0 <u>or</u> ar = 0 <u>and</u> aw = 1</code></pre>				</blockquote>				is beautifully maintained, when we remember that the repetitive construct can only terminate with its guard(s) false. (The alternative constructs in <code>endwrite</code> and <code>endread</code>, which may cause abortion, are only there for safety.) The nice thing is that these two guards derived from the invariant relation occur only once! The whole choice of strategy is reflected in the shunting and switching! Isn't that nice?				<p>The way in which in &quot;startread&quot; the presence of a waiting writer prevents new readers to get access, also pleases me. At first it may strike you as a coding trick, but after having played with these trains for a while, it comes quite natural. The way in which &quot;endwrite&quot; gives priority to the readers is also quite nice; at least, I think so.</p>				<p>In programming style, the above is very much different from your approach, in which the continuation after a &quot;wait&quot; can do no harm on account of what has been checked by the other process, that caused the &quot;signal&quot;. In such a way one can also get one's programs right, but in principle I think the approach a wrong one: your procedures are logically more intertwined —at least so it seems to me— and it is therefore a stronger invitation to make logical spaghetti.</p>				<p>The convincing beauty of the above contrast with the program on the next page, where I did the dischead monitor without the scheduled wait, and without the &quot;<code>condname.queue</code>&quot;. That was not easy!</p>				<pre><code>dischead: <u>monitor</u><u>begin</u> headpos, newdest: cylinder;      direction: (up, down);      busy: boolean;      upsweep, downsweep, qu1, qu2: train;      <u>proc</u> request(dest: cylinder);           upsweep:= (upsweep, qu1); downsweep:= (downsweep, qu2);           newdest:= dest;           <u>if</u> dest &gt; headpos <u>or</u> dest = headpos <u>and</u> direction = up →                qu2:= (upsweep); qu1:= (head(qu2), me); me:= head(qu1);                <u>do</u> busy → <u>if</u> newdest ≧ dest → upsweep:= (upsweep, me);                                              me:= head(qu2)                           <font size="+3"><sub>&#x25AF;</sub></font> newdest &lt; dest → upsweep:= (upsweep, qu1, me, qu2);                                              me:= nil;                          <u>fi</u>                <u>od</u>            <font size="+3"><sub>&#x25AF;</sub></font> dest &lt; headpos <u>or</u> dest = headpos <u>and</u> direction = down →                qu1:= (downsweep); qu2:= (head(qu1), me); me:= head(qu2);                <u>do</u> busy → <u>if</u> newdest ≦ dest →                               downsweep := (downsweep, me); me:= head(qu1)                           <font size="+3"><sub>&#x25AF;</sub></font> newdest &gt; dest →                               downsweep:= (downsweep, qu2, me, qu1); me:= nil                          <u>fi</u>                <u>od</u>           <u>fi</u>;           <u>if</u> headpos &lt; dest → direction:= up            <font size="+3"><sub>&#x25AF;</sub></font> headpos &gt; dest → direction:= down            <font size="+3"><sub>&#x25AF;</sub></font> headpos = dest → skip           <u>fi</u>           headpos:= dest; busy:= true; me:= nil      <u>corp</u> request;      <u>proc</u> release;  busy:= false;           <u>if</u> busy → upsweep:= (upsweep, qu1); downsweep:= (downsweep, qu2);           	<u>if</u> direction = up →           	     downsweep:= (head(upsweep), downsweep);           	     me:= head(downsweep)           	 <font size="+3"><sub>&#x25AF;</sub></font> direction = down →           	     upsweep:= (head(downsweep), upsweep);           	     me:= head(upsweep)           	<u>fi</u>           <u>fi</u>      <u>corp</u> release;      headpos:= 0; direction:= up; busy:= false<u>end</u> dischead</code></pre>				<p>Salvo errore at omissione, the above is a replacement for your dischead monitor on page 555-556. It could be argued that the above could only be programmed on a very warm day with thunderstorms —for your information: it is such a day!—. But it has not the danger of individual starvation when all requests are for the same cylinder! Your &quot;scheduled wait&quot; does not talk about this. Agreed? On account of the above I understand that you yielded to the temptation to introduce the scheduled wait. Note, how in the &quot;release&quot;, some shunting avoids the need for &quot;<code>condname.queue</code>&quot;. That part of the construction I think quite neat!</p>				<p align="center">Greetings and best wishes! Yours ever</p>				<p align="right">Edsger</p>				<hr>				<div id=footer>					<font size="-1">transcribed by Edwin de Jong<br>revised <csobj format="MedDate" h="13" region="15" t="DateTime" w="87">Tue, 7 Dec 2010</csobj></font></div>			</div>		</div> 	</BODY></HTML> </div>
  <script>
$('body').tweetSelection({
  height: 300,
  width: 600,
  minimumTextSelected: 3,
  shareClass: '.tweet-selection',
  ellipsis: '...',
  quoteLeft: '\'',
  quoteRight: '\'',
  via: 'raboofje'
});
  </script>
  </body>
  </html>
