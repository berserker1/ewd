<html>
<head>
  <title>Lambek and Moser revisited</title>
  <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
  <link href="assets/transcriptions.css" rel="stylesheet">
  <meta name="generator" content="convertArticle.pl">
</head>
<body>
<h1>Lambek and Moser revisited</h1>

				<p>Let <var>f </var>be an ascending sequence of natural numbers, i.e.</p>
				<p class="display">(<b>A</b> <var>i</var>,<var>j</var> : 0 &le; <var>i</var> &lt; <var>j</var> : <var>f </var>(<var>i</var>) &le; <var>f </var>(<var>j</var>))</p>
				<p class="continue"><br>
					that is unbounded, i.e.</p>
				<p class="display">(<b>A</b> <var>j</var> : <var>j</var> &ge; 0 : (<b>E</b> <var>i</var> : <var>i</var> &ge; 0 : <var>f </var>(<var>i</var>) &gt; <var>j</var>)) .</p>
				<p>The function <var>lambo</var> is defined as follows: <var>lambo</var>(<var>f </var>) is a sequence of natural numbers and <var>g</var> = <var>lambo</var>(<var>f </var>) means that for all <var>y</var> &ge; 0, <var>g</var>(<var>y</var>) = <var>x</var>, where <var>x</var> stands for the minimum value such that <var>f </var>(<var>y</var>) &gt; <var>x</var>, or, more formally, where <var>x</var> satisfies<br>
					<br>
				</p>
				<table width="60%" border="0" cellspacing="0" cellpadding="0">
					<tr>
						<td class="leftlabel" valign="top" width="10%"><var>R </var>:</td>
						<td>(<b>A</b> <var>i</var> : 0 &le; <var>i</var> &lt; <var>j</var> : <var>f </var>(<var>i</var>) &le; <var>x</var>) &and; <var>f </var>(<var>x</var>) &gt; <var>y</var> .</td>
					</tr>
				</table>
				<p>In order to compute <var>g</var>, we design a program with the invariant relation<br>
					<br>
				</p>
				<table width="60%" border="0" cellspacing="0" cellpadding="0">
					<tr>
						<td class="leftlabel" width="10%"><var>P </var>:</td>
						<td>(<b>A</b> <var>i</var> : 0 &le; <var>i</var> &lt; <var>j</var> : <var>f </var>(<var>i</var>) &le; <var>x</var>) &and; <var>f </var>(<var>x</var>) &ge; <var>y</var></td>
					</tr>
				</table>
				<p></p>
				<table width="100%" border="0" cellspacing="0" cellpadding="0">
					<tr>
						<td>
							<table class="program" border="0" cellspacing="0" cellpadding="0">
								<tr>
									<td colspan=2><var>x</var>,<var>y</var> := 0,0; {<var>P</var>}</td>
								</tr>
								<tr>
									<td><b>do</b>&nbsp;</td>
									<td><var>f </var>(<var>x</var>) = <var>y</var> &rarr; <var>x</var>:=<var>x</var>+1 {<var>P</var>}</td>
								</tr>
								<tr>
									<td align="right">&#9647;&nbsp;</td>
									<td><var>f </var>(<var>x</var>) &gt; <var>y</var> &rarr; {<var>R</var>} <var>g</var>(<var>y</var>):=<var>x </var>; <var>y </var>:=<var>y</var>+1 {<var>P</var>}</td>
								</tr>
								<tr>
									<td><b>od</b></td>
								</tr>
							</table>
						</td>
						<td class="rightlabel" align="right">(1)</td>
					</tr>
				</table>
				<p>Note firstly, that the program<br>
					<br>
				</p>
				<table width="100%" border="0" cellspacing="0" cellpadding="0">
					<tr>
						<td class="leftlabel" width="10%"></td>
						<td><b>do</b> <var>f </var>(<var>x</var>) = <var>y</var> &rarr; <var>x </var>:=<var>x</var>+1 <b>od</b></td>
						<td class="rightlabel" align="right">(2)</td>
					</tr>
				</table>
				<p class="continue"><br>
					terminates because <var>f</var> is unbounded; note secondly, that the program<br>
					<br>
				</p>
				<table width="100%" border="0" cellspacing="0" cellpadding="0">
					<tr>
						<td class="leftlabel" width="10%"></td>
						<td><b>do</b> <var>f </var>(<var>x</var>) &gt; <var>y</var> &rarr; <var>g</var>(<var>y</var>):=<var>x </var>; <var>y </var>:=<var>y</var>+1 <b>od</b></td>
						<td class="rightlabel" align="right">(3)</td>
					</tr>
				</table>
				<p class="continue"><br>
					terminates; note, finally, that on account of the last term of <var>P</var> program (1) fails to terminate.</p>
				<p>Consider now program (4), in which we assume <var>g</var> to be initialized <var>g</var> = <var>lambo</var>(<var>f&nbsp;</var>); the same <var>P</var> is again an invariant.<br>
					<br>
				</p>
				<table width="100%" border="0" cellspacing="0" cellpadding="0">
					<tr>
						<td>
							<table class="program" border="0" cellspacing="0" cellpadding="0">
								<tr>
									<td colspan=2><var>x</var>,<var>y</var> := 0,0; {<var>P</var>}</td>
								</tr>
								<tr>
									<td><b>do</b>&nbsp;</td>
									<td><var>f </var>(<var>x</var>) = <var>y</var> &rarr; <var>x </var>:=<var>x</var>+1 {<var>P</var>}</td>
								</tr>
								<tr>
									<td align="right">&#9647;&nbsp;</td>
									<td><var>f </var>(<var>x</var>) &gt; <var>y</var> &rarr; {<var>R</var>, hence <var>g</var>(<var>y</var>) = <var>x</var>} <var>y </var>:=<var>y</var>+1 {<var>P</var>}</td>
								</tr>
								<tr>
									<td><b>od</b></td>
								</tr>
							</table>
						</td>
						<td class="rightlabel" align="right">(4)</td>
					</tr>
				</table>
				<p class="continue"><br>
					Also program (4) fails to terminate; because we are entitled to assert <var>g</var>(<var>y</var>) = <var>x</var> in the second guarded command, the program still fails to terminate when we include that relation in the second guard<br>
					<br>
				</p>
				<table width="100%" border="0" cellspacing="0" cellpadding="0">
					<tr>
						<td>
							<table class="program" border="0" cellspacing="0" cellpadding="0">
								<tr>
									<td colspan=2><var>x</var>,<var>y</var> := 0,0; {<var>Q</var>}</td>
								</tr>
								<tr>
									<td><b>do</b>&nbsp;</td>
									<td><var>f </var>(<var>x</var>) = <var>y</var> &rarr; <var>x </var>:=<var>x</var>+1 {<var>Q</var>}</td>
								</tr>
								<tr>
									<td align="right">&#9015;&nbsp;</td>
									<td><var>f </var>(<var>x</var>) &gt; <var>y</var> &and; <var>g</var>(<var>y</var>) = <var>x</var> &rarr; <var>y </var>:=<var>y</var>+1 {<var>Q</var>}</td>
								</tr>
								<tr>
									<td><b>od</b></td>
								</tr>
							</table>
						</td>
						<td class="rightlabel" align="right">(5)</td>
					</tr>
				</table>
				<p>From the fact that (5) fails to terminate we conclude a further invariant<br>
					<br>
				</p>
				<table width="100%" border="0" cellspacing="0" cellpadding="0">
					<tr>
						<td class="leftlabel" width="10%"><var>Q</var>:</td>
						<td><var>g</var>(<var>y</var>) &ge; <var>x</var></td>
					</tr>
				</table>
				<p class="continue"><br>
					We conclude this by considering &not;<var>Q </var>: <var>g</var>(<var>y</var>) &lt; <var>x</var>. In that case (5) reduces to (2), of which &not;<var>Q</var> is obviously an invariant; because (2) terminates and (5) does not, &not;<var>Q</var> cannot occur. Having established the invariance of <var>Q</var>, we conclude that the program still fails to terminate when we &quot;strengthen&quot; the first guard with <var>wp</var>(&quot;<var>x&nbsp;</var>:=<var>x</var>+1&quot;, <var>Q </var>):<br>
					<br>
				</p>
				<table width="100%" border="0" cellspacing="0" cellpadding="0">
					<tr>
						<td>
							<table class="program" border="0" cellspacing="0" cellpadding="0">
								<tr>
									<td colspan=2><var>x</var>,<var>y</var> := 0,0;</td>
								</tr>
								<tr>
									<td><b>do</b>&nbsp;</td>
									<td><var>f </var>(<var>x</var>) = <var>y</var> &and; <var>g</var>(<var>y</var>) &gt; <var>x</var> &rarr; <var>x </var>:=<var>x</var>+1</td>
								</tr>
								<tr>
									<td align="right">&#9647;&nbsp;</td>
									<td><var>f </var>(<var>x</var>) &gt; <var>y</var> &and; <var>g</var>(<var>y</var>) = <var>x</var> &rarr; <var>y </var>:=<var>y</var>+1</td>
								</tr>
								<tr>
									<td><b>od</b></td>
								</tr>
							</table>
						</td>
						<td class="rightlabel" align="right">(6)</td>
					</tr>
				</table>
				<p>But program (6) is symmetric in the pairs (<var>x</var>,<var>f </var>) and (<var>y</var>,<var>g</var>); hence</p>
				<blockquote>
					<p class="display">(<var>g</var>=<var>lambo</var>(<var>f </var>)) = (<var>f</var>=<var>lambo</var>(<var>g</var>)) &nbsp;&nbsp;&nbsp;&nbsp;,</p>
				</blockquote>
				<p class="continue">in other words: the function <var>lambo</var> is its own inverse.</p>
				<p>Finally, let us consider the program<br>
					<br>
				</p>
				<table width="100%" border="0" cellspacing="0" cellpadding="0">
					<tr>
						<td>
							<table class="program" border="0" cellspacing="0" cellpadding="0">
								<tr>
									<td colspan=2><var>x</var>,<var>y</var> := 0,0;</td>
								</tr>
								<tr>
									<td><b>do</b>&nbsp;</td>
									<td><var>f </var>(<var>x</var>) = <var>y</var> &and; <var>g</var>(<var>y</var>) &gt; <var>x</var> &rarr; { <var>x</var> + <var>f </var>(<var>x</var>) = <var>n</var> } <var>x</var>,<var>n</var> := <var>x</var>+1,<var>n</var>+1</td>
								</tr>
								<tr>
									<td align="right">&#9015;&nbsp;</td>
									<td><var>f </var>(<var>x</var>) &gt; <var>y</var> &and; <var>g</var>(<var>y</var>) = <var>x</var> &rarr; { <var>y</var> + <var>g</var>(<var>y</var>) = <var>n</var> } <var>y</var>,<var>n</var> := <var>y</var>+1,<var>n</var>+1</td>
								</tr>
								<tr>
									<td><b>od</b></td>
								</tr>
							</table>
						</td>
						<td class="rightlabel" align="right">(7)</td>
					</tr>
				</table>
				<p>Program (7) has the obvious invariant <var>x</var> + <var>y</var> = <var>n</var>, which justifies the two assertions. They, however, are the respective weakest preconditions for the invariance of<br>
					<br>
				</p>
				<table border="0" cellspacing="0" cellpadding="0">
					<tr>
						<td class="leftlabel" valign="top" width="10%"><var>Q</var>1:</td>
						<td>the sets { <var>i</var> + <var>f </var>(<var>i</var>) | 0 &le; <var>i</var> &lt; <var>x</var> } and { <var>j</var> + <var>g</var>(<var>j</var>) | 0 &le; <var>j</var> &lt; <var>y</var> } form a partitioning of the first <var>n</var> natural numbers 0 through <var>n</var>&#x2212;1.</td>
					</tr>
				</table>
				<p>From the fact that <var>x</var> and <var>y</var> are unbounded and from the invariance of <var>Q</var>1, which is true at initialization, we conclude the second result of Lambek and Moser, viz. that { <var>i</var> + <var>f </var>(<var>i</var>) | 0 &le; <var>i</var> } and { <var>j</var> + <var>g</var>(<var>j</var>) | 0 &le; <var>j</var> } form a partitioning of the natural numbers.</p>
				<p class="noindent"><em>Note.</em> By introducing <var>x</var> + <var>y</var> = <var>n</var> in program (1) we could have derived the second result of Lambek and Moser immediately; it, in turn, implies that the function <var>lambo</var> is its own inverse. But I thought the independent derivation of (6) more fun. (End of Note.)</p>
				<table width="100%" border="0" cellspacing="0" cellpadding="0">
					<col width="40%">
						<col width="20%">
							<col width="40%">
								<tr>
									<td align="right">*</td>
									<td></td>
									<td align="left">*</td>
								</tr>
								<tr>
									<td></td>
									<td align="center">*</td>
								</tr>
							</col>
						</col>
					</col>
				</table>
				<p>I am not quite clear about the moral of the above. We have proved theorems about the function <var>lambo</var> by first deriving a program for it and then massaging the program. For me this is a novel application of semantics preserving program transformations, and this novelty &#151;as all such novelties&#151; causes some mild excitement. On the other hand we know that a chain of program transformations is so close to a mechanically verifiable proof that it seems vain to hope to prove any &quot;deep&quot; theorems this way. (Here I should add that I get less and less certain about the significance of the supposed difference between &quot;deep&quot; and &quot;shallow&quot; theorems.) It is possibly no more than an occasionally neat way of formulating an otherwise not unusual mathematical argument.</p>
				<p></p>
				<table class="address" width="100%" border="0" cellspacing="0" cellpadding="0">
					<tr>
						<td valign="top">Plataanstraat 5<br>
							5671 AL NUENEN<br>
							The Netherlands</td>
						<td valign="top">8 February 1981<br>
							prof. dr. Edsger W. Dijkstra<br>
							Burroughs Research Fellow</td>
					</tr>
				</table>
				<hr>
				<p class="colofon">transcribed by G&#x00FC;nter Rote<br>
					revised <csobj format="MedDate" h="13" region="15" t="DateTime" w="97">Wed, 14 Nov 2007</csobj></p>
			</div>
		
		
			
			
			
				
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		
				
			
		
			
				
			
</body>
</html>


</x-html>


</body>
</html>
