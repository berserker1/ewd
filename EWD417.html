<!DOCTYPE html>
<html>
<head>
  <title>On the abolishment of the subscripted variable</title>
  <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
  <link href="assets/common.css" rel="stylesheet">
  <link href="assets/transcriptions.css" rel="stylesheet">
  <meta name="generator" content="convertArticle.pl">
</head>
<body>
<div class="metabar">
  <div class="metabar-inner">
    <a href="index.html">HOME</a>
  </div>
</div>
<h1>On the abolishment of the subscripted variable</h1>
<div class='body'>				<div align="left">					<div>						<p class="noindent"><u>				On the abolishment of the subscripted variable.</u></p>						<p class="noindent">(The following is written after discussions with C.Ligtmans, W.H.J.Feijen, M.Rem and C.S.Scholten, while during the first part A.Martin is looking over my shoulder.)</p>						<p>I have been trained to regard an array in the ALGOL 60 sense as a finite set of elementary variables, whose &quot;identifiers&quot; could be &quot;computed&quot;. For two reasons this view does not satisfy me anymore and now I prefer to regard an array as a single variable.</p>						<p>The one reason is to be found in my abhorrence for variables whose values are undefined, a state of affairs caused by the simultaneous introduction of all local variables upon block entry, possibly long before they are actually needed. Two would-be remedies have been suggested (and implemented) many times. The one suggestion is to extend the original range with an additional value &quot;<u>undefined</u>&quot; or &quot;<u>nil</u>&quot;; this is the kind of remedy that pure mathematicians tend to invent, but it leads to all sorts of conflicts, exceptions and logical patches. If one decides on a case of bigamy when two different persons have the same spouse, what about two bachelors, married to the same &quot;nobody&quot;? The other suggestion is to allow initialization and, if not specified, by default a normal value will be assigned (say &quot;0&quot; for an integer and &quot;true&quot; for a boolean variable); the one that follows the second suggestion fools himself even worse, because he has even lost himself the possibility of a run-time check for a common programming error. In the case of scalar variables a meaningful initialization is no problem if the variables are only introduced when needed; with a set of adequate sequencing primitives there need be no problem in saving the static scope concept: at each semicolon there need not exist any doubt as to which variables together build up the current state space and the common programming error referred to above can be caught mechanically prior to execution. This solution breaks down, however, in the case of arrays regarded as a large collection of elementary variables.</p>						<p>The second reason is of a combinatorial nature and more fundamental. In ALGOL 60 the compound statement that causes the variables <var>x</var> and <var>y</var> to interchange their values needs an additional variable, <var>h</var> say:</p>						<p class="nospace"><var>h</var>:= <var>x</var>; <var>x</var>:= <var>y</var>; <var>y</var>:= <var>h</var></p>						which is cumbersome and ugly compared to the concurrent assignment						<p class="nospace"><var>x</var>, <var>y</var>:= <var>y</var>, <var>x</var> .</p>						A requirement of the concurrent assignment is of course that the variables on the left-hand side are all different: no one should care to give &quot;<var>x</var>, <var>x</var>:= 1, 2&quot; a meaning (different from &quot;error&quot;). For a long time I hesitated to adopt the concurrent assignment on account of the problems it causes in a case like						<p class="nospace"><var>a</var>[<var>i</var>], <var>a</var>[<var>j</var>]:= <var>x</var>,<var> y</var> .</p>						Should it be allowed when <var>i</var> &#x2260; <var>j</var>, but never when <var>i</var> = <var>j</var>? Or is it permissible in the latter case also when <var>x</var> = <var>y</var>? What about						<p class="nospace"><var>a</var>[<var>i</var>], <var>a</var>[<var>j</var>]:= <var>a</var>[<var>j</var>], <var>a</var>[<var>i</var>] ?</p>						Clearly we are piling one complication upon another. However, I have now come to the conclusion that it is not the concurrent assignment but the notion of the subscripted variable that is to be blamed. In the axiomatic definition of the assignment statement via &quot;substitution for a variable&quot; &#x2014;as in, I guess, all parts of logic&#x2014; one cannot afford uncertainty as to whether two variables are &quot;the same&quot; or not.						<p>We can regard a variable of type &quot;integer&quot; as an integer-valued function without arguments &#x2014;and therefore with a domain consisting of a single anonymous point&#x2014;,a function that does not change unless explicitly changed (usually by means of an assignment).</p>						<p>Restricting ourselves to the analogon of a one-dimensional array, we can similarly regard a variable of type &quot;integer array&quot; as an integer-valued function with one argument with a domain in the integers &#x2014;a function, again, that does not change unless explicitly changed.</p>						<p>We now take the view that we shall only admit types such as that an algorithm can establish whether the values of two variables of the same type are equal or not. In the case of integer variables <var>x</var> and <var>y</var> this can be done by the boolean expression <var>x</var> = <var>y</var>, i.e. both functions <var>x</var> and <var>y</var> are evaluated in the only point of their domain and these values are compared.</p>						<p>Given two variables of type &quot;integer array&quot; their values are equal if, as functions, they have the same domain and in each point of the domain they both take the same value. In order to be able to perform these comparisons, we must restrict ourselves to finite domains and it must be possible to extract from the current value of an array variable the currently corresponding domain. For practical purposes we propose to restrict ourselves to domains consisting of consecutive integers.</p>						<p>If &quot;<var>av</var>&quot; is the name of an array variable, I assume a number of functions of its value and operations upon its value defined. They will be denoted by the identifier of the array variable, a dot, and then a reserved name. Unable to make my choice, I have introduced more than the minimum.</p>						<p>Depending on the domain only are the integer functions &quot;<var>av.size</var>&quot;, &quot;<var>av.first</var>&quot; and &quot;<var>av.last</var>&quot;; they will always satisfy</p>						<p class="nospace"><var>av.size</var> &#x2265; 0 and <var>av.last</var> - <var>av.first</var> = <var>av.size</var> - 1 .</p>						The corresponding domain for the function <var>av</var>(<var>k</var>) is given by						<p class="nospace"><var>av.first</var> &#x2264; <var>k</var> &#x2264; <var>av.last</var> .</p>						<p>The expression &quot;<var>av</var>(<var>k</var>)&quot; &#x2014;which could be regarded as a special purpose abbreviation for &quot;<var>av.val</var>(<var>k</var>)&quot;, a kind of abbreviation one can introduce just once!&#x2014; is regarded as any other function call with an integer argument transmitted by value: the argument needs only to be defined and within the domain when the evaluation <var>av</var>(<var>k</var>) is actually required.</p>						<p>As stated above, a scalar variable can be regarded as a function (without arguments) that can be changed by assignment. Similarly we need operations to change the value of an array variable. For practical reasons I do not consider &quot;assignment&quot; of an arbitrary value to an array variable as a primitive operation: if the domain is large this can be a very costly operation. I therefore prefer array values being built up sequentially by &quot;slight modifications&quot;.</p>						<p>Slight modifications are extending the domain by one, at either the &quot;high&quot; or the &quot;low&quot; end: in both cases <var>av.size</var> is increased by 1. With the extension at the high end <var>av.last</var> is increased by 1, with extension at the low end <var>av.first</var> is decreased by 1. For the argument value added to the domain, a value must be supplied simultaneously, it is really the well-known push-operation and with &quot;<var>x</var>&quot; an expression of the appropriate type we could write &quot;<var>av.hipush</var>(<var>x</var>)&quot; and &quot;<var>av.lopush</var>(<var>x</var>)&quot;; on the intersection of the old and the new domain the value of the function <var>av</var> will be left unaltered. Similarly, with initially <var>av.size</var> &gt; 0 and <var>x</var> a variable of the appropriate type, we can envisage the inverse operations &quot;<var>av.hipop</var>(<var>x</var>)&quot; and &quot;<var>av.lopop</var>(<var>x</var>)&quot;.</p>						<p>A further domain changing operation I envisage is a translation, say &quot;<var>av.trans</var>(<var>k</var>)&quot;, which increases <var>av.first</var> and <var>av.last</var> both by <var>k</var> and leaves 0 &#x2264; <var>i</var> &lt; <var>av.size</var> the value of <var>av</var>(<var>av.first</var> + <var>i</var>) unchanged.</p>						<p>The next thing is assignment. Conceptually there is no problem with an assignment of the form <var>av</var>1:= <var>av</var>2, but if that operation is included it should not look so innocent, and something like &quot;<var>av.ass</var>(<var>av</var>2)&quot; is already much better. The kind of assignment I am wiling to write down with &quot;:=&quot; are the ones in which the final size is small because the function values must be enumerated at the right-hand side; I could live with a format of the form</p>						<p class="nospace"><var>av</var>:= (0: 0, 1, 2, 3)</p>						which defines <var>av.first</var> = 0, <var>av.last</var> = 3, <var>av.size</var> = 4 and <var>av</var>(<var>i</var>) = <var>i </var>for 0 &#x2264; <var>i</var> &lt; 4. Perhaps even this is already too ambitious and should the right-hand side be restricted to values with <var>size</var> = 0. Note that in this proposal even the empty domain &quot;has a place&quot;: <var>first</var> and <var>last</var> are always defined: we need this for the operation <var>hipush</var> and <var>lopush</var> to be defined. The same values that are allowed in the assignment are allowed in the obligatory initialization.						<p>The remaining operations to be discussed are the ones that modify the value of <var>av</var> without changing its domain. An obvious candidate is altering just one of the function values: the analogon of the well-known assignment to the subscripted variable <var>av</var>[<var>k</var>]:= <var>E</var>; in order to avoid confusion I propose a radically different notation for altering just one function value, say &quot;<var>av.alt</var>(<var>k</var>, <var>E</var>)&quot; in order to do justice to our considerations that we change the whole function, a modification that requires two value parameters.</p>						<p>Another operation that I have learned to consider as &quot;fundamental&quot; &#x2014;whatever that may mean&#x2014; is &quot;<var>av.swap</var>(<var>i</var>, <var>j</var>)&quot;. Both arguments must lie in the current domain; if they are equal, it is the empty operation, otherwise the function values <var>av</var>(<var>i</var>) and <var>av</var>(<var>j</var>) are interchanged.</p>						<p class="noindent"><u>Note</u>. It is unwise to regard the swap as a special case of a cyclic rotation over one place in a cycle of length <var>n</var> with <var>n</var> = 2. Let us not introduce &#x2014;with a variable number of parameters!&#x2014; <var>av.rot</var>(<var>i</var>, <var>j</var>, <var>k</var>) say: first of all no one would be able to remember in which direction the values would be shifted cyclically, secondly the difficulties when not all arguments are different &#x2014;an awkward test, by the way!&#x2014; are just terrible. It is the total absence of these difficulties that justifies the view of &quot;swap&quot; as a fundamental primitive.</p>						<p>Finally, what about the declaration, what about our old &quot;subscript bounds&quot;? The implied &quot;bound checking&quot; in <var>av</var>(<var>k</var>), <var>av.alt</var>(<var>k</var>, <var>E</var>) and <var>av.swap</var>(<var>i</var>, <var>j</var>) is of course with respect to the current value of the domain, it is the test <var>av.first</var> &#x2264; <var>k</var>, <var>i</var>, <var>j</var> &#x2264; <var>av.last</var>. For reasons of storage reservation we can still think of supplying a lower and an upper bound as part of the declaration; they are no more than a lower bound for <var>av.first</var> and an upper bound for <var>av.last</var> respectively. Alternatively, we could give an upper bound for <var>av.size</var>. I can think of</p>						a)&nbsp;&nbsp;&nbsp;&nbsp;no bounds given<br>						b)&nbsp;&nbsp;&nbsp;&nbsp;a lower bound for first<br>						c)&nbsp;&nbsp;&nbsp;&nbsp;an upper bound for last<br>						d)&nbsp;&nbsp;&nbsp;&nbsp;the combination of b) and c)<br>						e)&nbsp;&nbsp;&nbsp;&nbsp;an upper bound for size.<br>						<br>						We recognize the unrestricted stacks and the cyclic buffer of limited capacity.						<p>The drastic difference between these bounds and the old array concept of ALGOL 60 is the following (if I understand the ALGOL 60 array and the notion of type correctly). In ALGOL 60 I have always viewed the bounds as a constant attribute of the array, just as constant as &quot;the type of a variable&quot;. From that point of view the one-dimensional integer arrays of ALGOL 60 provide for infinity<sup>2</sup> different &quot;types&quot;: viz. as many different types as we can define different bound-pairs.</p>						<p>Here it is proposed that all one-dimensional integer arrays are array variables of exactly the same type, while bounds possibly given in the declaration are regarded as hints to the implementation, hints the implementation may exploit or ignore. They are regarded as more than just a hint, they are also a permission &#x2014;but not an obligation!&#x2014; to abort when the domain exceeds the stated limitations. The bounds when stated in the declaration are not an aspect of the value of the array variable.</p>						<p>The above seems clean and sound. I would welcome comments very much, comments on various levels. It may seem clean and sound, yet there may be logical difficulties hidden somewhere that I have not seen; if someone finds one, I would be immensely grateful. Also comments on notations and names would be very welcome. (It took me very long to find something for the name &quot;alt&quot; which was eventually suggested by Feijen; and to say that I am proud of my &quot;hipush&quot; and &quot;lopop&quot; would violate the truth.)</p>						<p>Use of the dot in this way &#x2014;it is the first time I do it myself&#x2014; is something with which I have reasonable confidence: it gives us the possibility for the introduction of &quot;restrictedly reserved identifiers&quot;. I did not state any scope rules, but the idea is that the fact that <var>av</var> is of type &quot;integer array&quot; makes <var>av.swap</var> identify the operation it should identify. With the dot-notation we can make the post-dot identifiers subordinate to the type of the pre-dot identifier. If <var>av</var>1 is of type integer array, and <var>av</var>2 is of type boolean array, there is yet no &quot;polymorphism&quot; (I think it is called) involved when we compare <var>av</var>1.<var>val</var>(<var>k</var>) and <var>av</var>2.<var>val</var>(<var>k</var>): the one <var>val</var> is an integer function, the other <var>val</var> is a boolean function. Clearer perhaps is the comparison of <var>av</var>1.<var>swap</var>(<var>i</var>, <var>j</var>) and <var>swap</var>(<var>av</var>2, <var>i</var>, <var>j</var>), where according to common interpretation these would be regarded as two calls of the same library procedure. As said, I have a reasonable confidence in this use of the dot-notation, but any warning for its pitfalls is welcome.</p>						<p></p>					</div>					<table width="459" border="0" cellspacing="2" cellpadding="0">						<tr>							<td valign="top" width="203">Burroughs<br>								Plataanstraat 5<br>								NUENEN - 4565<br>								The Netherlands</td>							<td valign="top" width="250">prof.dr.Edsger W.Dijkstra<br>								Burroughs Research Fellow								<p>20th March 1974</p>							</td>						</tr>					</table>				</div>				<hr>				<font size="-1">transcribed by Tristram Brelstaff<br>					revised <csobj format="MedDate" h="16" region="15" t="DateTime" w="96">Fri, 16 Jul 2010</csobj></font>																								</body></html></div>
</body>
</html>
