  <!DOCTYPE html>
  <html>
  <head>
    <title>Stepwise Program Construction</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <link href="assets/tweet-selection.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.12.0.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="assets/tweet-selection.js"></script>
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: Stepwise Program Construction" />
    <meta name="twitter:title" content="Stepwise Program Construction" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>Stepwise Program Construction</h1>
  <div class='body'>					<p>Over the past years I have been (heavily) engaged in a number of (at that time) advanced programming projects that could be considered as large in comparison to the available manpower. I am still in the active process of learning from the experience gained, one of the immediate goals of this learning process being the discovery of better ways to construct even &quot;small programs&quot; in a reliable fashion. Although large, advanced and sophisticated programming efforts are more spectacular, we must not forget that quite a lot of machine time and programmer's energy is really spent on small, down-to-earth projects and the present efforts to make computing facilities more directly accessible for the individual user will only reinforce this tendency.</p>					<p>For the interested reader I am going to make two programs and, besides that, I am going to show the individual steps in which they have been constructed. The`examples serve to illustrate parts of my present understanding of the demands, that the task of programming makes upon the human mind.</p>					<p>In my approach there are some central themes that I shall just mention for the proper understanding of the following. The one theme is that, although the program made by the programmer is his final product, the computations evoked by it are the true subject matter of his trade: he has to guarantee that the computations &#x2014;the &quot;making&quot; of which he leaves to the machine&#x2014; evoked by his program will have the desired effect. As a result he has the duty to structure his program in a useful way, where usefulness (among other things) implies that the form of the program admits trustworthy statements about the corresponding computations. The second theme is that the mental aids available to the human programmer are, in fact, very few. They are enumeration, mathematical induction and abstraction, where the appeal to enumeration has to satisfy the severe boundary condition that the number of cases to be considered separately, should be very, very small. The introduction of suitable abstractions is our only mental aid to reduce the appeal to enumeration, to organize and master complexity. Mathematical induction has been mentioned explicitly because it is the appropriate (and only!) established pattern of reasoning by which we can understand programs with either repetitive clauses or recursive procedures. As a corollary I mention the fact that for some time I knew that as a programmer I could live quite happily without any form of <b>go to</b> statements but that in the mean time my considered opinion is that I cannot live happily with the <b>go to</b> statement.</p>					<p>To avoid misunderstanding I should like to state explicitly that I do not claim that the two programs produced are the best possible, measured (probably!) in terms of your private yard-stick. I do claim that they are fairly good and reasonable in terms of the average yard-stick, i.e. that they present utterly realistic solutions. I do claim to have achieved a degree of clarity and transparency of an order of magnitude better than the average programmer's solution, that my solutions have been reached with an intellectual effort considerably below average and that they admit exhaustive verification. And that is more than can be said about many a program.</p>					<p>The reason to treat two examples is because they have been drawn from vastly different fields: the one dealing with prime numbers is a so-called scientific application, the other, dealing with the idiosyncrasies of Flexowriters, is a so-called clerical application. These two fields are often regarded as completely foreign to each other: the successful application of the same discipline as illustrated below gives a strong support to the assumption that the difference between scientific and clerical machine usage is by no means an inherent difference, but more probably the result of a difference in intellectual level and professional training of the people engaged.</p>					<p>(Note. I do not feel myself called to justify the choice of my examples, which are a kind of random draws from what is happening around me: emotionally speaking, prime numbers leave me as unaffected as Flexowriters.)</p>					<p></p>					<h2>The construction of a table of the first 1000 prime numbers.</h2>					<p>&quot;Given an <tt><u>integer</u> <u>array</u> <var>p</var>[1:1000]</tt>, make a program making its elements in order of increasing subscript value equal to the successive prime numbers, where 2 is considered as the first prime number.&quot;</p>					<p>Well-defined as this task may seem to the benevolent reader, as we go along we shall discover an undefined boundary between the amount of mathematical knowledge the programmer is willing to embody in his program and the amount of computation he leaves to the machine.</p>					<p>To start with: for the task to make sense it must be <em>known</em> that at least 1000 primes actually exist. We grant the programmer this knowledge and at a certain stage of program construction we allow him to appeal to this fact when he has to prove that his program does indeed halt.</p>					<p>We shall now give the coarsest version of the program, viz. version 0:</p>					<pre><u>begin</u> &quot;assign to the array <var>p</var> the prime table as described&quot; <u>end</u></pre>					<p>When this action occurs among the well-understood and well-defined repertoire of actions from which the computation has to be composed, version 0 solves our problem. For the sake of argument we now assume that this action does <em>not</em> occur among the repertoire; particularly we restrict ourselves to repertoires in which we can operate on arrays only element wise. This implies that in our next version the order in which the elements of the array <var><tt>p</tt></var> will get their desired value has to be expressed and in it we shall try to express just that and preferably nothing more.</p>					<p>An obvious version of the program then starts with</p>					<pre><u>begin</u> <var>p</var>[1]:= 2; <var>p</var>[2]:= 3; <var>p</var>[3]:= 5; <var>p</var>[4]:= 7; <var>p</var>[5]:= 11;.......</pre>					implying that the programmer's knowledge includes a table of the first 1000 primes. We shall not pursue this version, as it would imply that the programmer hardly needed the machine at all.					<p>The first prime number being given (=2), the thousandst being assumed unknown to the programmer, the most natural order to fill the elements of the array <var><tt>p</tt></var> is in order of increasing subscript value and if we express just that (with a simple repetitive <tt><u>while</u> <u>do</u></tt> clause) we come to version 1a:</p>					<pre><u>begin</u> <u>integer</u> <var>k</var>,<var>j</var>; <var>k</var>:= 1; <var>j</var>:= 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>k</var> &#x2264; 1000 <u>do</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> &quot;increase <var>j</var> until the next prime number&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>p</var>[<var>k</var>]:= <var>j</var>; <var>k</var>:= <var>k</var> + 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u><u>end</u></pre>					<p>Identifying <var><tt>k</tt></var> as the subscript value of the element whose turn it is to be filled the correctness of version 1a is easily proved by mathematical induction (under the assumption of the existence of a sufficient number of primes).</p>					<p>Version 1a is a perfect program when the operation described by &quot;increase <var><tt>j</tt></var> until the next prime number&quot; occurs among the repertoire, but let us suppose that it does not. In that case we have to express how <var><tt>j</tt></var> is increased and in our next elaboration we shall try to express just that and preferably nothing more. With a simple repetitive <tt><u>repeat</u> <u>until</u></tt> clause (which may act upon a sequence of statements) we come for <tt>&quot;increase <var>j</var> until the next prime number&quot;</tt> to version 2a:</p>					<pre><u>begin</u> boolean <var>jprime</var>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> <var>j</var>:= <var>j</var> + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;give to <var>jprime</var> the meaning: <var>j</var> is a prime number&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> <var>jprime</var><u>end</u></pre>					<p>If we substitute version 2a for the appropriate operation in version 1a our resulting program is undoubtedly correct. But if we assume that the programmer knows that, apart from 2, all prime numbers are odd, then we may expect that he will be dissatisfied with the obvious inefficiency of version 2a. The price to be paid for this, call it &quot;lack of clairvoyance&quot; is a revision of version 1a, in which the prime number 2 is dealt with separately, after which the cycle can deal with the odd primes. So we come to version 1b:</p>					<pre><u>begin</u> integer <var>k</var>,<var>j</var>; <var>p</var>[1]:= 2; <var>k</var>:= 2; <var>j</var>:= 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>k</var> &#x2264; 1000 <u>do</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> &quot;increase odd <var>j</var> until the next odd prime number&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>p</var>[<var>k</var>]:= <var>j</var>; <var>k</var>:= <var>k</var> + 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>endend</u> </pre>					<p class="continue">where the analogous elaboration of the operation between quotes leads to version 2b:</p>					<pre><u>begin</u> boolean <var>jprime</var>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> <var>j</var>:= <var>j</var> + 2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;give to <var>jprime</var> for odd <var>j</var> the meaning:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>j</var> is a prime number&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> <var>jprime</var><u>end</u></pre>					<p>The above oscillation between versions 1 and versions 2 is in fact nothing else but moving the interface between the overall structure and the primitive that has to fit in this structure. This is definitely not attractive, but with a sufficient lack of clairvoyance and being forced to take our decisions in sequence, I see no other way: we can regard our efforts as experiments to explore where the interface can be most conveniently chosen.</p>					<p>Encouraged by the success of treating 2 apart, we investigate what can be gained by treating 3 apart as well. For this purpose we introduce the property &quot;throdd&quot;, i.e. neither divisible by 2, nor by 3. The throdd numbers are of the form 6<var>N</var>+1 or 6<var>N</var>+5. By definition, 2 and 3 are the only prime numbers not contained in the set of throdd numbers and so we come to version 1c:</p>					<pre><u>begin</u> <u>integer</u> <var>k</var>,j; <var>p</var>[1]:= 2; <var>p</var>[2]:= 3; <var>k</var>:= 3; <var>j</var>:= 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>k</var> &#x2264; 1000 <u>do</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> &quot;increase throdd <var>j</var> until&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the next throdd prime number&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>p</var>[<var>k</var>]:= <var>j</var>; <var>k</var>:= <var>k</var> + 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u><u>end</u></pre>					<p class="noindent">where the analogous elaboration of the operation between quotes leads to version 2c:</p>					<pre><u>begin</u> <u>boolean</u> <var>jprime</var>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> &quot;increase throdd <var>j</var> until the next throdd value&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;give to <var>jprime</var> for throdd <var>j</var> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the meaning: <var>j</var> is a prime number&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> jprime<u>end</u></pre>					<p>This is only an improvement when the operation &quot;<tt>increase throdd <var>j</var> until the next throdd value</tt>&quot; is easily implemented. The proper increase of <var><tt>j</tt></var> is a function of <var><tt>j</tt></var>: call it &quot;<tt>INC(<var>j</var>)</tt>&quot;. Its value is =4 when <var><tt>j</tt></var>=6<var>N</var>+1, its value is =2 when <var><tt>j</tt></var>=6<var>N</var>+5. Instead of freshly evaluating the function <tt>INC(<var>j</var>)</tt> whenever we need it, we introduce a separate variable, <var><tt>inc</tt></var> say, to record the current value of <tt>INC(<var>j</var>)</tt>, corresponding to the current value of <var><tt>j</tt></var>. The variable <var><tt>inc</tt></var> has to be set initially when <var><tt>j</tt></var> is set, it has to be adjusted whenever the value of<var> <tt>j</tt></var> is changed. (The introduction of <var><tt>inc</tt></var> is an instance of a standard programmer's device to trade variable space for computation speed.) Using list-assignments to stress that <var><tt>inc</tt></var> is just a companion of <var><tt>j</tt></var>, the introduction of <var><tt>inc</tt></var> and the elaboration of &quot;increase throdd <var><tt>j</tt></var> until the next throdd value&quot; leads to version 1d:</p>					<pre><u>begin</u> <u>integer</u> <var>k</var>,<var>j</var>,<var>inc</var>; <var>p</var>[1]:= 2; <var>p</var>[2]:= 3; <var>k</var>:= 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<var>j</var>,<var>inc</var>):= (1,4);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>k</var> &#x2264; 1000 <u>do</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> &quot;increase throdd <var>j</var>, adjustment of <var>inc</var> included, &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;until the next throdd prime number&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>p</var>[<var>k</var>]:= <var>j</var>; <var>k</var>:= <var>k</var> + 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u><u>end</u></pre>					where the elaboration of the operation between quotes leads to version 2d:					<pre><u>begin</u> <u>boolean</u> <var>jprime</var>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> (<var>j</var>,<var>inc</var>):= (<var>j</var> + <var>inc</var>, <var>6</var> - <var>inc</var>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;give to <var>jprime</var> for throdd <var>j</var> the meaning:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>j</var> is a prime number&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> <var>jprime</var><u>end</u></pre>					<p>There is no indication that any gain will result from taking the next prime (i.e. 5) out of the cycle as well and we shall not try it.</p>					<p>Again, when &quot;<tt>give to <var>jprime</var> for throdd <var>j</var> the meaning: <var>j</var> is a prime number</tt>&quot; is an operation from the presupposed repertoire, then our program is finished. We now assume that it is not, in other words we have to evoke a computation deciding whether a given throdd <var><tt>j</tt></var> has a factor. It is only at this stage that the algebra really enters the picture. Here we make use of the knowledge that we only need to try prime numbers as factors; furthermore we shall use that the prime numbers to be tried can already be found in the filled portion of the array <var><tt>p</tt></var>.</p>					<p>We use the facts that</p>					<ol>						<li type="a" class="noindent">&nbsp;<var><tt>j</tt></var> being a throdd value, the smallest potential factor to be tried is <tt><var>p</var>[3]</tt>, i.e. the first prime above 3;						<li type="a" class="noindent">the largest prime factor we have to try is <tt><var>p</var>[<var>ord</var>-1]</tt>, when <tt><var>p</var>[<var>ord</var>]</tt> is the smallest prime number whose square exceeds <var><tt>j</tt></var>.					</ol>					<p>If this set is not empty, we have a chance of finding a factor and as soon as a factor has been found, the investigation of this particular <var><tt>j</tt></var> value can be stopped. We have to decide in which order the prime numbers from the set will be tried and we shall do so in order of increasing magnitude because the smaller a prime number the larger the probability of its being a factor of <var><tt>j</tt></var>.</p>					<p>In our first elaboration of &quot;<tt>give to <var>jprime</var> for throdd <var>j</var> the meaning: <var>j</var> is a prime number</tt>&quot; we come to version 3d:</p>					<pre><u>begin</u> <u>integer</u> <var>n</var>,<var>ord</var>; <u>boolean</u> <var>nofactorfound</var>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ord:= 1; <u>while</u> <var>p</var>[<var>ord</var>]^2 &#x2264; <var>j</var> <u>do</u> <var>ord</var>:= <var>ord</var> + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>n</var>:= 3; <var>nofactorfound</var>:= <u>true</u>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>n</var> &lt; <var>ord</var> <u>and</u> <var>nofactorfound</var> <u>do</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> &quot;give to <var>nofactorfound</var> the meaning:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>p</var>[<var>n</var>] is no factor of <var>j</var>&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>n</var>:= <var>n</var> + 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<var>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jprime</var> := <var>nofactorfound</var><u>end</u></pre>					<p>Here we make two observations. The boolean variable celled &quot;<var><tt>nofactorfound</tt></var>&quot; is superfluous, we could have used <var><tt>jprime</tt></var> instead, so that the last assignment statement can be removed. Furthermore, <var><tt>ord</tt></var> is a function of <var><tt>j</tt></var> that we need not recompute freshly every time, but that we can and should treat along the same line as <var><tt>inc</tt></var>. The latter remark causes the final revision of version 1, leading to version 1e:</p>					<pre><u>begin</u> <u>integer</u> <var>k</var>,<var>j</var>,<var>inc</var>,<var>ord</var>; <var>p</var>[1]:= 2; <var>p</var>[2]:= 3; <var>k</var>:= 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<var>j</var>,<var>inc</var>,<var>ord</var>):= (1,4,1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>k</var> &#x2264; 1000 <u>do</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> &quot;increase throdd <var>j</var>, adjustment of <var>inc</var> and<var>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ord</var> included, until the next throdd prime number&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>p</var>[<var>k</var>]:= <var>j</var>; <var>k</var>:= <var>k</var> + 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u><u>end</u></pre>					where the elaboration of the operation between quotes leads to version 2e:					<pre><u>begin</u> <u>boolean</u> <var>jprime</var>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> (j,inc):= (j + inc, 6 - inc);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> p[ord]^2 &#x2264; j <u>do</u> ord:= ord +1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;give for throdd <var>j</var>, using <var>p</var> and <var>ord</var>, to <var>jprime</var>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the meaning: <var>j</var> is a prime number&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> jprime<u>end</u></pre>					(Remark: here &quot;<tt><u>while</u> <var>p</var>[<var>ord</var>]^2 &#x2264; <var>j</var> <u>do</u></tt>&quot; can be replaced by &quot;<tt><u>if</u> <var>p</var>[<var>ord</var>]^2 &#x2264; <var>j</var> <u>then</u></tt>&quot;, but to my taste the marginal gain in efficiency is not worth the intellectual effort to prove its validity. A programmer should learn to be lazy at the right moment and to let the principle &quot;Safety First&quot; prevail!)					<p>Elaboration of the operation between quotes gives a variant of version 3d, viz. version 3e:</p>					<pre><u>begin</u> <u>integer</u> <var>n</var>; <var>n</var>:= 3; <var>jprime</var>:= <u>true</u>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>n</var> &lt; <var>ord</var> <u>and</u> <var>jprime</var> <u>do</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> &quot;give to <var>jprime</var> the meaning: <var>p</var>[<var>n</var>] is no&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factor of <var>j</var>&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>n</var>:= <var>n</var> + 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u><u>end</u></pre>					<p>For &quot;<tt>give to jprime the meaning: <var>p</var>[<var>n</var>] is no factor of <var>j</var></tt>&quot; we may write under the assumption of decent real arithmetic</p>					<pre><u>begin</u> <u>real</u> <var>q</var>; <var>q</var>:= <var>j</var> / <var>p</var>[<var>n</var>]; <var>jprime</var> := (entier(<var>q</var>) != <var>q</var>) <u>end</u>;</pre>					we shall assume the availability of the integer division and write version 4e:					<pre><var>jprime</var> := (<var>j</var> != (<var>j</var> / <var>p</var>[<var>n</var>]) * <var>p</var>[<var>n</var>])</pre>					Finally we perform all substitutions to construct a single statement.					<pre><u>begin</u> <u>integer</u> <var>k</var>,<var>j</var>,<var>inc</var>, <var>ord</var>; <var>p</var>[1]:= 2; <var>p</var>[2]:= 3; <var>k</var>:= 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<var>j</var>,<var>inc</var>,<var>ord</var>):= (1,4,1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>k</var> &#x2264; 1000 <u>do</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>begin</u> <u>boolean</u> <var>jprime</var>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> (<var>j</var>,<var>inc</var>):= (<var>j</var> + <var>inc</var>, 6 - <var>inc</var>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>p</var>[<var>ord</var>]^2 &#x2264; <var>j</var> <u>do</u> <var>ord</var>:= <var>ord</var> + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>integer</u> <var>n</var>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>n</var>:= 3; <var>jprime</var>:= <u>true</u>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>n</var> &lt; <var>ord</var> <u>and</u> <var>jprime</var> <u>do</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <var>jprime</var>:=(<var>j </var>!= (<var>j</var>/<var>p</var>[<var>n</var>])*<var>p</var>[<var>n</var>]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>n</var>:= <var>n</var> + 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> <var>jprime</var>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>p</var>[<var>k</var>]:= <var>j</var>; <var>k</var>:= <var>k</var> + 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u><u>end</u></pre>					<p>We could have made the inner blocks into compound statements by moving the declarations for <var><tt>jprime</tt></var> and <var><tt>n</tt></var> to the outside. We have not done so: clarity does not gain by it and whether there is a point in doing it is rather dependent on the implementation.</p>					<p>And thus ends the treatment of the first example.<br>						<br>						<br>						<br>					</p>					<h2>The unique reporting of the printed page as produced on a Flexowriter.</h2>					<p>For our purpose we can regard a Flexowriter as a kind of electric typewriter which is operated only via the keys of its keyboard. Whenever a key is pressed, a configuration characteristic for this key is punched in a paper tape which is then moved on over one position. Typing a page thus implies the production of a paper tape specifying what has been typed. (Indeed: besides the punching station the Flexowriter has also a reading station, from which the printing mechanism can be controlled. By inserting the paper tape just produced into the reading station one can obtain another copy of the printed page.)</p>					<p>We want to program a routine which reads such a paper tape and gives, when called repeatedly, a unique description of the corresponding page image, according to conventions to be described below. As we go along we shall see that this is no trivial matter, because (mainly due to the construction of the Flexowriter) the very same page image may correspond to many paper tapes, greatly varying among each other. (In our example we shall simplify the real situation slightly: we shall exclude the unexpected occurrence of &quot;end of tape&quot; and exclude the situation that the paper tape reader of the computer discovers &#x2014;due to some error in punching or reading&#x2014; an illegal configuration. Even thus simplified, the problem is messy and intricate enough to serve our purpose!)</p>					<p>Two remarks about the form in which we shall present our solution:</p>					<ol>						<li>the routine will be coded as an operator, operating in a local universe of permanently existing variables; we shall use small letters for their identifiers.						<li>constants, referring to the integer values associated with characters will be denoted by identifiers composed from capital letters.					</ol>					<p>In its coarsest form the local universe contains one integer variable, called &quot;<var><tt>charf</tt></var>&quot; and the operator can be described by version 0:</p>					<pre><u>begin</u> &quot;assign to <var>charf</var> the next value&quot; <u>end</u></pre>					<p>Our Flexowriter has equal spacing, i.e. each line has a fixed number of print positions. There is a finite number of so-called &quot;position characters&quot; (this thanks to the absence of a backspace key on our Flexowriters, that would allow a practically unlimited number of superpositions) and each position character can occur at each print position of the page. A numerical code for the position characters has been chosen and the operator reports by assigning to charf the numerical value associated with the position character in the current print position, dealing with the print positions in each line in order from left to right and with the lines in order from top to bottom.</p>					<p>With respect to the left margin we assume that its position on the printed page is given; to indicate the right hand end of a line we have extended the range of <var><tt>charf</tt></var> values with an additional one, denoted by &quot;<tt>RET</tt>&quot; (i.e. New Line, Carriage Return) and require for the sake of uniqueness that all &quot;invisible&quot; spaces at the right hand end of a line are suppressed. It is as if <tt>RET</tt> is counted among the visible position characters but that its (symbolic) printing position has to be aligned to the left as far as possible.</p>					<p>It is the purpose of version 1 to suppress any spaces at the right hand end of each line; for its benefit the local universe has been extended with two integer variables:</p>					<table width="100%" border="0" cellspacing="2" cellpadding="0">						<tr>							<td valign="top" width="20%"><var><tt>charf1</tt></var>:</td>							<td>the range of this variable equals that of <var><tt>charf</tt></var>, but in the time sequence of its values invisible spaces at the right hand end of each line will still occur (if present, of course)</td>						</tr>						<tr>							<td valign="top" width="20%"><var><tt>stock</tt></var>:</td>							<td>this is a counter; its value equals the number of times that <var><tt>charf</tt></var> can be filled with a next value, before <var><tt>charf1</tt></var> has to be refilled. It requires the initial setting &quot;<var>stock</var>:= 0&quot;.</td>						</tr>					</table>					<p>Version 1 implements the look ahead whenever via <var><tt>charf1</tt></var> one or more spaces are reported; when followed by <tt>RET</tt> they have to be suppressed, otherwise they have to be transmitted.</p>					version1:					<pre><u>begin</u> <u>if</u> <var>stock</var> = 0 <u>then</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>repeat</u> &quot;assign to <var>charf1</var> the next value&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>stock</var>:= <var>stock</var> + 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> <var>charf1</var> != SPACE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> <var>charf1</var> = RET <u>then</u> <var>stock</var> := 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>charf</var>:=(<u>if</u> <var>stock</var> &gt; 1 <u>then</u> SPACE <u>else</u> <var>charf1</var>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>stock</var>:= <var>stock</var> - 1<u>end</u></pre>					<p>Our next complication is that the &quot;position character&quot; as reported in <var><tt>charf1</tt></var> (with the exception of <tt>RET</tt>) may be composed of three parts: by means of the mechanism of a so-called non-escaping key (i.e. one that leaves the carriage position as it is) one can superpose various &quot;key characters&quot; in the same print position. We have in fact two such key characters, viz. underlining and a vertical stroke. It is the purpose of version2 (an elaboration of &quot;assign to <var>charf1</var> the next value&quot;) to combine the key characters referring to the same print position.</p>					<p>We have to take into account</p>					<ol>						<li>that non-escaping key characters have to be combined with the first following escaping key character						<li>that repetition of the same non-escaping key character in the same print position must be considered as equivalent to its single occurrence.					</ol>					<p>For the benefit of version2 we extend the local universe with one integer variable,</p>					<table width="100%" border="0" cellspacing="2" cellpadding="0">						<tr>							<td valign="top" width="20%"><var><tt>charf2</tt></var>:</td>							<td valign="top">the range of this variable covers those <var>charf</var> values corresponding to position characters, produced without non-escaping key characters plus the values denoted by <tt>UNDER</tt> and <tt>STROKE</tt>.</td>						</tr>					</table>					<p>As a matter of fact, 0 &#x2264; <var>charf2</var> &#x2264; 127 will be satisfied; the presence of underlining will be coded in <var><tt>charf1</tt></var> by an increase of 128, that of a stroke by an increase of 256.</p>					<p>Our tentative elaboration of &quot;<tt>assign to <var>charf1</var> the next value</tt>&quot; gives rise to version2 (here <tt>CRAZY2</tt> denotes a constant value well beyond the range of <var><tt>charf2</tt></var>)</p>					version2:					<pre><u>begin</u> <u>integer</u> <var>under</var>, <var>stroke</var>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>under</var>:= 0; <var>stroke</var>:= 0; <var>charf1</var>:= CRAZY2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> &quot;assign to <var>charf2</var> the next value&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> <var>charf2</var> = UNDER <u>then</u> <var>under</var>:= 128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>else</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> <var>charf2</var> = STROKE <u>then</u> <var>stroke</var>:= 256&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>else</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>charf1</var>:= <var>charf2</var>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> <var>charf1</var> != CRAZY2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>charf1</var>:= <var>charf1</var> + <var>under</var> + <var>stroke</var><u>end</u></pre>					<p>We have said &quot;tentative elaboration&quot;, because as it stands, this version will not prevent, say, the transmission of an underlined <tt>RET</tt>: &quot;<tt><var>charf2</var> = UNDER</tt>&quot; followed by &quot;<tt><var>charf2</var> = RET</tt>&quot; requires the insertion of an additional space to be underlined. As pure spaces (i.e. without underlining or stroke) preceding <tt>RET</tt> will be suppressed by version 1 anyhow, we can (and shall) remedy this situation by imposing upon &quot;<tt>assign to <var>charf2</var> the next value</tt>&quot; the requirement that it will never transmit <tt>RET</tt> unless immediately preceded by a transmission of <tt>SPACE</tt>.</p>					<p>The next complication is that our Flexowriters are equipped with a tabulator key <tt>TAB</tt> which, when pressed, gives rise to a punching in the paper tape, while the carriage moves on until the next tabulator stop that is more than one position to the right of the current position: the carriage moves over at least two positions. The positions of the tabulator stops are standardized (once every eight positions) but it implies that the algorithm deriving the number of spaces corresponding to <tt>TAB</tt> must be aware of the current position of the carriage (at least modulo 8). It is the purpose of version3 &#x2014;the elaboration of &quot;<tt>assign to <var>charf2</var> the next value</tt>&quot;&#x2014; to translate tabulations into the equivalent number of spaces and to insert a <tt>SPACE</tt> before <tt>RET</tt>.</p>					<p>For its benetit we introduce into the local universe three integer variables.</p>					<table width="100%" border="0" cellspacing="2" cellpadding="0">						<tr>							<td valign="top" width="20%"><var><tt>charf3</tt></var>:</td>							<td valign="top">the range of this variable is that of <var><tt>charf2</tt></var>, extended with <tt>TAB</tt>;</td>						</tr>						<tr>							<td valign="top" width="20%"><var><tt>pos</tt></var>:</td>							<td valign="top">keeps track of the current carriage position; when &quot;<tt><var>charf2</var> = RET</tt>&quot; occurs it will be set to zero, when &quot;<tt><var>charf2</var> = TAB</tt>&quot; occurs it will be increased until the proper multiple of 8 etc. It requires an initial setting, say &quot;<tt><var>pos</var>:= 0</tt>&quot;.</td>						</tr>						<tr>							<td valign="top" width="20%"><var><tt>substock</tt></var>:</td>							<td valign="top">this is a counter; its value equals the number of times that <var><tt>charf2</tt></var> can be filled with its next value before <var><tt>charf3</tt></var> has to be refilled. It requires the initial setting &quot;<tt><var>substock</var>:= 0</tt>&quot;.</td>						</tr>					</table>					<p>We arrive at the following elaboration ot &quot;<tt>assign to <var>charf2</var> the next value</tt>&quot;. (Note. As it stands I am not very much satistied with the coding of version3. The way in which <tt>SPACE</tt> before <tt>RET</tt> is smuggled in, for instance, is too tricky. As it stands it is, however, the first version I wrote down for it.)</p>					version3:					<pre><u>begin</u> <u>if</u> <var>substock</var> = 0 <u>then</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> &quot;assign to <var>charf3</var> the next value&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> <var>charf3</var> != UNDER <u>and</u> <var>charf3</var> != STROKE <u>then</u> <var>pos</var>:= <var>pos</var> + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> <var>charf3</var> != RET <u>and</u> <var>charf3</var> != TAB <u>then</u> <var>charf2</var> := <var>charf3</var>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>else</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <var>charf2</var>:= SPACE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> <var>charf3</var> = RET <u>then</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <var>substock</var>:= 1; <var>pos</var>:= 0 <u>end</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>else</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <var>substock</var>:= (<var>pos</var> + 8 + 1) * 8 - <var>pos</var>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>pos</var>:= <var>pos</var> + <var>substock</var> <u>end</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>else</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <var>charf2</var>:=(<u>if</u> <var>charf3</var> = TAB <u>then</u> SPACE <u>else</u> RET);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>substock</var>:= <var>substock</var> - 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u><u>end</u></pre>					<p>The last complication presented by the structure of the Flexowriter is its built-in memory element, called &quot;the case&quot;. It is in one of two states, called &quot;upper case&quot; and &quot;lower case&quot; respectively. When it is in the state upper case it remains in this state until the key &quot;LOWER CASE&quot; is pressed, what furthermore results in punching the value &quot;<tt>LC</tt>&quot; in the paper tape; when it is in the state lower case, it remains in this state until the key &quot;UPPER CASE&quot; is pressed, what results in punching the value &quot;<tt>UC</tt>&quot; in the paper tape. When pressing any of the other keys, the punching is only dependent on the key pressed, the painting is (except for the space bar, the tabulator and the carriage return) dependent on the current case as well.</p>					<p>In version4 &#x2014;an elaboration of &quot;<tt>assign to <var>charf3</var> the next value</tt>&quot;&#x2014; we have to implement the influence of the case punchings. For the benefit of it we extend the local universe with two integer variables</p>					<table width="100%" border="0" cellspacing="2" cellpadding="0">						<tr>							<td valign="top" width="20%"><var><tt>octade</tt></var>:</td>							<td valign="top">used to record the next punching on the paper tape</td>						</tr>						<tr>							<td valign="top" width="20%"><var><tt>case</tt></var>:</td>							<td valign="top">this variable may have the values <tt>LC</tt> or <tt>UC</tt> (ur possibly a third one, meaning &quot;undefined&quot;, because space, tabulation and carriage return can be processed case independently). It must get an initial value, say &quot;<tt><var>case</var>:= LC</tt>&quot;.</td>						</tr>					</table>					<p>At this same level we implement that two legal punchings (<tt>BLANK</tt> and <tt>ERASE</tt>, corresponding to no holes and all holes respectively) are skipped without any possible effect on the page image. <tt>CRAZY3</tt> denotes a constant outside the legal range for <var><tt>charf3</tt></var>.</p>					version4:					<pre><u>begin</u> <var>charf3</var>:= CRAZY3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> &quot;give <var>octade</var> its next value&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> <var>octade</var> != BLANK <u>and</u> <var>octade</var> != ERASE <u>then</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>if</u> <var>octade</var> = LC <u>or</u> <var>octade</var> = UC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>then</u> <var>case</var>:= <var>octade</var>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>else</u> <var>charf3</var>:= fun(<var>case</var>, <var>octade</var>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> <var>charf3</var> != CRAZY3<u>end</u></pre>					<p>With &quot;<tt>give <var>octade</var> its next value</tt>&quot; I indicate the paper tape read instruction and I shall not elaborate it any further. The function &quot;<tt>fun(<var>case</var>,<var>octade</var>)</tt>&quot; is also left undescribed: it is too much dependent on the special numerical codes; we only mention that upper and lower case space (tab or ret) must both be transmitted as <tt>SPACE</tt> (<tt>TAB</tt> or <tt>RET</tt>).</p>					<p>The successive insertions of version &quot;<var>i</var> + 1&quot; into version &quot;<var>i</var>&quot; is left to the industrious reader (or should I say &quot;writer&quot;?).</p>					<h2>Concluding Remarks.</h2>					<p>Before stressing the similarity of the ways in which our two problems have been solved I should draw attention to a difference. In the first example I have paid considerable attention to the decision where to put the interface between the successive levels, in the second one I did no longer do so. I do not believe that the origin of this difference is in any way related to the supposed contrast between &quot;scientific&quot; and &quot;clerical&quot; machine applications, for it has a perfect historical and psychological explanation. The historical explanation is that I have used the prime number table generation problem in a number of oral examinations, the psychological explanation is that, treating the second example I am getting tired and perfectly willing to leave to my readers the intellectual satisfaction of improvement.</p>					<p>Personally I am much more impressed by the similarity of the ways in which the two rather different programs have been constructed. The successive versions appear as successive levels of elaboration. It is apparently essential for each level to make a clear separation between &quot;what it does&quot; and &quot;how it works&quot;. The description of &quot;what it does&quot;, the definition of its net effect requires the introduction of the adequate concepts and both examples seem to show a way in which we can use our power of abstraction to reduce the appeal to be made upon enumeration.</p>					<p>As stated in the introduction we may expect that computers will become more directly accessible for the individual user and we may expect that the latter should like to use its capabilities for the text manipulations involved in program composition. At present I am rather unsure about the true nature of the text manipulations the user would then like to perform: it is certainly something more structured than just deletion and insertion of characters or lines! In the fervent hope of getting a better understanding of what these manipulations are I have reported two instances of program construction as detailed and as honestly as I possibly could.</p>					<p>Finally: if I did hit a worth-while nail on its head, then this manuscript should end with a proper acknowledgement, giving honour where honour is due. Under the present circumstances I can only express my gratitude to.... my Friends or Relations, my Masters, Colleagues and Pupils.</p>					<p class="noindent">Eindhoven. February 1968</p>					<p class="noindent"></p>					<hr>					<p class="continue"><font size="-1">transcribed by Saleem Shafi<br>							revised <csobj format="MedDate" h="13" region="15" t="DateTime" w="88">Fri, 12 Dec 2008</csobj></font></p>				</div>			</div>							</body></html></div>
  <script>
$('.body').tweetSelection({
  ellipsis: '...',
  quoteLeft: '\'',
  quoteRight: '\'',
  via: 'raboofje'
});
  </script>
  </body>
  </html>
