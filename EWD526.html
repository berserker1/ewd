<html>
<head>
  <title>Comments of &quot;Woodenman&quot; HOL Requirements for the DoD.</title>
  <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
  <link href="assets/transcriptions.css" rel="stylesheet">
  <meta name="generator" content="convertArticle.pl">
</head>
<body>
<h1>Comments of &quot;Woodenman&quot; HOL Requirements for the DoD.</h1>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=ISO-8859-1">
		<meta name="generator" content="Adobe GoLive 6">
		<title>E.W.Dijkstra Archive: Comments of &quot;Woodenman&quot; HOL Requirements for the DoD. (EWD 526)</title>
	</head>

	<body bgcolor="#ffffff">
		<table width="499" border="0" cellspacing="0" cellpadding="0" cool gridx="16" gridy="16" height="4402" showgridx showgridy usegridx usegridy>
			<tr height="4401">
				<td content csheight="4401" width="477" height="4401" valign="top" xpos="0">
					<div align="right">
						<a href="https://www.cs.utexas.edu/~EWD/ewd05xx/EWD526.PDF" target="_blank">EWD526</a></div>
					<div align="left">
						<p><u>
						 
						Comments of &quot;Woodenman&quot; HOL Requirements for the DoD.</u></p>
						<p>(This is a sequel to EWD514 &quot;On a language proposal for the Department of Defense&quot;, written after reading &quot;Strawman&quot;. Many of those comments on that earlier document are still applicable to its successor &quot;Woodenman&quot;. I here confine myself to some further comments.)</p>
						<p><u>
						 
						1. Repercussions on future hardware design have not been taken into account.</u></p>
						<p>
						If the DoD accepts as a standard a common HOL, its sheer buying power 
						will ensure that efficient implementability of the HOL will become an 
						important design criterion for computer manufacturers.  This will then 
						happen, if the DoD so desires or not.  This implies that the DoD 
						cannot restrict its responsibility to just serving its own software 
						needs as it now sees them: the choice will have much wider 
						consequences of (almost certainly) long duration, affecting the whole 
						market place.  These responsibilities have not been taken into 
						account, and this is a serious omission.</p>
						<p>The old view of programming was that it was the purpose of our programs to instruct our machines. With the software problems --and as a result: the software costs-- skyrocketing, a new view of that relation has emerged, viz. that it is the purpose of our machines to execute our programs! The latter, more modern and more appropriate view is hardly reflected in Woodenman, in which existing hardware --with the report's insistence on efficient implementation by existing techniques-- is too much taken for granted. Unless the HOL is designed for an ideal machine --or better: machines as we would like them to be--, the whole effort may in the long run cause great harm.</p>
						<p><u>
						 
						2.  Simplicity and ease to learn the new language.</u></p>
						<p>
						The report contains a discussion of simplicity versus complexity that 
						itself is so simplified as to be misleading.  I mention in connection 
						the requirement that the new language should be &quot;easy to learn&quot;.</p>
						<p>
						It is perfectly clear that any unnecessary training burden should be 
						avoided: programmers should not learn to fight problems that should 
						not be there in the first place.  And the report is fully justified 
						when it points out the tremendous costs induced by grotesquely baroque 
						programming languages.  Hence the cry for a simple programming 
						language, which, in my view, is fully justified.</p>
						<p>
						To conclude that, therefore, the language must be &quot;easy to learn&quot;, 
						however, is a rash conclusion, for cruelly stated, that &quot;easiness&quot; 
						suggests the desire to continue to design software with hardly 
						educated programmers!  And then our problems will remain with us, no 
						matter which HOL is adopted.</p>
						<p>The training of programmers cannot be &quot;easy&quot;, for programming is and will remain difficult. The point is that &quot;learning the language&quot; should, indeed&quot; be a minimal affair, and the major attention should be given to mastering an orderly <u>discipline</u> how to use it.</p>
						<p>As long as we discuss the whole problem in terms of simplicity versus complexity, we may end up with the conclusion that machine code --or perhaps even a Turing machine!-- is the most &quot;simple&quot; code. The major point is that machine codes, the Turing machine and the most baroque higher programming languages, suffer from the <u>same</u> shortcoming, viz. the absence of such an orderly discipline for their use.</p>
						<p>
						When designing a programming language the existence of a sound, 
						orderly discipline for its use --a discipline that, by necessity shall 
						be one of a rather mathematical nature-- should be one of one's major 
						concerns.  I stress this for immensely practical reasons.  The 
						existence of such a discipline is a prerequisite for the design of 
						high-quality programs; it is also a very effective criterion for the 
						decision what to include and what to exclude from one's language 
						design!  When considering a &quot;feature&quot;, [if] one cannot find a way of 
						avoiding the puzzles and the conflicts, omit it...  The resulting 
						language will be &quot;small&quot; and &quot;simple&quot; as a consequence: there are not 
						so many &quot;features&quot; with the necessary (mathematical) properties.</p>
						<p>
						Besides the existing population of machines, also the existing 
						population of programmers is taken too much for granted.  When I read 
						--page 37-- &quot;Most programmers are not used to origin 0 and find it 
						inconvenient or unnatural.&quot;, I conclude that &quot;inconvenient&quot; has 
						--again!-- be confused with &quot;unconventional&quot;, and that the report is 
						too much oriented towards the past and the present and too little 
						towards the future.</p>
						<p><u>
						 
						3. Are so many &quot;specialized capabilities needed&quot;?</u></p>
						<p>On a number of places --e.g. pages 11 and 31-- the report accepts the not uncommon assumption that, because applications are varied and the language must be geared to the application, a great number of specialized features or capabilities are needed. <u>Is this true to the extent that the report suggests?</u> I seriously challenge this opinion because</p>
						<ol>
							<li type="a">I do not believe it myself<br>
								&nbsp;
							
							<li type="a">the report does not motivate it and takes it just for granted<br>
								&nbsp;
							
							<li type="a">historical evidence is inconclusive, as the observable variation can also be interpreted as the obvious result of the absence of the discipline referred to above.
						</ol>
						<p>
						It will not surprise the reader that I consider the discussion on 
						pages 11 - 12 &quot;Generality versus Specificity&quot; as rather inconclusive; 
						page 31 even strikes me as misleading.  When I read there:</p>
						<blockquote>
							<p>
						  &quot;A common language must have capability for growth.  It should 
						  contain all the power necessary to satisfy all the applications and 
						  the ability to specialize that power to the particular application 
						  task.  A language with defining facilities for data and operations 
						  will make it possible to add new application-oriented structures and 
						  to use new programming techniques and mechanisms using descriptions 
						  written entirely within the language.&quot;</p>
						</blockquote>
						<p>
						I feel like reading a misleading advertisement that would be rejected 
						by the professional code of our advertisers.</p>
					</div>
					<div align="center">
						<p>*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>
							*</p>
					</div>
					<div align="left">
						<p>
						A few further, minor points.  *)</p>
						<p>[<u>Footnote</u>] *) In retrospect not so minor at all! EWD [End of footnote]</p>
						<p><u>
						 
						4. Equivalence for real numbers.</u></p>
						<p>
						On page 38 I read:</p>
						<blockquote>
							<p>
						  &quot;The use of equivalence is not recommended for real numbers but 
						  resolution of what equivalence means for imprecise quantities is a 
						  problem of numerical analysis not language design.&quot;</p>
						</blockquote>
						<p>
						This is not true, the problem should not be left to the numerical 
						analysts, because language design requires --and dictates-- a very 
						precise answer to that question.  The point has been settled fifteen 
						years ago.</p>
						<p>When I implemented ALGOL 60, I thought that --because exact equality of floating point numbers seemed too much to ask for-- I would provide a service by delivering the value <u>true</u> for the boolean expression <i>a</i> = <i>b</i>, when <i>a</i> and <i>b</i> were floating point values only differing in the least significant bit of the mantissa. This was one of the gravest mistakes I ever made, because it proved to be an absolute disaster, and I had to remedy the situation very quickly. The point is that such a loose equality is too weak a criterion to be of any use; for instance, the loose equality is no longer transitive. One could find <i>a</i> = <i>b</i>, <i>b</i> = <i>c</i> and <i>a</i> &#x2260; <i>c</i> all being true at the same time! Under those shaky circumstances it is very hard, if not impossible, to prove the correctness of a program manipulating real variables. If at that time, proving programming correctness had been the normal practice, I would never have made the blunder in the first place.</p>
						<p>
						I mention this point for two reasons: firstly it settles a point that 
						the report has erroneously left open, secondly it illustrates my 
						point, made above, that the requirement of an orderly discipline 
						indeed settles design questions.</p>
						<p><u>
						 
						5. The range.</u></p>
						<p>
						I read on page 43:</p>
						<blockquote>
							<p>
						  &quot;The source language should require its users to individually 
						  specify the range of values for integer and floating point variables 
						  [...]  Range [...] specifications should not be interpreted as 
						  defining new types.&quot;</p>
						</blockquote>
						<p>
						The latter addition seems in contradiction with page 35 &quot;By the type 
						of a data object is meant the set of objects themselves, the essential 
						properties of those objects and the set of operations which give 
						access to and take advantage of those properties.</p>
						<p>There seems to be a confusion, it is not clear what the implications are when the integer variable <i>x</i> has the range declared to be from 0 through 15. There are at least two possibilities:</p>
						<ol>
							<li type="a">any implementation has to check that the values of the intermediate variable <i>x</i> always lies within that range from 0 through 15.<br>
								&nbsp;
							
							<li type="a">no implementation needs to allocate more than 4 bits to the variable <i>x</i>; any implementation has the right, but never the obligation, to signal an alarm when <i>x</i> is found to lie outside the range from 0 through 15, it has only the duty to signal an alarm when it has used the assumption that <i>x</i> would have such a value (by, for instance, only allocating 4 bits to it).
						</ol>
						<p>In interpretation (b) any implementation, therefore, may ignore the range specification, and may take it into account if it can do so at good advantage. In interpretation (a), each implementation <u>has</u> to take it into account; as this implies in general a run-time check, interpretation (a) is in conflict with some of the efficiency requirements. Interpretation (a) has the further dramatic disadvantage that &quot;static type checking&quot; is no longer possible. I call this &quot;dramatic&quot;, because it introduces an intertwining of the semantics of the programming language --describing the net effect to be effectuated by the programs written in it-- and their implementations --i.e. possible computational histories that could achieve that effect--.</p>
						<p>I have learned to appreciate axiomatic, non-operational definitions of programming language semantics, in which the program text defines the net effect to be established independent of the computational histories that may be invoked under control of the programs. In such an approach the program does not prescribe what has to happen during the execution, it only prescribes the answers; what happens during the execution of a program is only defined by the combination of program and implementation. But the implementation is not defined by the definition of the programming language, only constrained by the requirement that always the correct answer will be produced. I have found such a separation of concerns between what should be achieved and how it is to be achieved, absolutely essential. Interpretation (a) which refers to the computational history, would deny me that separation of concerns; it is for <u>that</u> reason --and not on account of the cost of run-time checks-- that I regard adoption of interpretation (a) as a disaster. The suggestion --page 80-- that formal definition of the semantics could be done via either the Vienna Definition Language or (a la LISP) by an interpreter --which are both operational definitions-- is one of which I cannot approve.</p>
					</div>
					<div align="center">
						<p>*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>
							*</p>
					</div>
					<div align="left">
						<p>
						To Dr. John B. Goodenough's list of typographical errors I can add:</p>
						<table width="400" border="0" cellspacing="2" cellpadding="0">
							<tr>
								<td align="center"><u>Page</u></td>
								<td align="center"><u>Line</u></td>
								<td align="center"><u>As Is</u></td>
								<td align="center"><u>Should Be</u></td>
							</tr>
							<tr>
								<td align="center">78</td>
								<td align="center">7</td>
								<td align="center">inovation</td>
								<td align="center">innovation</td>
							</tr>
						</table>
						<p></p>
						<table width="400" border="0" cellspacing="2" cellpadding="0">
							<tr>
								<td align="left" valign="top">3rd November 1975<br>
									Plataanstraat 5<br>
									NUENEN - 4565<br>
									 The Netherlands</td>
								<td align="left" valign="top">prof.dr.Edgser W.Dijkstra<br>
									Burroughs Research Fellow</td>
							</tr>
						</table>
						<p></p>
					</div>
					<div align="left">
						<p><u></u></p>
					</div>
					<hr>
					<font size="-1">transcribed by Tristram Brelstaff<br>
						revised <csobj format="MedDate" h="16" region="15" t="DateTime" w="99">Wed, 26 May 2004</csobj></font>
					<p></p>
				</td>
				<td width="21" height="4401"></td>
				<td width="1" height="4401"><spacer type="block" width="1" height="4401"></td>
			</tr>
			<tr height="1" cntrlrow>
				<td width="477" height="1"><spacer type="block" width="477" height="1"></td>
				<td width="21" height="1"><spacer type="block" width="21" height="1"></td>
				<td width="1" height="1"></td>
			</tr>
		</table>
		<p></p>
	</body>

</html>
</body>
</html>
