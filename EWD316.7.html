  <!DOCTYPE html>
  <html>
  <head>
    <title>A Short Introduction to the Art of Programming (EWD 316), Chapter 7</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <link href="assets/tweet-selection.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.12.0.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="assets/tweet-selection.js"></script>
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: A Short Introduction to the Art of Programming (EWD 316), Chapter 7" />
    <meta name="twitter:title" content="A Short Introduction to the Art of Programming (EWD 316), Chapter 7" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>A Short Introduction to the Art of Programming (EWD 316), Chapter 7</h1>
  <div class='body'>				<div id="frame">					<div id="header">						<div align="center">							<p>EWD316: A Short Introduction to the Art of Programming</p>							<p>by</p>							<p>prof.dr.Edsger W.Dijkstra</p>							<p>August 1971</p>						</div>						<div align="left">							<p class="noindent"><a name="contents"></a><u>Contents</u></p>							<div id="frame">								<div id="header">									<blockquote>										<div align="left">											<div id="frame">												<div id="content">													<blockquote>														<div align="left">															<p class="noindent">0. Contents</p>															<p class="noindent">1. <a title="Chapter 1 of EWD 316" href="EWD316.html">Preface</a><br>																<br>																2. <a title="Chapter 2 of EWD 316" href="EWD316.2.html">Some Fundamental Notions</a><br>																<br>																3. <a title="Chapter 3 of EWD 316" href="EWD316.3.html">Programming Languages and their Implementation</a><br>																<br>																4. <a title="Chapter 4 of EWD 316" href="EWD316.4.html">Variables and relations between their values</a><br>																<br>																5. <a title="Chapter 5 of EWD 316" href="EWD316.5.html">Programs corresponding to recurrence relations</a><br>																<br>																6. <a title="Chapter 6 of EWD 316" href="EWD316.6.html">A first example of step-wise program composition</a><br>																<br>																7. The shortest spanning subtree of a graph<br>																<br>																8. <a title="Chapter 8 of EWD 316" href="EWD316.8.html">The towers of Hanoi</a><br>																<br>																9. <a title="Chapter 9 of EWD 316" href="EWD316.9.html">The problem of eight queens</a><br>																<br>																10. <a title="Chapter 10 of EWD 316" href="EWD316.10.html">A rearranging routine</a></p>														</div>													</blockquote>												</div>											</div>										</div>									</blockquote>								</div>							</div>						</div>					</div>				</div>				<p class="noindent">7. <u>The shortest spanning subtree of a graph</u>.</p>				<p>I have chosen the following example for a variety of reasons. Firstly, although the final program is rather short, the solution is far from trivial. Secondly, our true subject matter is ''structure'' rather than straightforward numerical material, and as a result, the decisions taken to represent the information (using numerical values) are more manifest. Finally it presents us with a type of strategic decisions which are typical.</p>				<p>Two points can be connected by one point-to-point connection; three points can be connected with each other by two point-to-point connections; in general N points can be fully interconnected by N&#150;1 point-to-point connections. Such a set of interconnections is called a ''tree''; the point-to-point connections that constitute the tree are called ''its branches''. Cayley has been the first to prove that the number of possible trees between N points equals <span class="MATH">N<sup>N&#150;2</sup></span>.</p>				<p>We now assume that for each possible branch the length has been given. Defining the length of a tree as the sum of the lengths of its branches, we can ask for the shortest tree between those N points. (For the time being we assume that the given lengths are such that the shortest tree is unique. From our analysis it will follow that no two branches of equal length is a sufficient condition for this assumption.)</p>				<p class="noindent"><span id="txt1342"><u>Note</u>.</span> The points don't need to lie in a Euclidean plane, nor do the given distances need to satisfy the triangle inequality.</p>				<p>An apparently straightforward solution would generate all trees between the N points, compute their lengths and select the shortest one, but Cayley's theorem shows that this would become very expensive as N increases. The following theorem enables us to find the shortest tree with considerably less work. Given a subtree of the shortest tree, then the shortest branch that can be found between one of the points touched by this subtree and one of the points not touched by this subtree will be part of the shortest tree between all N points.</p>				<p>This theorem is easily proved. Colour the branches of the subtree and all points connected to it red; colour all the remaining points blue and colour all branches leading from a red point to a blue one violet. The theorem asserts the shortest violet branch is part of the shortest tree as well. Call this shortest violet branch V and assume that it is not part of the shortest tree T; we shall then construct a tree T' which is shorter than T, thus arriving at a contradiction. Add to the tree T the violet branch V; in the resulting graph the violet branch must be contained in a closed loop. As this violet branch connects a red point with a blue one, it is clear that, going around the loop, we must find at least one other violet branch in this loop. Call this V' and remove V'. The resulting graph has again N&#150;1 branches; it connects all N points (we have removed a branch from a loop) and therefore it is a tree connecting all N points. Call it T'. From T' = T + V &#150; V' follows: length(T') = length(T) + length(V) - length(V') As V was the shortest violet branch, we have length (V) &lt; length (V'), so that length (T') &lt; length (T) i.e. the tree T cannot have been the shortest one.</p>				<p>The above theorem tells us that a red subtree of the shortest tree T can be extended with a point and the branch leading to it: the shortest violet branch and the blue point it leads to can be coloured red. As a result, if we can find a red subtree to start with, we can let it grow by one branch at a time. But it is very easy to start with a red subtree, viz. the red subtree consisting of a single point (any point will do) and no branches. Starting from the subtree we can let it grow to the shortest tree in N&#150;1 steps, each step adding a new red branch and a new red point to it. We can represent the framework of this algorithm as follows:</p>				<blockquote>					<p>COLOUR ONE POINT RED AND THE REMAINING ONES BLUE;<br>						<span id="txt1351"><u>while</u></span> NUMBER OF RED POINTS &lt; N <span id="txt1352"><u>do</u></span><br>						<span id="txt1353"><u>begin</u></span><br>						&nbsp;&nbsp;SELECT SHORTEST VIOLET BRANCH;<br>						&nbsp;&nbsp;COLOUR IT AND ITS BLUE ENDPOINT RED<br>						<span id="txt1354"><u>end</u></span>. </p>				</blockquote>				<p>As it stands, the main task will be ''SELECT SHORTEST VIOLET BRANCH'', because the number of violet branches may be quite large, viz. k * (N &#150; k) where k = NUMBER OF RED POINTS. If ''SELECT SHORTEST VIOLET BRANCH'' were an isolated operation, there is not much that could be done about it; in the above program, however, the operation has to be performed N&#150;1 times in succession and the successive sets of violet branches are strongly related: they are the branches between red and blue points and each time only one point changes its colour. We would like to exploit this with the aim of reducing the set of branches from which each time the shortest branch should be selected: we are looking for a useful subset of the violet branches. We still don't know if such a really useful subset exists, but let us assume for the moment that it can be found and let us call it ''ultraviolet''. If such a set exists (each time) it is only helpful provided that we have a cheap way of constructing this subset, and our only hope is to be found in the past history of the computation, for instance the set of ultraviolet branches used the previous time. This suggests a program of the following structure:</p>				<blockquote>					<p class="noindent">COLOUR ONE POINT RED AND THE REMAINING ONES BLUE;<br>						CONSTRUCT THE SET OF ULTRAVIOLET BRANCHES;<br>						<span id="txt1359"><u>while</u></span> NUMBER OF RED POINTS &lt; N <span id="txt1360"><u>do</u></span><br>						<span id="txt1361"><u>begin</u></span><br>						&nbsp;&nbsp;SELECT SHORTEST ULTRAVIOLET BRANCH;<br>						&nbsp;&nbsp;COLOUR IT AND ITS BLUE ENDPOINT RED;<br>						&nbsp;&nbsp;ADJUST THE SET OF ULTRAVIOLET BRANCHES<br>						<span id="txt1362"><u>end</u></span>. </p>				</blockquote>				<p class="noindent">where the set of ultraviolet branches should be defined in such a way that</p>				<ol>					<li>it is guaranteed to contain the shortest violet branch					<li>the set of ultraviolet branches is in general much smaller than the set called simply violet					<li>the operation ''ADJUST THE SET OF ULTRAVIOLET BRANCHES'' is cheap, for otherwise the profit we are trying to gain is lost.				</ol>				<p>Can we find such a definition of the concept ''ultraviolet''? Well, for lack of further knowledge I can only suggest that we try.</p>				<p>Considering that the set of violet branches leading from the k red points to the N&#150;k blue ones has K * (N &#150; k) members and observing criterion 1, two obvious possible subsets present themselves immediately:</p>				<ol>					<li>Make for each red point the shortest violet branch ending in it ultraviolet. In this case the set of ultraviolet branches has k members.					<li>Make for each blue point the shortest violet branch ending in it ultraviolet. In this case the set of ultraviolet branches has N&#150;k members.				</ol>				<p>Our aim is to keep the ultraviolet subset small, but we won't get a clue from their size: with the first choice the sizes will run from 1 through N&#150;1, with the second choice it will be the other way round. So, if there is any chance of deciding we must find it in the price of the operator ''ADJUST THE SET OF ULTRAVIOLET BRANCHES''.</p>				<p>Without trying the various adjustments of the ultraviolet sets, there is one observation which suggests a preference for the second choice. In the first choice k ultraviolet branches may lead from the red tree to the same blue point; then we know a priori that at most one of them will be coloured red, while with the second choice each blue point is connected in one way only to the red tree (the sum of the number of red and ultraviolet branches is then constantly equal to N&#150;1) and it is possible that all ultraviolet branches at a certain moment will be eventually coloured red &#151;in which case the adjustment operator was empty but for the removal of the one made red. Therefore, let us try the second choice for the criterion ultraviolet. (Initially this set comprises the N&#150;1 branches leading from the one red point to the remaining N&#150;1 blue ones, so that presents no problem.)</p>				<p>Consider now that we have a red subtree R and that from the corresponding set of ultraviolet branches (according to the second choice &#151;I shall no longer repeat that qualification) the shortest branch leading to the blue point P and the blue point P itself have been coloured red. The number of ultraviolet branches has been decreased by 1 as it should be. Are the remaining ones the good ones? For each blue point they represent the shortest connection to the red tree R, and they should represent the shortest possible connection to the new red tree R + P. But this is settled by means of a simple comparison for each blue point B: if the branch BP is shorter than the ultraviolet branch connecting B to R, the latter is to be replaced by the branch BP &#151;its colour is washed away and BP is made ultraviolet instead&#151;; otherwise it is maintained, as the growth of the red tree with the point P did not provide a shorter way of connecting B with the red tree. As a result the cost of the adjustment operator &#151;which has to deal with N&#150;k blue points&#151; is a linear function of N and k (and not quadratic as k * (N &#150; k)), and the introduction of this concept of ultraviolet is indeed accomplishing the savings we were hoping for.</p>				<p class="noindent"><span id="txt1370"><u>Exercise</u></span>. Convince yourself that the rejected alternative of the concept ''ultraviolet'' is not so helpful.</p>				<p>Let us try to represent our algorithm in its current stage of refinement:</p>				<blockquote>					<p class="noindent">COLOUR ONE POINT RED AND THE REMAINING ONES BLUE;<br>						CONSTRUCT THE SET OF ULTRAVIOLET BRANCHES;<br>						<span id="txt1373"><u>while</u></span> NUMBER OF RED POINTS &lt; N <span id="txt1375"><u>do</u></span><br>						<span id="txt1376"><u>begin</u></span> SELECT SHORTEST ULTRAVIOLET BRANCH AND CALL ITS BLUE ENDPOINT P;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COLOUR IT AND POINT P RED;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ADJUST FOR EACH BLUE POINT B BY COMPARING WITH THE BRANCH BP<br>						<span id="txt1377"><u>end</u></span>.</p>				</blockquote>				<p>By now the time has come to consider the representation of the information involved. We assume the N points numbered from 1 to N, we assume the length of the branches given by a two-dimensional array</p>				<blockquote>					<p class="noindent"><u>real</u> <u>array</u> distance[1:N, 1:N] , </p>				</blockquote>				<p class="noindent">such that for 1 &#x2264; i, j &#x2264; N</p>				<blockquote>					<p class="noindent">distance[i, j] = distance[j, i] =<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length of branch connecting the points i and j.</p>				</blockquote>				<p>The answer required is for a tree of N&#150;1 branches, each branch being identified by the numbers of its endpoints; the answer is an (unordered) set of (unordered) pairs of numbers. We can represent then by two arrays:</p>				<blockquote>					<p class="noindent"><u>integer</u> <u>array</u> from, to[1:N&#150;1]</p>				</blockquote>				<p class="noindent">where for each h satisfying 1 &#x2264; h &#x2264; N&#150;1 the pair ''from [h], to [h]'' gives (the numbers of) the endpoints of the h-th branch. In our final solution the branches will be numbered (by h); the only order that makes sense is the order in which they have been coloured red. The observation made earlier that the total number of branches to be manipulated (red and ultraviolet together) remains constant suggests that we store them in the same array:</p>				<p class="noindent">if k = NUMBER OF RED POINTS<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from[h], to[h] will be red for 1 &#x2264; h &lt; k<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from[h], to[h] will be ultraviolet for k &#x2264; h &lt; N .</p>				<p class="noindent">The ultraviolet branches will be represented leading from a red point to a blue one. The array ''length'' has been introduced in order to reduce the number of subscriptions to be carried out:</p>				length[h] = distance [from[h], to[h]] will hold (and will be restored immediately when temporarily invalid).				<p>Point N is chosen as the initial point to be coloured red. ''SELECT SHORTEST ULTRAVIOLET BRANCH'' is a straightforward search for a minimum value. ''COLOUR IT AND POINT P RED'' is done by an interchange on the three arrays (if necessary), followed by an increase of k. In ''ADJUST FOR EACH BLUE POINT B BY COMPARING WITH THE BRANCH BP'', h scans the violet branches, to[h] will scan the blue points and len is used to store the length of branch BP. The final program is given on the next page.</p>				<p class="noindent"><span id="txt1421"><u>Exercise</u></span>.</p>				<p>Let distance [i,j] be the distance from point i to point j <span id="txt1424"><u>in</u> <u>that</u> <u>direction</u></span>. As we may have one-way traffic, the relation distance[i,j] &#x2260; distance[j,i] is then permissable. Make a program finding in the graph the shortest path leading from point I to point J. This is a difficult exercise, therefore it is worth trying!</p>				<p class="noindent"><u>begin</u><br>					<span id="txt1433">&nbsp;&nbsp;<u>integer</u> <u>array</u></span> from, to [1:N&#150;1];<br>					<span id="txt1437">&nbsp;&nbsp;<u>real</u> <u>array</u></span> length [1:N&#150;1];<br>					&nbsp;&nbsp;<span id="txt1440"><u>real</u></span> len, minlen;<br>					&nbsp;&nbsp;<span id="txt1441"><u>integer</u></span> k, h, minh, p;<br>					<br>					&nbsp;&nbsp;COLOUR ONE POINT RED AND THE REMAINING ONES BLUE:<br>					&nbsp;&nbsp;&nbsp;&nbsp;k := 1; &nbsp;&nbsp;CONSTRUCT THE SET OF ULTRAVIOLET BRANCHES:<br>					&nbsp;&nbsp;&nbsp;&nbsp;h := 1;<br>					&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1442"><u>while</u></span> h &lt; N <span id="txt1443"><u>do</u></span><br>					&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1444"><u>begin</u></span><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from[h] := N; to [h] := h; length[h] := distance[N,h]; h := h+1;<br>					&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1453"><u>end</u>;</span><br>					&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1454"><u>while</u></span> k &lt; N <span id="txt1455"><u>do</u></span><br>					&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1456">begin</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SELECT SELECT SHORTEST ULTRAVIOLET BRANCH<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AND CALL ITS BLUE ENDPOINT P:<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minh := k; minlen := length[k]; h := k+1;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1459"><u>while</u></span> h &lt; N <span id="txt1460"><u>do</u></span><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1461"><u>begin</u></span><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len := length[h];<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1464"><u>if</u></span> len &lt; minlen <span id="txt1465"><u>do</u></span><br>					<span id="txt1466">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u></span><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minlen := len;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;minh := h;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1467"><u>end</u></span><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h := h + 1;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1468"><u>end</u></span>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p := to[minh]; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;COLOR IT AND POINT P RED:<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u><span id="txt1471">if</span></u><span id="txt1471"> k &#x2260; minh <span id="txt1472"><u>do</u></span><br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1473"><u>begin</u></span><br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h := from[k];<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from[k] := from[minh];<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from[minh] := h;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h := to[k];<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to[k] := to[minh];<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;to[minh] := h;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len := length[k];<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length[k] := length[minh];<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length[minh] := len;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1498"><u>end</u></span>;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k := k + 1; </span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ADJUST FOR EACH BLUE POINT BY COMPARING WITH THE BRANCH BP:<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h := k;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1499"><u>while</u></span> h &lt; N <span id="txt1500"><u>do</u></span><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1501"><u>begin</u></span><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len := distance[p, to[h]];<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1506"><u>if</u></span> len &lt; length[h] <span id="txt1509"><u>do</u></span><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1510"><u>begin</u></span><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length[h] := len;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;from[h] := p;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1515"><u>end</u></span>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;h := h + 1;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1516"><u>end</u></span>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;<span id="txt1517"><u>end</u></span>;<br>					&nbsp;&nbsp;h := 1;<br>					&nbsp;&nbsp;<span id="txt1518"><u>while</u></span> h &lt; N <span id="txt1519"><u>do</u></span><br>					&nbsp;&nbsp;<span id="txt1520"><u>begin</u></span><br>					&nbsp;&nbsp;&nbsp;&nbsp;print(from[h]);<br>					&nbsp;&nbsp;&nbsp;&nbsp;print(to[h]);<br>					&nbsp;&nbsp;&nbsp;&nbsp;newline;<br>					&nbsp;&nbsp;&nbsp;&nbsp;h := h + 1;<br>					&nbsp;&nbsp;<span id="txt1525"><u>end</u></span>;<br>					<span id="txt1527"><u>end</u></span>;</p>				<p class="noindent"><a href="#contents">Back to top</a></p>				<p class="noindent">Next chapter:  8. <a title="Chapter 8 of EWD 316" href="EWD316.8.html">The towers of Hanoi</a></p>				<p class="noindent"></p>			</div>			<hr />			<!-- name and date -->      <div id="footer">transcribed by Bert Put<br />revised <csobj format="MedDate" h="15" region="15" t="DateTime" w="95">Sat, 2 Aug 2008</csobj></div>    </div>  </body></html></x-html></div>
  <script>
$('.body').tweetSelection({
  ellipsis: '...',
  quoteLeft: '\'',
  quoteRight: '\'',
  via: 'raboofje'
});
  </script>
  </body>
  </html>
