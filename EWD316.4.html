<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head><link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1" />    <title>E.W.Dijkstra Archive: A Short Introduction to the Art of Programming (EWD 316), Chapter 4</title>		<link href="assets/transcriptions.css" rel="stylesheet" media="screen">	</head>  <body><div id="title"><h1>A Short Introduction to the Art of Programming (EWD 316), Chapter 4</h1></div>    <div id="frame">			<div id="header">				<a title="link to PDF version of EWD316" href="https://www.cs.utexas.edu/~EWD/ewd03xx/EWD316.PDF">EWD316</a></div>			<div id="content">				<div id="frame">					<div id="header">						<div align="center">							<p>EWD316: A Short Introduction to the Art of Programming</p>							<p>by</p>							<p>prof.dr.Edsger W.Dijkstra</p>							<p>August 1971</p>						</div>						<div align="left">							<p class="noindent"><a name="contents"></a><u>Contents</u></p>						</div>						<blockquote>							<div align="left">								<div id="frame">									<div id="header">										<blockquote>											<div align="left">												<div id="frame">													<div id="content">														<div align="left">															<p class="noindent">0. Contents</p>															<p class="noindent">1. <a title="Chapter 1 of EWD 316" href="EWD316.html">Preface</a><br>																<br>																2. <a title="Chapter 2 of EWD 316" href="EWD316.2.html">Some Fundamental Notions</a><br>																<br>																3. <a title="Chapter 3 of EWD 316" href="EWD316.3.html">Programming Languages and their Implementation</a><br>																<br>																4. Variables and relations between their values<br>																<br>																5. <a title="Chapter 5 of EWD 316" href="EWD316.5.html">Programs corresponding to recurrence relations</a><br>																<br>																6. <a title="Chapter 6 of EWD 316" href="EWD316.6.html">A first example of step-wise program composition</a><br>																<br>																7. <a title="Chapter 7 of EWD 316" href="EWD316.7.html">The shortest spanning subtree of a graph</a><br>																<br>																8. <a title="Chapter 8 of EWD 316" href="EWD316.8.html">The towers of Hanoi</a><br>																<br>																9. <a title="Chapter 9 of EWD 316" href="EWD316.9.html">The problem of eight queens</a><br>																<br>																10. <a title="Chapter 10 of EWD 316" href="EWD316.10.html">A rearranging routine</a></p>														</div>													</div>												</div>											</div>										</blockquote>									</div>								</div>							</div>						</blockquote>					</div>				</div>				<p class="noindent"><u>4. Variables and relations between their values</u></p>				<p>When introducing the basic notions we have said that <em>different</em> happenings could take place following the <em>same</em> pattern of behaviour. And as the happening is fully determined by the confrontation of the pattern of behaviour with the initial state, it follows that the same pattern of behaviour can only evoke different happenings on different occasions when at these different occasions the initial states differ from each other. In this section we shall show how so-called <em>variables</em> are used for the description of the initial (and final) states. We find the typical use of variables when the same pattern of behaviour is followed repeatedly, i.e. when sequencing is repetitively controlled.</p>				<p>We begin with a very simple program: given two positive integer values <var>A</var> and <var>B</var>, a program has to be made that will compute (i.e. can cause a computer to compute) the Greatest Common Divisor of <var>A</var> and <var>B</var>. Let us use the notation GCD(<var>A</var>, <var>B</var>) for that value.</p>				<p>(<u>Remark</u>. We have restricted ourselves to positive numbers in order to make life somewhat easier. Zero is divisible by any positive integer <var>D</var> (for 0 = <var>D</var> * 0), and there would be no objection with <var>B</var> &gt; 0, to</p>				<blockquote>					<p class="noindent">GCD(0, <var>B</var>) = <var>B&nbsp;&nbsp;&nbsp;&nbsp;.</var></p>				</blockquote>				<p class="noindent">But admitting zero as argument is asking for trouble, because GCD(0, 0) is clearly undefined! In order to avoid these complications, we restrict ourselves to positive arguments.)</p>				<p>For the sake of argument we request an algorithm in which no arithmetic operators other than addition and subtraction will be used. How do we find such an algorithm?</p>				<p>Well, there seem in this case to be two ways of attacking the problem. The first one is more or less a direct application of the definition. One could construct a table of divisors of <var>A</var> (including&nbsp;1) and a table of divisors of <var>B</var> (also including&nbsp;1); as both <var>A</var> and <var>B</var> are finite and different from zero, both tables contain only a finite number of numbers. From these two tables of divisors one can construct a third table of common divisors, i.e. containing all the numbers in both of them. This third table is non-empty (because it contains the number 1) and it is finite (because it cannot be longer than any of the original tables). From this non-empty, finite table we can select the greatest number and that will, by virtue of the way in which it has been found, be the Greatest Common Divisor.</p>				<p>We could do it along the lines just sketched (or at least use it as a source of inspiration). In the current example, however, there is a second line of attack because the GCD is a well-known mathematical function, &quot;well-known&quot; meaning that a number of its <em>properties</em> are known. If we can think of so many of its properties that they <em>define</em> the GCD &#x2014;i.e. that the GCD is the only function satisfying them&#x2014; we might try to determine GCD(<var>A</var>, <var>B</var>) by exploiting these properties. What properties can we think of?</p>				<p class="noindent">1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GCD(<var>a</var>, <var>b</var>) = GCD(<var>b</var>, <var>a</var>)<br>					2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GCD(<var>a</var>, <var>b</var>) = GCD(<var>a</var> + b, <var>b</var>) = GCD(<var>a</var>, <var>a</var> + <var>b</var>)<br>					3.1)&nbsp; if <var>a</var> &gt; <var>b</var>:&nbsp;&nbsp;&nbsp;&nbsp;GCD(<var>a</var>, <var>b</var>) = GCD(<var>a</var> - <var>b</var>, <var>b</var>) = GCD(<var>a</var>, <var>a</var> - <var>b</var>)<br>					3.2)&nbsp;&nbsp;if <var>a</var> = <var>b</var>:&nbsp;&nbsp;&nbsp;&nbsp;GCD(<var>a</var>, <var>b</var>) = <var>a</var> = <var>b</var><br>					3.3)&nbsp;&nbsp;if <var>a</var> &lt; <var>b</var>:&nbsp;&nbsp;&nbsp;&nbsp;GCD(<var>a</var>, <var>b</var>) = GCD(<var>a</var>, <var>b</var> - <var>a</var>) = GCD(<var>b</var> - <var>a</var>, <var>b</var>)</p>				<p class="noindent">(We can think of other properties, such as</p>				<p class="noindent">4)&nbsp;&nbsp;&nbsp;&nbsp; for <var>n</var> &#x2265; 0:&nbsp;&nbsp;&nbsp;&nbsp;GCD(<var>a<sup>n</sup></var>, <var>b<sup>n</sup></var>) = GCD(<var>a</var>, <var>b</var>)<var><sup>n</sup></var><br>					5)&nbsp;&nbsp;&nbsp;&nbsp; for <var>c</var> &gt; 0:&nbsp;&nbsp;&nbsp;&nbsp;GCD(<var>c</var> * <var>a</var>, <var>c</var> * <var>b</var>) = <var>c</var> * GCD(<var>a</var>, <var>b</var>)&nbsp;&nbsp;&nbsp;&nbsp;,</p>				<p class="noindent">but they look less promising as they involve multiplication and we have to restrict ourselves to the arithmetic operations of addition and subtraction.)</p>				<p>The first property states that the GCD is a symmetric function. The second one states that the GCD of two numbers is equal to the GCD of one of them and the sum, while the third property states this for the difference. Because we want to restrict ourselves to positive numbers, we have dealt with the cases <var>a</var> &lt; <var>b</var> and <var>a</var> &gt; <var>b</var> separately. The case <var>a</var> = <var>b</var>, however, is very special: it is the only case in which the value of the GCD is given directly.</p>				<p>Relations 2, 3.1 and 3.3 tell us that the GCD of a pair of numbers is equal to the GCD of another pair of numbers. This suggests that we use the &quot;current state&quot; to fix such a number pair; the algorithm can then try to change these numbers in such a way that</p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="20%">firstly:&nbsp;</td>						<td>the GCD remains constant</td>					</tr>					<tr>						<td valign="top" width="20%">secondly:</td>						<td>until eventually the two numbers are equal and rule 3.2 can be applied.</td>					</tr>				</table>				<p>With the second requirement in mind, rule 2 does not look too promising: given two positive numbers, one of them never can be equal to their sum. On the other hand, given two (different!) positive numbers, one of them, viz. the smallest, can be equal to their difference. This suggest that from 3.1 and 3.3 we use:</p>				<p class="noindent">3.1'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if <var>a</var> &gt; <var>b</var>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GCD(<var>a</var>, <var>b</var>) = GCD(<var>a</var> - <var>b</var>, <var>b</var>)</p>				<p class="noindent">3.3'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if <var>a</var> &lt; <var>b</var>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GCD(<var>a</var>, <var>b</var>) = GCD(<var>a</var>, <var>b</var> - <var>a</var>)&nbsp;&nbsp;&nbsp;&nbsp;.</p>				<p>Now the moment has come to consider the first version of the program:</p>				<p class="noindent">program1:<br>					<u>begin</u> <u>integer</u> <var>a</var>, <var>b</var>, <var>gcd</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>a</var>:= <var>A</var>; <var>b</var>:= <var>B</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>a</var> &#x2260; <var>b</var> <u>do</u><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> <var>a</var> &gt; <var>b</var> <u>then</u> <var>a</var>:= <var>a</var> &#150; <var>b</var><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>else</u> <var>b</var>:= <var>b</var> &#150; <var>a</var><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>gcd</var>:= <var>a</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<var>A</var>); print(<var>B</var>); print(<var>gcd</var>)<br>					<u>end</u></p>				<p>(In this program we have used the well-known alternative connective &quot;<u>if</u> &#133; <u>then</u> &#133; <u>else</u>&quot;. The construction</p>				<blockquote>					<p class="noindent">&quot;<u>if</u> <var>inspection</var> <u>then</u> <var>action1</var> <u>else</u> <var>action2</var>&quot;</p>				</blockquote>				<p class="noindent">causes one of two actions, either <var>action1</var> or<var> action2</var> to take place. If the inspection delivers the value true,<var> action1</var> will take place (and <var>action2</var> will be skipped); if the inspection delivers the value false, (<var>action1</var> will be skipped and)<var> action2</var> will take place. We can describe the conditional connective in terms of it:</p>				<blockquote>					<p class="noindent">&quot;<u>if</u> <var>inspection</var> <u>do</u> <var>action</var>&quot;</p>				</blockquote>				<p class="noindent">is equivalent to</p>				<blockquote>					<p class="noindent">&quot;<u>if</u> <var>inspection</var> <u>then</u> <var>action</var> <u>else</u> <var>nothing</var>&quot; )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.</p>				</blockquote>				<p class="noindent">When we try to understand this program we should bear the following in mind:</p>				<blockquote>					<p class="noindent">While the typical use of <em>variables</em> manifests itself with the program loop, the way to understand such a program implies looking for the relations between their values which remain invariant during the repetition.</p>				</blockquote>				<p>In this example the invariant relation <var>P</var> is</p>				<p class="noindent"><var>P </var>:&nbsp;&nbsp;&nbsp;<var>a</var> &gt; 0 <u>and</u> <var>b</var> &gt; 0 <u>and</u> GCD(<var>a</var>, <var>b</var>) = GCD(<var>A</var>, <var>B </var>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.</p>				<p>The relation P holds after initialization (for then <var>a</var> = <var>A</var> and <var>b</var> = <var>B </var>; from <var>A</var>&nbsp;&gt;&nbsp;<var>0</var> and <var>B</var>&nbsp;&gt;&nbsp;0, relation <var>P</var> then follows).</p>				<p>The repeatable statement will only be executed under the additional condition <var>a</var>&nbsp;&#x2260;&nbsp;<var>b</var>; i.e. either <var>a</var> &lt; <var>b</var> or <var>a</var> &gt; <var>b</var>. If <var>a</var> &gt; <var>b</var>, then the new value of <var>a</var>, viz. <var>a</var> &#150; <var>b</var>, will again be positive and GCD(<var>a</var>,&nbsp;<var>b</var>) will remain unchanged on account of 3.1'; if <var>a</var> &lt; <var>b</var>, the new value of <var>b</var> will again be positive and GCD(<var>a</var>, <var>b</var>) will remain unchanged on account of 3.3'. The invariance of relation <var>P</var> is therefore established.</p>				<p>When the loop terminates, <var>a</var> = <var>b</var> is guaranteed to hold, GCD(<var>A</var>, <var>B</var>) = GCD(<var>a</var>, <var>b</var>) = GCD(<var>a</var>,&nbsp;<var>a</var>) and on account of 3.2 the assignment &quot;<var>gcd </var>:=&nbsp;<var>a</var>&quot; will establish the net effect &quot;<var>gcd </var>:= GCD(<var>A</var>,&nbsp;<var>B</var>)&quot;.</p>				<p>To complete the proof we must demonstrate that the repetition will indeed terminate. Whenever the repeatable statement is executed, the largest of the two (different!) values is decreased by the value of the other which is positive; as a result</p>				<blockquote>					<p class="noindent">max(<var>a</var>, <var>b</var>)<sub>T0</sub> &gt; max(<var>a</var>, <var>b</var>)<sub>T1</sub></p>				</blockquote>				<p class="noindent">We also know that before the repetition max(<var>a</var>, <var>b</var>) = max(<var>A</var>, <var>B</var>) is finite; from the invariance of the relation P (<var>a</var> &gt; 0 and <var>b</var> &gt; 0) we conclude that</p>				<blockquote>					<p class="noindent">max(<var>a</var>, <var>b</var>) &gt; 0</p>				</blockquote>				<p class="noindent">will continue to hold. All values being integer, the maximum number of times the repeatable statement can be executed must be less than the max(<var>A</var>, <var>B</var>) and therefore the repetition must terminate after a finite number of repetitions. And this completes the proof.</p>				<p>Once we have this program, it is not difficult to think of others. Reading program1 we observe that each subtraction is preceded in time by two tests, first <var>a</var> &#x2260; <var>b</var> and then <var>a</var> &gt; <var>b</var>; this seems somewhat wasteful as the truth of <var>a</var> &gt; <var>b</var> already implies the truth of of <var>a</var> &#x2260; <var>b</var>. What happens in time is that a number of times <var>a</var> will be decreased by <var>b</var>, then <var>b</var> will be decreased by <var>a</var>, and so on. A program in which (in general) the number of tests will be smaller is</p>				<p class="noindent">program 2:<br>					<u>begin</u> <u>integer</u> <var>a</var>, <var>b</var>, <var>gcd</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>a </var>:= <var>A</var>; <var>b </var>:= <var>B</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>a</var> &#x2260; <var>b</var> <u>do</u><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>while</u> <var>a</var> &gt; <var>b</var> <u>do</u> <var>a </var>:= <var>a</var> &#150; <var>b</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>b</var> &gt; <var>a</var> <u>do</u> <var>b </var>:= <var>b</var> &#150; <var>a</var><br>										&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>gcd </var>:= <var>a</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<var>A </var>), print(<var>B </var>), print(<var>gcd</var>)<br>					<u>end</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.</p>				<p class="noindent"><u>Exercise</u>. Prove the correctness of program 2.</p>				<p class="noindent"><u>Exercise</u>. Rewrite program 2 in such a way that the outer repeatable statement contains only one loop instead of two. Prove its correctness.</p>				<p>Before going on, it is desirable to give a more formal description of the kind of theorems that we use. (In the following I shall make use of a formalism introduced by C.A.R. Hoare.)</p>				<p>Let <var>P</var>, <var>P</var>1, <var>P</var>2, &#133; stand for predicates stating a relation between values of variables. Let <var>S</var>, <var>S</var>1, <var>S</var>2, &#133; stand for pieces of program text, in general affecting values of variables, i.e. changing the current state. Let <var>B</var>, <var>B</var>1, <var>B</var>2, &#133; stand for either predicates stating a relation between values of variables or for pieces of program text evaluating such a predicate, i.e. delivering one of the values true or false without further affecting values of variables, i.e. without changing the current state.</p>				<p>Then&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>P</var>1 { <var>S</var> } <var>P</var>2</p>				<p class="noindent">means: &quot;The truth of <var>P</var>1 immediately prior to the execution of <var>S</var> implies the truth of <var>P</var>2 immediately after that execution of <var>S </var>&quot;. In terms of this formalism we write down the following theorems. (Some readers would prefer to call some of them rather &quot;axioms&quot; or &quot;postulates&quot;, but at present I don't particularly care about the difference.)</p>				<p class="noindent">Theorem 1:</p>				<table width="80%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td width="30%">Given:</td>						<td><var>P</var>1 { <var>S</var>1 } <var>P</var>2</td>					</tr>					<tr>						<td width="30%"></td>						<td><var>P</var>2 { <var>S</var>2 } <var>P</var>3</td>					</tr>					<tr>						<td width="30%">Conclusion:</td>						<td><var>P</var>1 { <var>S</var>1; <var>S</var>2 } <var>P</var>3</td>					</tr>				</table>				<p class="noindent">(This theorem gives the semantic consequences of the semicolon as connective.)</p>				<p class="noindent">Theorem 2:</p>				<table width="80%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td width="30%">Given:</td>						<td><var>B</var> { <var>S</var> } <u>non</u> <var>B</var></td>					</tr>					<tr>						<td width="30%">Conclusion:</td>						<td> <u>true</u> { <u>if</u> <var>B</var> <u>do</u> <var>S</var> } <u>non</u> <var>B</var></td>					</tr>				</table>				<p class="noindent">(Here &quot;<u>true</u>&quot; is the condition which is satisfied by definition, i.e. the conclusion that after the execution of the conditional statement &quot;<u>non</u> <var>B </var>&quot; will hold, is independent of any assumptions about the initial state.)</p>				<p class="noindent">Theorem 3:</p>				<table width="80%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td width="30%">Given:</td>						<td>(<var>P</var> <u>and</u> <var>B </var>) { <var>S</var> } <var>P</var></td>					</tr>					<tr>						<td width="30%">Conclusion:</td>						<td><var>P</var> { <u>if</u> <var>B</var> <u>do</u> <var>S</var> } <var>P</var></td>					</tr>				</table>				<p class="noindent">Theorem 4:</p>				<table width="80%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td width="30%">Given:</td>						<td>(<var>P</var>1 and <var>B </var>) { <var>S</var>1 } <var>P</var>2</td>					</tr>					<tr>						<td width="30%"></td>						<td> (<var>P</var>1 <u>and</u> <u>non</u> <var>B </var>) { <var>S</var>2 } <var>P</var>2</td>					</tr>					<tr>						<td width="30%">Conclusion:</td>						<td><var>P</var>1 { <u>if</u> <var>B</var> <u>then</u> <var>S</var>1 <u>else</u> <var>S</var>2 } <var>P</var>2</td>					</tr>				</table>				<p class="noindent">Theorem 5:</p>				<table width="80%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td width="30%">Given:</td>						<td> (<var>P</var> <u>and</u> <var>B </var>) { <var>S</var> } <var>P</var></td>					</tr>					<tr>						<td width="30%">Conclusion:</td>						<td><var>P</var> { <u>while</u> <var>B</var> <u>do</u> <var>S</var> } (<var>P</var> <u>and</u> <u>non</u> <var>B </var>)</td>					</tr>				</table>				<p class="noindent">Remark: This theorem only applies to the case that the repetition terminates, otherwise it is void.</p>				<p>Theorem 5 is one of the most useful theorems when dealing with loops. The appropriate reasoning mechanism to deal with loops is mathematical induction, but often the use of Theorem&nbsp;5 (which itself can only be proved by mathematical induction) avoids a direct use of mathematical induction.</p>				<p>We used Theorem 5 when proving the correctness of program1. Here was</p>				<p class="noindent"><var>P</var>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>a</var> &gt; 0 <u>and</u> <var>b</var> &gt; 0 <u>and</u> GCD(<var>a</var>, <var>b</var>) = GCD (<var>A</var>, <var>B </var>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and</p>				<p class="noindent"><var>B</var>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>a</var> &#x2260; <var>b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.</var></p>				<p>We draw attention to the fact that we could not show &quot;<var>P</var> {&nbsp;<var>S</var>&nbsp;}&nbsp;<var>P&nbsp;</var>&quot; but only &quot;(<var>P</var>&nbsp;and&nbsp;<var>B&nbsp;</var>)&nbsp;{&nbsp;<var>S</var>&nbsp;}&nbsp;<var>P&nbsp;</var>&quot;: for <var>a</var> and <var>b</var> to remain positive it was necessary to know that initially they were different. (How is this with program2?) We also draw attention to the fact that after termination, when we wished to show that <var>a</var> = GCD(<var>A</var>, <var>B </var>), we did not only use the mild conclusion &quot;<var>P&nbsp;</var>&quot; bur the strong conclusion &quot;<var>P</var> <u>and</u> <u>non</u> <var>B&nbsp;</var>&quot;: we need the knowledge that <var>a</var> = <var>b</var> in order to justify the application of 3.2.</p>				<p>With respect to termination one often uses a somewhat stronger theorem, the formulation of which falls outside the strict Hoare formalism:</p>				<p class="noindent">Theorem 6:</p>				<table width="80%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td width="30%">Given:</td>						<td>(<var>P</var> <u>and</u> <var>B </var>) { <var>S</var> } <var>P</var></td>					</tr>					<tr>						<td valign="top" width="30%">Conclusion:</td>						<td> in <var>P</var> { <u>while</u> <var>B</var> <u>do</u> <var>S</var> } the relation (<var>P</var> <u>and</u> <var>B </var>) will hold immediately after each execution of the repeatable statement that is not its last execution.</td>					</tr>				</table>				<p class="noindent">This theorem often plays a role when deriving a contradiction from the assumption that the loop will not terminate.</p>			</div>			<div id="content" align="center">				<p class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>					*</p>			</div>			<div id="content">				<p>There is an alternative form of repetition control which might be represented by</p>				<blockquote>					<p class="noindent">&quot;<u>repeat</u> <var>S</var><u> </u>until <var>B </var>&quot;</p>				</blockquote>				<p class="noindent">(other authors write &quot;<u>do</u> <var>S</var> <u>until</u> <var>B </var>&quot;); it is semantically equivalent to</p>				<blockquote>					<p class="noindent">&quot;<var>S </var>; <u>while</u> <u>non</u> <var>B</var> <u>do</u> <var>S </var>&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.</p>				</blockquote>				<p class="noindent">(Instead of describing its semantics in terms of the other repetitive connective, we could also have given a recursive definition in terms of itself, viz. </p>				<blockquote>					<p class="noindent">&quot;<var>S </var>; <u>if</u> <u>non</u> <var>B</var> <u>do</u> <u>repeat</u> <var>S</var> <u>until</u> <var>B</var> &quot; &nbsp;&nbsp;.)</p>				</blockquote>				<p>The differences with the while-clause are:</p>				<p class="continue">1)&nbsp;&nbsp;&nbsp;&nbsp;the termination condition has been inverted</p>				<p class="continue">2)&nbsp;&nbsp;&nbsp;&nbsp;the repeatable statement is executed at least once.</p>				<p>Sometimes the repeat-clause comes in really handy and the text sometimes gains in clarity when it is used. It should be used with great caution, a caution which is shown in the pertinent</p>				<p class="noindent">Theorem 7:</p>				<table width="80%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td width="30%">Given:</td>						<td><var>P</var>1 { <var>S</var> } <var>P</var>2</td>					</tr>					<tr>						<td width="30%"></td>						<td>(<var>P</var>2 <u>and</u> <u>non</u> <var>B </var>) { <var>S</var> } <var>P</var>2</td>					</tr>					<tr>						<td width="30%">Conclusion:</td>						<td><var>P</var>1 { <u>repeat</u> <var>S</var> <u>until</u> <var>B</var> } (<var>P</var>2 <u>and</u> <var>B </var>)</td>					</tr>				</table>				<p class="noindent">Remark: This theorem only applies to the case that the repetition terminates, otherwise it is void.</p>				<p>The greater the complexity of the assumptions about B and S which have to be verified reflects the additional care required in the use of the repeat-clause.</p>				<p class="noindent"><u>Exercise</u>. We give now three tentative alternative programs (3, 4, and 5) for the computation of GCD(<var>A</var>,&nbsp;<var>B </var>). Discover which of them are correct and which are faulty by trying to prove their correctness. If the program is incorrect, construct an <var>A</var>-<var>B</var>-pair for which it fails.</p>				<p class="noindent">program3:<br>					<u>begin</u> <u>integer</u> <var>a</var>, <var>b</var>, <var>gcd</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>a </var>:= <var>A</var>; <var>b </var>:= <var>B </var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> <u>if</u> <var>a</var> &gt; <var>b</var> <u>then</u> <var>a </var>:= <var>a</var> &#150; <var>b</var><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>else</u> <var>b </var>:= <var>b</var> &#150; <var>a</var><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> <var>a</var> = <var>b</var>;<br>					<var>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gcd </var>:= <var>a</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<var>A </var>); print(<var>B </var>); print(<var>gcd </var>)<br>					<u>end</u><br>				</p>				<p class="noindent">program4:<br>					<u>begin</u> <u>integer</u> <var>a</var>, <var>b</var>, <var>gcd</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>a </var>:= <var>A</var>; <var>b </var>:= <var>B </var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> <u>while</u> <var>a</var> &gt; <var>b</var> <u>do</u> <var>a </var>:= <var>a</var> &#150; <var>b</var><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>b</var> &gt; <var>a</var> <u>do</u> <var>b </var>:= <var>b</var> &#150; <var>a</var><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> <var>a</var> = <var>b</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>gcd </var>:= <var>a</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<var>A </var>); print(<var>B </var>); print(<var>gcd </var>)<br>					<u>end</u><br>				</p>				<p class="noindent">program5:<br>					<u>begin</u> <u>integer</u> <var>a</var>, <var>b</var>, <var>gcd</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>a </var>:= <var>A</var>; <var>b </var>:= <var>B </var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>a</var> &#x2260; <var>b</var> <u>do</u><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>if</u> <var>a</var> &lt; <var>b</var> <u>do</u> <u>begin</u> <var>x </var>:= <var>a</var>; <var>a</var> = <var>b</var>; <var>b </var>:= <var>x</var> <u>end</u>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> <var>a </var>:= <var>a</var> &#150; <var>b</var> <u>until</u> <var>a</var> &#x2264; <var>b</var><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>gcd </var>:= <var>a</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<var>A </var>); print(<var>B </var>); print(<var>gcd </var>)<br>					<u>end</u></p>				<p class="noindent">(Note. If any of the above programs is correct, its occurrence in this exercise is not to be interpreted as a recommendation of its style!)</p>				<p class="noindent"><u>Exercise</u>. Prove that the following program will print in addition to the greatest common divisor of <var>A</var> and <var>B</var> the smallest common multiple of <var>A</var> and <var>B</var> (being defined as their product divided by the greatest common divisor).</p>				<p class="noindent"><u>begin</u> <u>integer</u> <var>a</var>, <var>b</var>, <var>c</var>, <var>d</var>, <var>gcd</var>, <var>scm</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>a </var>:= <var>A</var>; <var>b </var>:= <var>B </var>; <var>c</var>:= <var>B </var>; <var>d </var>:= 0;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>a</var> &#x2260; <var>b</var> <u>do</u><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>while</u> <var>a</var> &gt; <var>b</var> <u>do</u> <u>begin</u> <var>a </var>:= <var>a</var> &#150; <var>b</var>; <var>d </var>:= <var>d</var> + <var>c</var> <u>end</u>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <var>b</var> &gt; <var>a</var> <u>do</u> <u>begin</u> <var>b </var>:= <var>b</var> &#150; <var>a</var>; <var>c </var>:= <var>c</var> + <var>d</var> <u>end</u><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>gcd </var>:= <var>a</var>; <var>scm </var>:= <var>c</var> + <var>d </var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(<var>A </var>); print(<var>B </var>); print(<var>gcd </var>); print(<var>scm</var>)<br>					<u>end</u></p>				<p class="noindent">Hint. Follow the expression <var>a</var> * <var>c</var> + <var>b</var> * <var>d&nbsp;&nbsp;</var>. (Courtesy Software Sciences Holdings Limited London)</p>			</div>			<div id="content" align="center">				<p class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>					*</p>			</div>			<div id="content">				<p>For a meaningful loop controlled by a while-clause we can make the following further observations. Let us consider the loop &quot;<u>while</u> <var>B</var> <u>do</u> <var>S&nbsp;</var>&quot;.</p>				<p>Our first observation is that the execution of the repeatable statement <em>must</em> change the state. Suppose that it does not. If then the repeatable statement is executed once, the predicate <var>B</var> (that was true prior to its execution) will still be true after its execution, so that the statement <var>S</var> will be executed yet another time; then the argument can be repeated and the net result is that the repetition will not terminate. The only termination occurs when <var>B</var> is false to begin with: then the statement <var>S</var> will be executed zero times. This we don't call a &quot;meaningful loop&quot;.</p>				<p>So, execution of statement <var>S</var> changes the state: let us call &quot;<var>s</var>&quot; that part of the total state that may be changed by the execution of statement <var>S</var>. Here &quot;<var>s</var>&quot; can be regarded as the aggregate of variables whose values can be affected by the execution of statement <var>S</var>. Then our second observation is that (one or more variables of) <var>s</var> must be involved in the predicate <var>B</var>. If not, a single execution of the repeatable statement would imply infinitely many (by the same argument as used in our previous observation). Treating &quot;<var>s</var>&quot; as a generalized variable, we can express this explicitly by rewriting the loop, using two functions of the generalized argument <var>s</var>:</p>				<blockquote>					<p class="noindent">&quot;<u>while</u> <var>B</var>(<var>s</var>) <u>do</u> <var>s </var>:= <var>S</var>(<var>s</var>)&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.</p>				</blockquote>				<p>This is the basic form of <em>every</em> repetition which is controlled by a while-clause. Reading it, it is obvious that its behaviour is undefined when the initial value of <var>s</var> is completely undefined. In terms of programming this leads to our third observation:</p>				<blockquote>					<p class="noindent">Every repetition controlled by a while-clause requires a proper initialization of the variables involved.</p>				</blockquote>				<p class="noindent">(Although obvious, this rule is mentioned explicitly, because I have seen many programmers forgetting to initialize properly. The rule is so rigid that such an omission is not a mistake but a blunder.)</p>				<p>Let the initial state be denoted by <var>s</var><sub>0</sub> and let the state immediately after the <var>i</var>-th execution of the repeatable statement be denoted by <var>s<sub>i</sub></var>; let the loop terminate after the <var>k</var>-th execution of the repeatable statement. Then the following theorems hold.</p>				<p class="noindent">Theorem 8:<br>					Given <var>s</var><sub>0</sub> , the remaining successive values of <var>s</var> are given by the recurrence relation</p>				<blockquote>					<p class="noindent"><var>s<sub>i</sub></var> = <var>S </var>(<var>s<sub>i</sub></var><sub>-1</sub>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for 0 &lt;<var> i</var> &#x2264; <var>k&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.</var></p>				</blockquote>				<p class="noindent">Theorem 9:<br>					In the sequence <var>s</var><sub>0</sub>, <var>s</var><sub>1</sub>, &#133;, <var>s<sub>k</sub></var> no two values (with different subscripts) are equal.</p>				<p class="noindent">Theorem 10:</p>				<blockquote>					<p class="noindent"><var>B </var>(<var>s</var><sub><var>i </var></sub>) for all <var>i</var> satisfying 0 &#x2264; <var>i</var> &lt; <var>k</var> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and</p>					<p class="continue"><u>non</u> <var>B </var>(<var>s</var><sub><var>k</var></sub>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.</p>				</blockquote>				<p>Theorem 8 is fairly obvious. It is mentioned, however, because it shows that a repetition is an adequate tool for the evaluation of a recurrence relation. Theorem 9 is mentioned because it is so obviously correct (although I see at present no use for it). Theorem 10 &#x2014;also called the &quot;Linear Search Theorem&quot;&#x2014; which is also fairly obvious, is a very important one, comparable in importance to Theorem 5. It does not only assert that after termination the state <var>s<sub>k</sub></var> will be such that <u>non</u> <var>B</var> is valid, it asserts that in all previous states <var>s<sub>i</sub></var> with <var>i</var> &lt; <var>k</var> (if any) <var>B</var> did hold. This theorem is used in many searching algorithms looking for the <em>smallest</em> number for which a predicate <var>B</var> is false: by inspecting the numbers in the order of increasing magnitude, the <em>smallest</em> becomes the <em>first</em> found. Theorem 10 tells us that in that case a loop controlled by a while-clause is a proper vehicle. (It is not restricted to looking for a smallest number, it can be applied to any (somehow) ordered set of values of some sort.)</p>				<p class="noindent"><u>Remark</u>. We have called the last three theorems &quot;obvious&quot;. This is not meant to imply that giving a reasonably formal proof for them is trivial. I did it, but the resulting proofs were surprisingly cumbersome and boring.</p>				<p>Finally, in Theorems 2, 3, and 5 we always have assumptions including the truth of <var>B</var> prior to the execution of <var>S</var>. Clearly we are not interested in the net effect of the execution of <var>S</var> after an initial state in which <var>B</var> is false. As a matter of fact, with such initial states the net effect of an <var>S</var> will often be undefined. (A similar remark can be made regarding Theorem 4.) in other words: our statements <var>S</var> regarded as operators are often not defined on the domain of all possible states, they are &quot;partial operators&quot; and the predicates occurring in the clauses ensure that they will not be evoked inappropriately. This observation should temper our hope of increasing computation speed by introducing more parallelism.</p>				<p class="noindent"><a href="#contents">Back to top</a></p>				<p class="noindent">Next chapter: 5. <a title="Chapter 5 of EWD 316" href="EWD316.5.html">Programs corresponding to recurrence relations</a></p>				<p></p>			</div>			<hr />			<!-- name and date -->      <div id="footer">transcribed by Max Kohler<br />revised <csobj format="MedDate" h="15" region="15" t="DateTime" w="95">Sat, 2 Aug 2008</csobj></div>    </div>  </body></html></x-html>