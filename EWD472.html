  <!DOCTYPE html>
  <html>
  <head>
    <title>Guarded commands, non-determinacy and formal derivation of programs</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <link href="assets/tweet-selection.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.12.0.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="assets/tweet-selection.js"></script>
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: Guarded commands, non-determinacy and formal derivation of programs" />
    <meta name="twitter:title" content="Guarded commands, non-determinacy and formal derivation of programs" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>Guarded commands, non-determinacy and formal derivation of programs</h1>
  <a class='original' href='https://www.cs.utexas.edu/~EWD/ewd47xx/EWD472.PDF'><img src='assets/original.png' alt='Show original manuscript'></a>
  <div class='body'>
<hr>
<p class="noindent">NOTE: This transcription was contributed by Martin P.M. van der Burgt, who has devised a process for producing transcripts automatically. Although its markup is incomplete, we believe it serves a useful purpose by virtue of its searchability and its accessibility to text-reading software. It will be replaced by a fully marked-up version when time permits. —HR</p>
<hr>
<p class="noindent" style="margin-bottom: 0.5cm">&nbsp;</p>
<p class="noindent" style="margin-bottom: 0.5cm"><font face="Arial Black, sans-serif">Copyright Notice</font></p>
<p class="noindent" style="margin-bottom: 0.5cm"><font face="Arial, sans-serif"><font size="2">The following manuscript</font></font></p>
<p style="margin-bottom: 0.5cm"><font face="Arial, sans-serif"><font size="2">EWD 472: Guarded commands, non-determinacy and formal derivation of programs</font></font></p>
<p class="noindent" style="margin-bottom: 0.5cm"><font face="Arial, sans-serif"><font size="2">was published in Commun. ACM 18(1975), 8: 453-457.</font></font></p>
<p class="noindent" style="margin-bottom: 0.5cm"><font face="Arial, sans-serif"><font size="2"><b>It is reproduced here by permission.</b></font></font></p>
<p class="noindent"><b>Guarded commands, non-determinacy and formal derivation of programs</b>.</p>
<table width="100%">
<tr>
<td valign="top" width="30%"></td>
<td>by Edsger W.Dijkstra *)</td>
</tr>
<tr>
<td valign="top">&nbsp;</td>
<td></td>
</tr>
<tr>
<td valign="top">*) Author’s address:</td>
<td>BURROUGHS</td>
</tr>
<tr>
<td valign="top"></td>
<td>Plataanstraat 5</td>
</tr>
<tr>
<td valign="top"></td>
<td>NUENEN - 4565</td>
</tr>
<tr>
<td valign="top"></td>
<td>The Netherlands.</td>
</tr>
</table>
<p class="noindent"><b>Abstract</b>. So-called “guarded commands” are introduced as a building block for alternative and repetitive constructs that allow non-deterministic program components for which at least the activity evoked, but possibly even the final state, is not necessarily uniquely determined by the initial state. For the formal derivation of programs expressed in terms of these constructs, a calculus will be shown.</p>
<p class="noindent"><b>Keywords</b>. programming languages, sequencing primitives, program semantics, programming language semantics, non-determinacy, case-construction, repetition, termination, correctness roof, derivation of programs, programming methodology.</p>
<p class="noindent">CR-category: 4.20, 4.22.</p>
<p class="noindent"><b>Guarded commands, non-determinacv and formal derivation of programs.</b></p>
<p>1. <b>Introduction</b>.</p>
<p>In section 2, two statements, an alternative construct and a repetitive construct will be introduced, together with an intuitive (mechanistic) definition of their semantics. The basic building block for both of them is the so-called “guarded command”, a statement list prefixed by a boolean expression: only when this boolean expression is initially true, is the statement list eligible for execution. The potential non-determinacy allows us to map otherwise (trivially) different programs on the same program text, a circumstance that seems largely responsible for the fact that now programs can be derived in a more systematic manner then before.</p>
<p>In section 3, after a prelude defining the notation, a formal definition of the semantics of the two constructs will be given, together with two theorems for each of the constructs (without proof).</p>
<p>In section 4, it will be shown, how upon the above a formal calculus for the derivation of programs can be founded. We would like to stress that we do not present “an algorithm” for the derivation of programs: we have used the term “a calculus” for a formal discipline —a set of rules— such that, if applied successfully<br>
1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it will have derived a correct program<br>
2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it will tell us that we have reached such a goal. (We use the term as in “integral calculus”.)</p>
<p>2. <b>Two statements made from guarded commands</b>.</p>
<p>If the reader accepts “other statements” as indicating, say, assignment statements and procedure calls, we can give the relevant syntax in BNF [2]. In the following we have extended BNF with the convention that the braces “{...}” should be read as: “followed by zero or more instances of the enclosed”.</p>
<p class="p0">&lt; <var>guarded command</var> &gt; ::= &lt; <var>guard</var> &gt; → &lt; <var>guarded list</var> &gt;</p>
<p class="p0">&lt; <var>guard</var> &gt; ::= &lt; <var>boolean expression</var> &gt;</p>
<p class="p0">&lt; <var>guarded list</var> &gt; ::= &lt; <var>statement</var> &gt; {; &lt; <var>statement</var> &gt;}</p>
<p class="p0">&lt; <var>guarded command set</var> &gt; ::= &lt; <var>guarded command</var> &gt; {▯ &lt; <var>guarded command</var> &gt;}</p>
<p class="p0">&lt; <var>alternative construct</var> &gt; ::= <b>if</b> &lt; <var>guarded command set</var> &gt; <b>fi</b></p>
<p class="p0">&lt; <var>repetitive construct</var> &gt; ::= <b>do</b> &lt; <var>guarded command set</var> &gt;<b>od</b></p>
<p class="p0">&lt; <var>statement</var> &gt; ::= &lt; <var>alternative construct</var> &gt; | &lt; <var>repetitive construct</var> &gt; | “<var>other statements</var>” .</p>
<p>The semicolons in the guarded list have the usual meaning: when the guarded list is selected for execution its statements will be executed successively in the order from left to right; a guarded list will only be selected for execution in a state such that its guard is true. Note that a guarded command by itself is <b>not</b> a statement: it is a component of a guarded command set from which statements can be constructed. If the guarded command set consists of more than one guarded command, they are mutually separated by the separator “▯” ; our text is then an arbitrarily ordered enumeration of an unordered set, i.e. the order in which the guarded commands of a set appear in our text is semantically irrelevant.</p>
<p>Our syntax gives two ways for constructing a statement out of a guarded command set. The alternative construct is written by enclosing it by the special bracket pair: <b>if</b> ... <b>fi</b>“. If in the initial state none of the guards is true, the program will abort, otherwise an arbitrary guarded list with a true guard will be selected for execution.</p>
<p class="noindent"><b>Note</b>. If the empty guarded command set were allowed ”<b>if</b> <b>fi</b>“ would be semantically equivalent to ”abort“ . (End of note.)</p>
<p>An example —illustrating the non-determinacy in a very modest fashion— would be the program that for fixed x and y assigns to m the maximum value of x and y :</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>if</b> x ≥ y → m:= x</td>
</tr>
<tr>
<td></td>
<td>&nbsp;</td>
<td>▯ y ≥ x → m:= y</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>fi</b> .</td>
</tr>
</table>
<p>The repetitive construct is written down by enclosing a guarded command set by the special bracket pair <b>do</b> ... <b>od</b>” . Here a state in which none of the guards is true will not lead to abortion but to proper termination; the complementary rule, however, is that it will only terminate in a state in which none of the guards is true: when initially or upon completed execution of a selected guarded list one or more guards are true, a new selection for execution of a guarded list with a true guard will take place, and so on. When the repetitive construct has terminated properly, we know that all its guards are false.</p>
<p class="noindent"><b>Note</b>. If the empty guarded command set were allowed “<b>do</b> <b>od</b>” would be semantically equivalent to “skip” . (End of note.)</p>
<p>An example —showing the non-determinacy in somewhat greater glory— is the program that assigns to the variables q1, q2, q3 and q4 a permutation of the values Q1, Q2, Q3 and Q4, such that q1 ≤ q2 ≤ q3 ≤ q4 . Using concurrent assignment statements for the sake of convenience, we can program</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="2">q1, q2, q3, q4 := Q1, Q2, Q3, Q4;</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>do</b> ql &gt; q2 → ql, q2 := q2, ql</td>
</tr>
<tr>
<td></td>
<td>&nbsp;</td>
<td>▯ q2 &gt; q3 → q2, q3 := q3, q2</td>
</tr>
<tr>
<td></td>
<td></td>
<td>▯ q3 &gt; q4 → q3, q4 := q4, q3</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>od</b></td>
</tr>
</table>
<p>To conclude this section we give a program where not only the computation but also the final state is not necessarily uniquely determined. The program should determine k such that for fixed value n (n &gt;0) and a fixed function f(i) defined for O ≤ i &lt; n , k will eventually satisfy:</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>0 ≤ k &lt; n <b>and</b> (∀i: 0 ≤ i &lt; n: f(k) ≥ f(i))</td>
</tr>
</table>
(Eventually k should be the place of at maximum.)
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="3">k:= 0; j:= 1;</td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>od</b> j ≠ n → <b>if</b> f(j) ≤ f(k) → j:= j + 1</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp;</td>
<td>▯ f(j) ≥ f(k) → k:= j; j:= j + 1</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>fi</b></td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>od</b></td>
</tr>
</table>
<p>Only permissible final states are possible and each permissible final state is possible .</p>
<p><b>3. Formal definition of the semantics</b>.</p>
<p><b>3.1. Notational prelude.</b></p>
<p>In the following sections we shall use the symbols P, Q and R to denote (predicates defining) boolean functions defined on all points of the state space; alternatively we shall refer to them as “conditions”, satisfied by all states for which the boolean function is true. Two special predicates that we denote by the reserved names “T” and “F” play a special role: T denotes the condition that, by definition, is satisfied by all states, F denotes, by definition, the condition that is satisfied by no state at all.</p>
<p>The way in which we use predicates (as a tool for defining sets of initial or final states) for the definition of the semantics of programming language constructs has been directly inspired by Hoare [1], the main difference being that we have tightened things up a bit: while Hoare introduces sufficient pre-conditions such that the mechanisms will not produce the wrong result (but may fail to terminate), we shall introduce necessary and sufficient —i.e. so-ca1led “weakest”— pre-conditions such that the mechanisms are guaranteed to produce the right result.</p>
<p>More specifically: we shall use the notation “wp(S, R)”, where S denotes a statement list and R some condition on the state of the system, to denote the weakest pre-condition for the initial state of the system such that activation of S is guaranteed to lead to a properly terminating activity leaving the system in a final state satisfying the post-condition R . Such a “wp” —which is called “a predicate transformer”, because it associates a pre-condition to any post-condition R — has, by definition, the following properties .</p>
<p class="noindent">1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For any S, we have for all states</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wp(S, F) = F</td>
</tr>
</table>
(the so-called “Law of the Excluded Miracle”).<br>
2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For any S and any two post-conditions, such that for all states
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>P ⇒ Q</td>
</tr>
</table>
we have for all states
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wp(S, P) ⇒ wp(S, Q) .</td>
</tr>
</table>
3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For any S and any two post-conditions P and Q we have for all states
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(wp(S, P) <b>and</b> wp(S, Q)) = wp(S, P <b>and</b> Q).</td>
</tr>
</table>
4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;For any deterministic S and any post-conditions P and Q we have for all states
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(wp(S, P) <b>or</b> wp(S, Q)) = wp(S, P <b>or</b> Q) .</td>
</tr>
</table>
For non-deterministic mechanisms S the equality has “to be replaced by an implication; the resulting formula follows from the second property.
<p>Together with the rules of propositional calculus and the semantic definitions to be given below, the above four properties take over the role of the “rules of inference” as introduced by Hoare [1].</p>
<p>We take the position that we know the semantics of a mechanism S sufficiently well if we know its predicate transformer, i.e. can derive wp(S, R) For any post-condition R.</p>
<p class="noindent"><b>Note</b>. We consider the semantics of S only defined for those initial states for which has been established a priori that they satisfy wp(S, T), i.e. for which proper termination is guaranteed (even in the face of possibly non-deterministic behaviour); for other initial states we don’t care. By suitably changing S, if necessary, we can always see to it that wp(S, T) is decidable.(End of note.)</p>
<p class="noindent"><b>Example 1</b>. The semantics of the empty statement, denoted by ’“skip”, are given by the definition that for any post-condition R, we have</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wp(“skip”, R) = R .</td>
</tr>
</table>
<p class="noindent"><b>Example 2</b>. The semantics of the assignment statement “x:= E” are given by</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wp(“x:= E”, R) = R<sub>E</sub><sup>x</sup></td>
</tr>
</table>
in which R<sub>E</sub><sup>x</sup> denotes a copy of the predicate defining R in which each occurence of the variable x is replaced by “(E)”.
<p class="noindent"><b>Example 3</b>. The semantics of the semicolon “;” as concatenation operator are given by</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wp(“S1; S2”, R) = wp(S1, wp(S2, R)) .</td>
</tr>
</table>
<p><b>3.2. The alternative construct</b>.</p>
<p>In order to define the semantics of the alternative construct we define two abbreviations. Let “IF” denote</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td><b>if</b> b<sub>1</sub> → SL<sub>1</sub> ▯ ... ▯ B<sub>n</sub> → SL<sub>n</sub> <b>fi</b> ;</td>
</tr>
</table>
let “BB” denote
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(∃i: 1 ≤ i ≤ n: B<sub>i</sub>) ;</td>
</tr>
</table>
then, by definition
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wp(IF, R) = (BB <b>and</b> (∀i: 1 ≤ i ≤ n: B<sub>i</sub> ⇒ wp(SL<sub>i</sub>, R)) .</td>
</tr>
</table>
<p class="noindent">(The first term “BB” requires that the alternative construct as such will not lead to abortion on account of all guards false, the second term requires that each guarded list eligible for execution will lead to an acceptable final state.) From this definition we can derive —by simple substitutions—</p>
<p class="noindent"><b>Theorem 1</b>. From</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(∀i: 1 ≤ i ≤ n: (Q <b>and</b> B<sub>i</sub>) ⇒ wp(SL<sub>i</sub>, R)) for all states</td>
</tr>
</table>
we can conclude that
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(Q <b>and</b> BB) ⇒ wp(IF, R) holds for all states .</td>
</tr>
</table>
<p>Let “t” denote some integer function, defined on the state space, and let “wdec(S, t)” denote the weakest pre-condition such that activation of S is guaranteed to lead to a properly terminating activity leaving the system in a final state such that the value of t is decreased by at least 1 (compared to its initial value). In terms of “wdec” we can formulate the very similar</p>
<p class="noindent"><b>Theorem 2</b>. From .</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(∀i: 1 ≤ i ≤ n: (Q <b>and</b> B<sub>i</sub>) ⇒ wdec(SL<sub>i</sub>, t)) for all states</td>
</tr>
</table>
we can conlude that
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(Q <b>and</b> BB) ⇒ wdec(IF, t) holds for all states.</td>
</tr>
</table>
<b>Note</b> (which can be skipped at first reading). The relation between “wp” and “wdec” is as follows. For any point X in state space we can regard
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wp(S, t ≤ t0)</td>
</tr>
</table>
as an equation with t0 as the unknown. Let its smallest solution for t0 be tmin(X). (Here we have added the explicit dependence on the state X.) Then tmin(X) can be interpreted as the lowest upper bound for the final value of t if the mechanism S is activated with X as initial state. Then, by definition,
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wdec(S, t) = (tmin(X) ≤ t(X) - 1) = (tmin(X) &lt; t(X)) .</td>
</tr>
</table>
(End of note.)
<p><b>3.3. The repetitive construct</b>.</p>
<p>As is to be expected, the definition of the repetitive construct</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td><b>do</b> b<sub>1</sub> → SL<sub>1</sub> ▯ ... ▯ B<sub>n</sub> → SL<sub>n</sub> <b>od</b></td>
</tr>
</table>
that we denote by “DO”, is more complicated.
<table width="100%">
<tr>
<td valign="top" width="15%">Let</td>
<td>H<sub>0</sub>(R) = (R <b>and</b> <b>non</b> BB)</td>
</tr>
<tr>
<td valign="top">and for k &gt; 0:</td>
<td>H<sub>k</sub>(R) = (wp(IF, H<sub>k-1</sub>(R)) <b>or</b> H<sub>0</sub>(R))</td>
</tr>
</table>
(where “IF” denotes the <b>same</b> guarded command set enclosed by “<b>if</b> <b>fi</b>”) then, by definition
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wp(DO, R) =(&amp;#x2203k: k ≥ 0: H<sub>k</sub>(R)) .</td>
</tr>
</table>
(Intuitively, H<sub>k</sub>(R) can be interpreted as the weakest pre-condition guaranteeing proper termination after at most k selections of a guarded list, leaving the system in a final state satisfying R .) Via mathematical induction we can prove
<p class="noindent"><b>Theorem 3.</b> If we have for all states</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(P <b>and</b> BB) ⇒ (wp(IF, P) <b>and</b> wdec(IF, t) <b>and</b> t ≥ 0)</td>
</tr>
</table>
we can conclude that we have for all states
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>P ⇒ wp(DO, P <b>and</b> <b>non</b> BB) .</td>
</tr>
</table>
Note that the antecedent of Theorem 3 is of the form of the consequents of Theorems 1 and 2.
<p>Because T is the condition by definition satisfied by all states, wp(S, T) is the weakest pre-condition guaranteeing proper termination for S . This allows us to formulate an alternative theorem about the repetitive construct, viz.</p>
<p class="noindent"><b>Theorem 4.</b> From</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(P <b>and</b> BB) ⇒ wp(IF, P) for all states,</td>
</tr>
</table>
we can conclude that we have for all states
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(P <b>and</b> wp(DD, T)) ⇒ wp(DO, P <b>and</b> <b>non</b> BB) .</td>
</tr>
</table>
In connection with the above theorems “P” is called “the invariant relation” and “t” is called “the variant function”. Theorems 3 and 4 are easily proved by mathematical induction, with k as the induction variable.
<p><b>4. Formal derivation of programs</b>.</p>
<p>The formal requirement of our program performing “m:= max(x, y)” —see above— is that for fixed x and y it establishes the relation</p>
<table width="100%">
<tr>
<td valign="top" width="10%">R:</td>
<td>(m = x <b>or</b> m = y) <b>and</b> m ≥ x <b>and</b> m ≥ y .</td>
</tr>
</table>
<p>Now the Axiom of Assignment tells us that “m:= x” is the standard way of establishing the truth of “m = x” for fixed x, which is a way of establishing the truth of the first term of R. Will “m:= x” do the job? In order to investigate this, we derive and simplify</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2">wp(“m:= x”, R) = (x = x <b>or</b> x = y) <b>and</b> x ≥ x <b>and</b> x ≥ y</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>= x ≥ y .</td>
</tr>
</table>
Taking this weakest pre-condition as its guard, Theorem 1 tell us that
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td><b>if</b> x ≥ y → m:= x <b>fi</b></td>
</tr>
</table>
will produce the correct result if it terminates succesfully. The disadvantage of this program is that BB ≠ T, i.e. it might lead to abortion; weakening BB means looking for alternatives which might introduce new guards. The obvious alternative is the assignment “m:= y” with the guard
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wp(“m:= y”, R) = y ≥ x ;</td>
</tr>
</table>
so thus we are led to our program
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>if</b> x ≥ y → m:= x</td>
</tr>
<tr>
<td></td>
<td>&nbsp;</td>
<td>▯ y ≥ x → m:= y</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>fi</b></td>
</tr>
</table>
and by this time BB = T and therefore we have solved the problem. (In the mean time we have proved that the maximum of two values is always defined, viz. that R considered as equation for m has always a solution.)
<p>As an example of the deriviation of a repetitive construct we shall derive a program for the greatest common divisor of two positive numbers, i.e. for fixed, positive X and Y we have to establish the final relation</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>x = gcd(x, v) .</td>
</tr>
</table>
<p>The formal machinery only gets in motion, once we have chosen our invariant relation and our variant function. The program then gets the structure “establish the relation P to be kept invariant”;</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>do</b> “decrease t as long as possible onder invariance</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td>of P” <b>od</b> .</td>
</tr>
</table>
<p>Suppose that we choose for the invariant relation</p>
<table width="100%">
<tr>
<td valign="top" width="10%">P:</td>
<td>gcd(X, Y) = gcd(x, y) <b>and</b> x &gt; O <b>and</b> y &gt; 0</td>
</tr>
</table>
a relation that has the advantage of being easily established by
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>x:= X; y:= Y .</td>
</tr>
</table>
<p>The most general “something” to be done under invariance of P is of the form</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>x, y:= E1, E2</td>
</tr>
</table>
and we are interested in a guard B such that
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2">(P <b>and</b> B) ⇒ wp(“x, y := E1, E2”, P)</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>= (gcd(X, Y) = gcd(E1, E2) <b>and</b> E1 &gt;0 <b>and</b> E2 &gt;0) .</td>
</tr>
</table>
<p>Because the guard must be a computable boolean expression and should not contain the computation of gcd(X, Y) —for that was the whole problem!— we must see to it that the expressions E1 and E2 are so chosen. that the first term</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>gcd(X, Y) = gcd(E1, E2)</td>
</tr>
</table>
is implied by P, which is true if
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>gcd(x, y) = gcd(E1, E2) .</td>
</tr>
</table>
In other words we are invited to massage the value pair (x, y) in such a fashion that their gcd is not changed. Because —and this is the place at which to mobilize our mathematical knowledge about the gcd-function—
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>gcd(x, y) = gcd(x - y, y)</td>
</tr>
</table>
a possible guarded list would be
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>x:= x - y .</td>
</tr>
</table>
Deriving
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wp(“x:= x - y”, P) = (gcd(X, Y) = gcd(x - y, y) <b>and</b> x - y &gt; 0 <b>and</b> y &gt; 0)</td>
</tr>
</table>
and omitting all terms of the conjunction implied by P we find the guard
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>x &gt; y</td>
</tr>
</table>
as far as the invariance of P is concerned. Besides that we must require guaranteed decrease of the variant function t . Let us investigate the consequences of the choice
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>t = x + y .</td>
</tr>
</table>
From
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wp(“x:= x - y”, t ≤ t0) =</td>
</tr>
<tr>
<td></td>
<td>wp(“x:= x - y”. x + y ≤ t0) = (x ≤ t0)</td>
</tr>
</table>
we conclude that .
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>tmin = x ;</td>
</tr>
</table>
therefore
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wdec(“x:= x - y”, t) = (x &lt; x + y) = (y &gt; 0) .</td>
</tr>
</table>
<p>The requirement of monotonic decrease of t imposes no further restriction of the guard because wdec(“x:= x - y”, t) is fully implied by P and we come at our first effort</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>x:= X; y:= Y;</td>
</tr>
<tr>
<td></td>
<td><b>do</b> x &gt; y → x:= x - y <b>od</b> .</td>
</tr>
</table>
<p>Alas, this single guard is insufficient: from P <b>and</b> <b>non</b> BB we are not allowed to conclude x = gcd(X, Y). In a completely analogous manner, the alternative y:= y - x will require as its guard y &gt; x and our next effort is</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2">x:= X; y:= Y;</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>do</b> x &gt; y → x:= x - y</td>
</tr>
<tr>
<td></td>
<td>&nbsp;</td>
<td>▯ y &gt; x → y:= y - x</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>od</b> .</td>
</tr>
</table>
<p>Now the job is done, because with this last program <b>non</b> BB = (x = y) and (P <b>and</b> x = y) ⇒ (X = gcd(X, Y) because gdc(x, x) = x .</p>
<p class="noindent"><b>Note</b>. The choice of t = x +2y and the knowledge of the fact that the gcd is a symmetric function could have led to the program</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2">x:= X; y:= Y;</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>do</b> x &gt; y → x:= x - y</td>
</tr>
<tr>
<td></td>
<td>&nbsp;</td>
<td>▯ y &gt; x → x, y:= y, x</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>od</b> .</td>
</tr>
</table>
The swap “x, y := y, x” can never destroy P : the guard of the last guarded list is fully caused by the requirement that t is effectively decreased.
<p>In both cases the final game has been to find a large enough set of such guarded lists that BB, the disjunction of their guards, was sufficiently weak: in the case of the alternative construct the purpose is avoiding abortion, in the case of the repetitive construct the goal is getting BB weak enough such that P <b>and</b> <b>non</b> BB is strong enough to imply the desired post-condition R .</p>
<p>It is illuminating to compare our first version of Euclid’s Algorithm with what we would have written down with the traditional clauses;</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>x:= X; y:= Y; (version A)</td>
</tr>
<tr>
<td></td>
<td><b>while</b> x ≠ y <b>do</b> <b>if</b> x &gt; y <b>then</b> x:= x - y <b>else</b> y:= y - x <b>od</b> <b>od</b></td>
</tr>
</table>
and
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="3">x:= X; y:= Y; (version B)</td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>while</b> x ≠ y <b>do</b> <b>while</b> x &gt; y <b>do</b> x:= x - y <b>od</b> ;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td><b>while</b> y &gt; x <b>do</b> y:= y - x <b>od</b></td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>od</b></td>
</tr>
</table>
<p class="noindent">In the fully symmetric version with the guarded commands the algorithm has been reduced to its bare essentials, while the traditional clauses force us to choose between versions A and B (and others), a choice that can only be justified by making assumptions about the time taken for tests and about expectation values for traversal frequencies. (But even taking the time taken for tests into account, it is not clear that we have lost: the average number of necessary tests per assignment ranges with guarded commands from 1 to 2, equals 2 for version A and ranges from 1 to 2.5 for version B. If the guards of a guarded command set are evaluated concurrently —nothing in our semantics excludes that— the new version is time-wise superior to all the others.) The virtues of the <b>case</b>-construction have been extended to repetition as well.</p>
<p>5. <b>Concluding remarks.</b></p>
<p>The research, the outcome of which is reported in this article, was triggered by the observation that Euclid’s Algorithm could also be regarded as synchronizing the two cyclic processes “<b>do</b> x:= x - y <b>od</b>” and “<b>do</b> y:= y - x <b>od</b>” in such a way that the relation x &gt; 0 <b>and</b> y &gt; 0 would be kept invariantly true. It was only after this observation that we saw that the formal techniques we had already developed for the derivation of the synchronizing conditions that ensure the harmonious co-operation of (cyclic) sequential processes, such as can be identified in the total activity of operating systems, could be transferred lock, stock and barrel to the development of sequential programs as shown in this article. The main difference is that while for sequential programs the situation “all guards false” is a desirable goal —for it means termination of a repetitive construct—, one tries to avoid it in operating systems —for there it means deadlock.</p>
<p>The second reason to pursue these investigations was my personal desire to get a better appreciation, which part of the programming activity can be regarded as a formal routine and which part of it seems to require “invention”. While the design of an alternative construct now seems to be a reasonably straightforward activity, that of a repetitive construct requires what I regard as “the invention” of an invariant relation and a variant function. My presentation of this calculus should, however, not be interpreted as my suggestion that all programs should be developed in this way: it just gives us another handle.</p>
<p>The calculus does, however, explain my preference for the axiomatic definition of programming language semantics via predicate transformers above other definition techniques: the definition via predicate transformers seems to lend itself most readily to being forged into a tool for the goaldirected activity of program composition.</p>
<p>Finally I would like to add a word or two about the potential nondeterminacy. Having worked mainly with hardly self-checking hardware, with which non-reproducing behaviour of user programs is a very strong indication of a machine malfunctioning, I had to overcome a considerable mental resistance, before I found myself willing to consider non-deterministic programs seriously. It is, however, fair to say that I could never have discovered the calculus before having taken that hurdle: the simplicity and elegance of the above would have been destroyed by requiring the derivation of deterministic programs only. Whether non-determinacy is eventually removed mechanically —in order not too mislead the maintenance engineer— or (perhaps only partly) by the programmer himself because, at second thought, he does care —e.g. for reasons of efficiency— which alternative is chosen, is something I leave entirely to the circumstances. In any case we can appreciate the non-deterministic program as a helpful steppingstone.</p>
<p class="noindent"></p>
<p><b>Acknowledgements</b>.</p>
<p>In the first place my acknowledgements are due to the members of the IFIP Working Group W.G.2.3 on “Programming Methodology”. Besides them, W.H.J.Feijen, D.E.Knuth, M.Rem and C.S.Scholten have been directly helpful in one way or another. I should also thank the various audiences —in Albuquerque (courtesy NSF), in San Diego and Luxembourg (courtesy Burroughs Corporation)— that have played their role of critical sounding board beyond what one is entitled to hope.</p>
<p class="noindent">[1] Hoare, C.A.R., An Axiomatic Basis for Computer Programming, Comm.ACM 12 (Oct. 1969) 575 - 583.<br>
[2] Naur, Peter, (Ed.) Report on the Algorithmic Language ALGOL 60, Comm.ACM 3 (May 1960) 299 - 314</p>
<p class="noindent"></p>
<table width="100%">
<tr>
<td valign="top" width="20%">27th January 1975</td>
<td>prof.dr.Edsger W.Dijkstra</td>
</tr>
<tr>
<td valign="top">NUENEN</td>
<td>Burroughs Research Fellow</td>
</tr>
</table>
<hr>
<p class="noindent"><font size="-1">Transcribed by Martin P.M. van der Burgt<br>
Last revision <!-- #BeginDate format:IS1 -->2014-12-08<!-- #EndDate -->
 .</font></p>
<p>&nbsp;</p>
</div>
  <script>
$('.body').tweetSelection({
  ellipsis: '...',
  quoteLeft: '\'',
  quoteRight: '\'',
  via: 'raboofje'
});
  </script>
  </body>
  </html>
