  <!DOCTYPE html>
  <html>
  <head>
    <title>Towards correct programs</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: Towards correct programs" />
    <meta name="twitter:title" content="Towards correct programs" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>Towards correct programs</h1>
  <div class='body'><html>
<head>
<style type="text/css">
p {text-indent: 3em; margin-top: 0.25in}
p.pagenum { text-align: right }
p.signature {text-indent: 0; margin-left: 24em; margin-right: 6em; text-align: left;margin-top: 0in}
p.novert {text-indent: 0em; margin-top: 0in; margin-bottom: 0in;}
p.indentnovert  {text-indent: 3em; margin-top: 0in; margin-bottom: 0in;}
p.head {text-indent: 0em; text-decoration: underline}
p.noindent {text-indent: 0em; margin-top: 0in; margin-bottom: 0in}
p.zero {text-indent: 0em; margin-top: 0in; margin-bottom: 0in; font-family: Courier, sans-serif}
p.one {text-indent: 3em; margin-top: 0in; margin-bottom: 0in; font-family: Courier, sans-serif}
p.two {text-indent: 6em; margin-top: 0in; margin-bottom: 0in; font-family: Courier, sans-serif}
p.three {text-indent: 9em; margin-top: 0in; margin-bottom: 0in; font-family: Courier, sans-serif}
p.four {text-indent: 12em; margin-top: 0in; margin-bottom: 0in; font-family: Courier, sans-serif}
p.five {text-indent: 15em; margin-top: 0in; margin-bottom: 0in;font-family: Courier, sans-serif}
p.six{text-indent: 15em; margin-top: 0in; margin-bottom: 0in; font-family: Courier, sans-serif}
rw {text-decoration: underline}

td.math { font-family: Courier }
</style>
		<title>E.W.Dijkstra Archive: Towards correct programs (EWD 241)</title>
	</head>

<body>
<p class="pagenum"><a href="https://www.cs.utexas.edu/~EWD/ewd02xx/EWD241.PDF" target="_blank">EWD241</a><p class="head">Towards correct programs.
<p>The purpose of this paper is to stress what mental aids we have at
our disposal in designing and understanding algorithms, to show some
patterns of programming that we may hope to apply without losing our
intellectual grasp on what we are doing and to stress the need that
our programs (i.e. the final program and the intermediate programs
leading to it) mirror as closely as possible our understanding of the
problem and the algorithms solving it.
<p> Among the mental aids available I should like to mention three
explicitly:
<p class="noindent">1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enumeration<p class="noindent">2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Mathematical Induction<p class="noindent">3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abstraction.
		<p>I regard as an appeal to Enumeration the mental effort required to
understand either a sequential program generating a fixed time
sequence of actions or a conditional or alternative clause (the
so-called "case construction" included). As one of the principle
properties of the human mind I take that the appeal to enumeration
should be small. In particular this means
<br>
			1a) that the text describing a sequential program
fragment should generate a small number of actions (i.e. that the
corresponding computation can be grouped, understood as the time
succession of a small number of actions)
<br>
			1b) that the number of cases to be distinguished
in an alternative clause should be small.

		<p>Mathematical induction is mentioned explicitly because it is the
standard pattern of reasoning to understand recursive procedures and
the (much more common) loops; I shall restrict myself to loops
generated by some form of repetition clause.

		<p>Abstraction is regarded as the main mental tool needed for the application of mathematical induction &#x2014;i.e. to form the concepts in terms of which the net effect of the induction step can be described&#x2014; and valuable in the effort to reduce the appeal to enumeration: in the case of an alternative clause it should provide the concepts in terms of which the net effect can be described regardless of the path taken.<p>With the above in mind I shall tackle the following problem. Given
32 cyclically arranged positions, make a program generating all ways
(if any) in which these positions can be filled with zeros and ones
(one digit per position) such that the 32 quintuples of five adjoining
positions present the 32 different patterns of five binary
digits. Fillings that only differ from each other by rotation are
regarded as equivalent, all solutions have to be generated with the
five zeros leading. (The last sentence reduces the number of
"independent solutions" by a factor 32.)

		<p>C. Ligtmans has shown that the above cyclic problem is equivalent to the following linear problem. Given a linear array of 36 positions, make a program generating all ways (if any) in which these positions can be filled with zeros and ones (one digit per position) such that the 32 quintuples of five adjoining positions present the 32 different patterns of five binary digits. We may restrict ourselves to sequences staring with five zeros, the 32 leading digits of a solution of the linear problem present a solution of the cyclic one and vice versa. (The proof by C. Ligtmans runs as follows. Each solution of the linear problem starts with 000001... &#x2014;because the pattern 00000 may occur only once&#x2014;; furthermore the pattern 10000 must occur once; as the latter patterns can only be followed by 00000 or 00001 (presented already by the first two quintuples), the pattern 10000 cannot occur in the interior of the linear sequence and therefore it must occur at the end. As a result each
solution of the linear problem ends with four zeros and therefore the
ring closes!) We shall solve the linear problem, imposing the further
condition that the solutions (if more than one) have to be generated
in alphabetical order.

		<p class="indentnovert">The coarsest description of the program is as a single instruction<br>
			Version 0:
		<p class="indentnovert">&quot;do all work&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<p>This description is completely general, but also completely
useless, for it reflects none of our understanding of the problem nor
anything about the structure of the algorithm. In order to be able to
proceed we have to analyse the problem further.
<p>I take for granted that, given a sequence of 36 binary digits the
boolean function stating whether this sequence represents a solution
is computable and that we could write an algorithm computing it. In
principle we could write a program generating all 36-digit sequences
with five leading zeros in alphabetical order and subjecting all these
sequences to the test just mentioned, thereby selecting those
satisfying the test. This gives a very unrealistic program and we
shall not pursue it; we only remark that generating the trial
sequences in alphabetical order will ensure that the solutions, when
found, will be found in alphabetical order as well.
<p>Remark. Our final program could be regarded as a derivation from
the one sketched above, viz. by the introduction of some significant
short-cuts. At present I do not feel inclined to stress this relation
any further for it seems too tightly connected with this specific
problem.
<p>In our next approach we shall again generate our solutions by
(generating and) scanning a larger set of sequences from which by a
suitable criterion all solutions will be selected.
<p>Let us define as &quot;length of a sequence&quot; the number of quintuples it contains (i.e. length = number of digits &#150; 4). Let us call a sequence &quot;acceptable&quot; if no two different quintuples in it present the same digit pattern. With these definitions the solutions are a subset of the set of acceptable sequences, viz. those with length = 32.<p>We do not know whether there are any solutions at all but we do
know that the set of acceptable sequences is non-empty (e.g. "00000");
we do not have a ready made criterion to recognize "the last solution"
when we encounter it, in our set of acceptable sequences, however, we
can designate a "virtual last one" (viz. "00001"): when that one is
encountered we know that all acceptable sequences with five zeros
leading have been scanned and that no further solutions will be found.
<p class="indentnovert">Summarizing, we know of the set of acceptable sequences
<p class="novert">1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;it is non-empty and finite<p class="novert">2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;we know a first member (&quot;00000&quot;)<p class="novert">3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;we know a virtual last member (&quot;00001&quot;)<p class="novert">4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;we can transfer an acceptable sequence into the next acceptable sequence<p class="novert">5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;solutions are all acceptable sequences (excluding the virtual one) satisfying the further condition &quot;length of sequence equals 32&quot;.
		<p>The transition from considering only the set of solutions to
considering the set of acceptable sequences seems to mark a step in
our analysis sufficiently relevant to justify that it be expressed in
our first refinement, a program in
 which all instructions operate upon (a still rather abstract) object, called &quot;sequence&quot;.
		<p class="noindent">Version 1:
		<p class="one">"set sequence to first acceptable one;
<p class="one"> 
			<rw>
				repeat
			</rw> <rw>if</rw> length of sequence equals 32 <rw>do</rw>
<p class="two"><rw>begin</rw> accept sequence as solution;
<p class="three">print solution
<p class="two"><rw>end</rw>;
<p class="two">transform sequence into next acceptable one
<p class="one"> 
			<rw>until</rw> sequence is (first or) virtual last member"

		<p>In explaining this program, two remarks seem appropriate.
<br>
			Remark 1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The final test &quot;sequence is (first or) virtual last member&quot; has to distinguish the virtual last member from all members excluding the first one, as the first one will not be subjected to the test. Basically there would be no objection to the first member being equal to the virtual last one (say: the empty sequence). The above freedom is expressed by putting &quot;first or&quot; within parentheses.
<br>
			Remark 2.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The statement &quot;accept sequence as solution&quot; may well puzzle the reader. It may turn out to be an empty statement. It is inserted to express that &quot;at the following semicolon&quot; the sequence is regarded as representing a solution. (One may think of it as extracting the 32 leading digits.)

		<p>The criterion "acceptable" has a further
important property:
<br>
			6) no extension of a sequence that is not acceptable
will be acceptable.

		<p class="novert">and it is this important property that will be exploited in the refinement of &quot;transform sequence into next acceptable one&quot;. As a direct consequence of property 6, the acceptability test need only be applied to so-called &quot;promising sequences&quot;, where a promising sequence is defined as a one-digit extension of an acceptable sequence. This leads to our next refinement
<br>
			&nbsp;</p>
		<p class="noindent"></p>
		<p class="noindent">transform sequence into next acceptable one:

		<p class="one">"transform acceptable sequence into next promising one;

		<p class="one"> 
			<rw>while</rw> promising sequence not acceptable <rw>do</rw>
<p class="two">transform promising sequence into next promising one;
<p class="one"> accept sequence as acceptable&quot;
<p>When we regard &quot;transform sequence into next acceptable one&quot; as an available primitive, the value of &quot;sequence&quot; as always acceptable; it is only in the interior of its dissection &#x2014;viz. at the semicolons of the above refinement&#x2014; that the current value of &quot;sequence&quot; is a promising sequence.
		<p>In view of the required alphabetical ordering "transform acceptable
sequence into next promising one" forms a new sequence equal to the
old one extended with a zero, while "transform promising sequence into
next promising one" forms a new sequence equal to the old one up to
and excluding the last zero, followed by a one, or more explicitly as
in the next refinement

		<p class="noindent">transform promising sequence into next promising one:

		<p class="one">"<rw>while</rw> sequence ends with a one <rw>do</rw> remove final
digit from sequence;
<p class="one"> replace final zero by a one&quot;.
		<p>In the above step-wise refinements we have focused our attention
upon the sequencing of the program. Now the time has come to introduce
more explicit the decisions as how the still rather abstract object
called "sequence" has to be represented.

		<p>We introduce an <rw>integer</rw> k and decide that k = length of the
sequence. Furthermore we introduce an <rw>integer</rw> <rw>array</rw> d[-3:33] to
represent the digits with

		<table border="0" width="100%">
<tr>
<td align="left" class="math">d[-3] d[-2].....d[k] representing the sequence.</td>
<td align="right">(1)</td>
</table>
		<p class="novert">Remark 1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>d[-3]</tt> through <tt>d[0]</tt> will be equal to zero.<p class="novert">Remark 2:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The maximum length of an acceptable sequence = 32; as the algorithm handles promising sequences and a promising sequence is a one-digit extension of an acceptable one, the maximum length of the sequence is 33.
		<p>The above conventions serve as a basis for the more explicit
statement of the property "acceptable". We have to characterize digit
patterns as presented by the quintuples contained in the current value
of the sequence. I propose to characterize such a digit pattern by the
integer value one gets when interpreting the digits of such a
quintuple as the digits of a binary number. In other words we define
the function H(i) for 1 &le; i &le; k

		<table border="0" width="100%">
<tr>
<td align="left" class="math"> H(i) = d[i-4]*16 + d[i-3]*8 + d[i-2]*4 + d[i-1]*2
+ d[i]</td>
<td align="right">(2)</td>
</table>
		<p>The property "acceptable" means that

		<table border="0" width="100%">
<tr>
<td align="left" class="math">for 1 &le; i, j &le; k, i &ne; j implies H(i) &ne;
H(j). 
<td align="right">(3)</td>
</table>
		<p>At each moment the function H(i) is defined on the current value
of sequence for 1 &le; i &le; k. Instead of recomputing these function
values whenever we need them (i.e. in the acceptability test) we can
tabulate them in an <rw>integer</rw> <rw>array</rw> h[1:33].

		<p>Our convention is that for all sequence values will hold

		<table border="0" width="100%">
<tr>
<td align="left" class="math">h[i] = H(i) for 1 &le; i &le; k.
<td align="right">(4)</td>
</table>
		<p>This convention implies that modifications of the value of sequence
in general includes updating of the array h in order to maintain
relation (4).

<p>The acceptability test is now -analogous to (3)- that for 1 &le; i,
j &le; k i &ne; j implies h[i] &ne; h[j].

		<p>Next we exploit the fact that the only sequences to be subjected to
the acceptability test are promising sequences, i.e. one-digit
extensions of an acceptable sequence. For a promising sequence we can
conclude that it is acceptable if and only if

		<table border="0" width="100%">
<tr>
<td align="left" class="math">h[i] &ne; h[k]  for 1 &le; i &lt; k
<td align="right">(5)</td>
</table>
		<p class="noindent">i.e. when the last quintuple presents a pattern
different from all the preceding ones.

		<p>This, again, would imply scanning, but we can repeat the trick and tabulate whether a certain digit pattern already occurs. The most elegant way is to produce a <u>boolean</u> <u>array</u> <tt>in[0:31]</tt> where for 0 &le; <tt>m</tt> &le; 31 <tt>in[m]</tt> means:
		<table border="0" width="100%">
			<tr>
<td align="left" class="math" valign="top">
					<table width="446" border="0" cellspacing="1" cellpadding="0">
						<tr>
							<td> for an acceptable sequence: m occurs among h[1]...h[k]</td>
						</tr>
						<tr>
							<td>for a promising sequence: m occurs among h[1]...h[k-1] </td>
						</tr>
					</table>
				
				
				
				<td align="right">(6)</td>
		</table>
		<p class="noindent"><rw>Note</rw>. When the sequence is acceptable,
each pattern can only be presented once and a boolean variable is
sufficient to record whether it occurs. In a promising sequence h[k]
may equal h[i] for i &lt; k; therefore convention 6 distinguishes
between acceptable and promising sequences.

		<p>We now give the final version of the program. What were names of
primitives now occur as labels (either of statements or expressions).

		<p class="zero"><rw>begin</rw> <rw>integer</rw> k; <rw>integer</rw> <rw>array</rw> d[-3:33];

		<p class="one"><rw>integer</rw> <rw>array</rw> h[1:33]; <rw>boolean</rw> <rw>array</rw> in[0:31];
  <p class="one">set sequence to first acceptable one:
  <p class="one"><rw>begin</rw> d[-3]:= d[-2]:= d[-1]:= d[0]:= d[1]:=
  0; k:=1;
    <p class="two">h[1]:= 0; in[0]:= true;
    <p class="two"><rw>begin</rw> <rw>integer</rw> m; m:= 1;
      <p class="three"><rw>repeat</rw> in[m]:= <rw>false</rw>; m:= m + 1 <rw>until</rw> m = 32
    <p class="two"><rw>end</rw>
  <p class="one"><rw>end</rw>;
  <p class="one"><rw>repeat</rw> <rw>if</rw> length of sequence equals 32: (k = 32)
  <rw>do</rw>
    <p class="two"><rw>begin</rw> accept sequence as solution: new line
  carriage return;
      <p class="three">print solution;
      <p class="three"><rw>begin</rw> <rw>integer</rw> m; m:= 0;
        <p class="four"><rw>repeat</rw> print(d[m-3]); m := m + 1 <rw>until</rw> m =
  32
      <p class="three"><rw>end</rw>
    <p class="two"><rw>end</rw>;
    <p class="two">transform sequence into next acceptable one:
    <p class="two"><rw>begin</rw> transform acceptable sequence into next
  promising one:
    <p class="three"><rw>begin</rw> k:= k + 1; d[k]:= 0;
      <p class="four">h[k]:= 2 * h[k-1] - 32 * d[k - 4]
    <p class="three"><rw>end</rw>; 
    <p class="three"><rw>while</rw> promising sequence non acceptable:
  (in[h[k]]) <rw>do</rw>
      <p class="four">transform promising sequence into next
  acceptable one:
          <p class="four"><rw>begin</rw> <rw>while</rw> sequence ends with a one:
  (d[k] = 1) <rw>do</rw> 
            <p class="five">remove final digit from sequence:
            <p class="five"><rw>begin</rw> k:= k - 1; in[h[k]]:= <rw>false</rw>
  <rw>end</rw>;
            <p class="five">replace final zero by a one:
	    <p class="five"><rw>begin</rw> d[k]:= 1; h[k]:= h[k] + 1 <rw>end</rw>
          <p class="four"><rw>end</rw>;
       <p class="three">accept sequence as acceptable: in[h[k]]:=
  <rw>true</rw>
     <p class="two"><rw>end</rw>
   <p class="one"><rw>until</rw> sequence is virtual last member: (k =
  1)

		<p class="zero"><rw>
				end
			</rw>
		<p class="indentnovert"><br>
			&nbsp;
		
		<p class="indentnovert">In explanation:
</p>
		<p class="novert">1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;accept sequence as solution&quot;, that could have been an empty statement has been given the meaning of transition to a new line<p class="novert">2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;accept sequence as acceptable&quot; has got contents, due to convention (6) where distinction is made between promising and acceptable sequences.
		<p class="head">Concluding Remarks.

		<p>We have shown successive program versions, leading from the
original problem statement to the final program. In our final program,
the merging of these successive versions has been done by hand and the
more abstract versions have been reduced to comment in the form of
labels.

		<p>For large programs this merging process itself becomes a major data
processing task and I expect the growth of interactive program
composition techniques in which the service of computers will be
enlisted for the benefit of this process.

		<p>Furthermore: at present the more abstract versions are only reflected as explanatory comment, inserted for human understanding. The origin of this is that we want at present a program formulated at a constant semantic level, viz. the level of the programming language. For the more abstract versions we have at present during run time no mechanical use. In future I expect the more abstract versions to be an integral part of the program.

		<p>Finally, we have considered only a single line of programs leading
from the problem statement to a working problem expressed at the
desired semantic level. In future I expect that this single line will
be extended to a more or less tree-structured class of programs in
which is also room for alternatives, thus structurely tying together
program composition and program modification.

		<p class="signature">Edsger W. Dijkstra 
<br>
Department of Mathematics
<br>
Technological University
<br>
P.O. Box 513
<br>
EINDHOVEN
<br>
The Netherlands</p>
<p>
		<p class="noindent">(This paper has been produced in relation to a talk given at the
University of Grenoble in December 1967.)

		<hr>
		<font size="-1">transcribed by Jordan Olsommer<br>
			revised <csobj format="MedDate" h="12" region="15" t="DateTime" w="105">Wed, 30 Nov 2005</csobj></font>
	</body>
</html></div>
  </body>
  </html>
