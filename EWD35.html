  <!DOCTYPE html>
  <html>
  <head>
    <title>Over de sequentialiteit van procesbeschrijvingen</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <link href="assets/tweet-selection.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.12.0.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="assets/tweet-selection.js"></script>
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: Over de sequentialiteit van procesbeschrijvingen" />
    <meta name="twitter:title" content="Over de sequentialiteit van procesbeschrijvingen" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>Over de sequentialiteit van procesbeschrijvingen</h1>
  <div class='body'>
				<p>Het is niet ongebruikelijk, wanneer een spreker zijn voordracht begint met een inleiding. Omdat ik mij hier mogelijk richt tot een gehoor, dat als geheel minder vertrouwd is met de problematiek, die ik wil aansnijden en de terminologie, die ik zal moeten gebruiken, wilde ik in dit geval ter introductie graag <em>twee</em> inleidingen houden, nl. een om de achtergrond van de problemen te schilderen en een tweede, om U een gevoel te geven voor de aard van de logische problemen, die wij tegen het lijf zullen lopen.</p>
				<p>Mijn eerste inleiding is een historische. Eerst moet ik U vertellen, wat U zich moet voorstellen bij een sequenti&euml;le procesbeschrijving. U kent allen dergelijke procesbeschrijvingen. Beschouw bv. de beschrijving van de constructie van de hoogtelijn uit het hoekpunt <var>C</var> van de driehoek <var>ABC</var>. Deze kan als volgt luiden:</p>
				<p class="noindent">1) trek de cirkel met middelpunt <var>A</var> en straal = <var>AC</var>; <br>
					
					2) trek de cirkel met middelpunt <var>B</var> en straal = <var>BC</var>; <br>
					3) trek de rechte, die bepaald is door de snijpunten van de onder 1) en 2) genoemde cirkels.</p>
				<p class="noindent">Dit is een beschrijving ten bate van iemand, wiens &quot;parate kennis&quot; de constructie van de hoogtelijn niet omvat; ten bate van hem is de constructie van de hoogtelijn opgebouwd uit een aantal handelingen van een beperkter repertoire, handelingen, die hij in de opgegeven volgorde, de een na de ander, dwz. sequentieel, kan uitvoeren. Het zal het oplettende lezertje niet ontgaan zijn, dat wij hierbij meer gespecificeerd hebben, dan strikt noodzakelijk: het is wel essentieel, dat handeling 3) pas uitgevoerd wordt, nadat handelingen 1) en 2) voltooid zijn, handelingen 1) en 2) hadden best in de omgekeerde volgorde plaats mogen vinden, sterker, een tekenaar. die twee passers tegelijkertijd bedienen kan, bij wijze van spreken met elke hand &eacute;&eacute;n, mag handelingen 1) en 2) simultaan uitvoeren. Maar deze vrijheid is in onze procesbeschrijving geheel onder tafel geraakt.</p>
				<p>Nu een numerieker voorbeeld, dat iets meer aansluit bij de denkwereld, waarin de straks te behandelen problemen actueel zijn geworden. Gegeven de waarden van de variabelen <var>a</var>, <var>b</var>, <var>c</var> en <var>d</var>, gevraagd te berekenen de waarde van de variabele x, bepaald door de formule &quot;<var>x</var>:=(<var>a</var>+<var>b</var>)*(<var>c</var>+<var>d</var>)&quot;. Wanneer het uitvoeren van deze waardetoekenning niet tot het primitieve repertoire van de rekenaar &#x2014;en denkt U nu langzamerhand maar aan de rekenmachine&#x2014; behoort, dan dient dit rekenvoorschrift uit elementairdere stappen opgebouwd te worden, bv.:</p>
				<p class="continue">1) bereken <var>t</var>1:= <var>a</var> + <var>b</var>; <br>
					
					2) bereken <var>t</var>2:= <var>c</var> + <var>d</var> , <br>
					
					3) bereken <var>x</var>:= <var>t</var>1 *<var> t</var>2.<br>
					
					 Dit rekenvoorschrift bevat precies dezelfde overbepaaldheid als onze hoogtelijn-constructie: de volgorde van de eerste twee stappen doet niet ter zake, zij zouden zelfs simultaan uitgevoerd kunnen worden.</p>
				<p>De bovenstaande procesbeschrijving is representatief voor de werkingswijze van meer klassieke rekenautomaten. Het repertoire van elementaire operaties is, omdat voor elke operatie speciale technische voorzieningen vereist zijn, eindig en om financi&euml;le redenen zelfs heel beperkt; deze machines danken hun enorme flexibiliteit aan het feit, dat willekeurig ingewikkelde algebra&iuml;sche expressies als boven ge&iuml;llustreerd uitgewerkt kunnen worden door een sequens van dergelijke elementaire operaties. Inhaerent aan deze sequenti&euml;le beschrijving van het proces is, dat men meer specificeert, dan strikt noodzakelijk. Dit heeft lange tijd niet gehinderd, maar in de laatste jaren is daar verandering in gekomen, en wel door twee oorzaken: verandering van de structuur van machines en de komst van een nieuwe klasse problemen, waarvoor men deze machines zou willen inzetten.</p>
				<p>De klassieke sequenti&euml;le machine doet &quot;een ding tegelijk&quot; en verricht de ene functie na de andere. Om der wille van de efficiency is: men voor specifieke functies meer specifieke apparatuur gaan bouwen, maar als je er dan aan vast houdt, dat de verschillende operaties strict sequentieel uitgevoerd zullen worden, dan dringt zich van een machine plotseling het beeld op van een samenspel van <var>N</var> organen, waarvan er op elk discreet ogenblik maar 1 of 2 werken. Als <var>N</var> groot is, betekent dit, dat het merendeel van je machine het merendeel van de tijd stilstaat en dat is kennelijk niet de bedoeling.</p>
				<p>De tweede oorzaak is de komst van een nieuwe categorie van problemen; oorspronkelijk werden rekenautomaten alleen gebruikt voor van te voren volledig gedefinieerde processen, en de machine kon het proces vervolgens op zijn eigen houtje, in zijn eigen tempo uitvoeren. Zodra men echter het informatieverwerkende proces samen wil laten spelen met een of ander ander proces &#x2014;bv. een chemisch proces, dat door de rekenautomaat gestuurd moet worden&#x2014; dan treden er heel andere problemen op. Aanhakend bij ons voorbeeld van de berekening van <var>x</var>:=(<var>a</var> + <var>b</var>)*(<var>c</var> + <var>d</var>) zijn we dan niet meer in de omstandigheid, dat het er niet meer toe doet, welke som het eerste gevormd wordt. Als de gegevens <var>a</var>,<var>b</var>,<var>c</var> en <var>d</var> op onbekende momenten door de omgeving van de rekenautomaat verschaft worden en het de taak van de machine is, om de waarde van <var>x</var> zo snel mogelijk af te leveren, dan betekent dit, dat de automaat een deelberekening maar vast uit moet voeren, zodra de daarvoor vereiste gegevens binnen zijn: welke optelling men dan eerst uitgevoerd wil hebben, zal afhangen van de volgorde, waarin de gegevens <var>a</var>, <var>b</var>, <var>c</var> en <var>d</var> ter beschikking komen. Dit was mijn eerste inleiding en ik hoop U hiermee een idee gegeven te hebben, van wat U zich bij een sequenti&euml;le procesbeschrijving voor moet stellen, en waarom de vraag gesteld is naar minder strict sequenti&euml;le procesbeschrijvingen.</p>
				<p>Nu mijn tweede inleiding, die bedoeld is om U van meet af aan enig idee te geven van de logische problemen, die we door het verlaten van de stricte sequentialiteit ons op de hals zullen halen.</p>
				<p>Evenals in een normaal stuk algebra variabelen met letters, algemeen &quot;namen&quot;, aangeduid worden, heeft men in het proces van informatieverwerking aanhoudend de plicht tot identificatie, de plicht om bij de naam het hierdoor benoemde object te vinden. Onder omstandigheden zou men graag willen beschikken over het selectieproces, waarover de juffrouw in de klas beschikt, wanneer zij zegt &quot;Jantje, kom eens voor het bord.&quot; Aangenomen, dat de klas als geheel oplet en gehoorzaam is, werkt dit proces feilloos onder de aanname, dat er 1 en slechts 1 Jantje in de klas zit. Het bijzondere van dit selectiemechanisme is, dat het werkt ongeacht het aantal kinderen in de klas. Deze idylle is helaas technisch niet of hoogstens gebrekkig te verwezenlijken, en wij krijgen een probleemstelling, die meer in overeenstemming is met de werkelijkheid, wanneer de kinderen niet spontaan op het noemen van hun naam reageren en de juffrouw, wanneer zij Jantje voor het bord wil hebben, genoodzaakt is om Jantje bij het oor te vatten en daaraan voor het bord te slepen. Als dit nu een ouderwetse school is, waarin ieder kind zijn vaste plaats in de klas heeft, dan kan de juffrouw, als zij aan het begin van het jaar de kinderen op hun plaats gezet heeft, ze voor haar eigen gemak herdopen, en de naam &quot;Jantje&quot; &#x2014;die voor het vinden van het jongetje niet erg behulpzaam is&#x2014; vervangen door een identificatie, die blijkens zijn structuur meteen definieert, welk oor ze vatten moet: ze kan het jongetje noemen &quot;derde rij, tweede bank&quot;. Dit is in wezen de techniek, die in klassieke automaten bij klassieke toepassingen gevolgd wordt. In modernere toepassingen kan men dit niet meer doen, en moet men bv. opgewassen zijn tegen de problemen, die de juffrouw krijgt, als de kinderen kunnen kiezen, waar ze gaan zitten.</p>
				<p>Om het de juffrouw niet onmogelijk te maken, nemen we aan dat elk der onwillige kinderen een naamplaatje opgespeld heeft. AIs de juffrouw nu Jantje voor het bord wil hebben, moet zij dus Jantje opzoeken. De juffrouw werkt sequentieel, kan slechts een naamplaatje tegelijkertijd lezen, en de juffrouw werkt systematisch: zij heeft voor zichzelf de banken op een of andere manier uniek geordend en als zij Jantje wil hebben, dan loopt zij de banken in deze volgorde af, zich steeds afvragend &quot;Ben jij Jantje?&quot;, zo nee, dan gaat ze naar de volgende bank. Dit proces werkt feilloos, mits wij kunnen garanderen, dat de kinderen tijdens de rondgang van de juffrouw niet gaan verzitten, mits wij kunnen garanderen, dat de twee processen &quot;kindlocalisatie&quot; en &quot;kinderpermutatie&quot; niet simultaan uitgevoerd worden. Want U begrijpt ook wel, dat Jantje, zodra hij door heeft, dat hij de gezochte figuur is, achter in de klas gaat zitten en zodra de juffrouw de voorste helft van de klas doorzocht heeft, springt hij gauw naar voren. Wij kunnen de juffrouw verfijnen en haar, als ze de hele klas doorzocht heeft en Jantje niet gevonden heeft met frisse moed van voren af aan laten beginnen, maar dit is geen oplossing, want Jantje springt dan gauw weer naar achteren. Nu zou U kunnen opmerken, dat als die permutaties nu niet met zoveel kwaadwilligheid, maar slechts random uitgevoerd werden, dat dan de verwachtingstijd voor het localiseren van Jantje eindig blijft, ja zelfs door zijn vrijheid rond te springen niet groter is geworden. Deze opmerking, hoe hoopvol, brengt geen soulaas. Zij die zich verdiept hebben in de &quot;Theory of computability&quot; weten hoeveel gewicht gehecht wordt aan een eindige, dwz. een gegarandeerd eindigende algorithme, en zij zullen begrijpen, dat een proces, dat potentieel oneindig lang doortolt, geen aantrekkelijk element is. Veel erger is, dat het in de praktijk veelal de vraag is, of wij de permutaties van de kinderen wel als random mogen beschouwen. Als de kans eindig is, dat als de juffrouw een keer door de klas geweest is, de kinderen weer precies zo zitten als toen de juffrouw begon te zoeken, dan kon dit best eens de eerste periode van een zuiver periodiek verschijnsel zijn.</p>
				<p>Maar zelfs als wij het risico, dat we Jantje nooit zullen vinden voor lief nemen, dan nog is haar ellende niet te overzien, want naast het risico, dat ze Jantje niet vindt, loopt ze het veel grotere gevaar, dat ze het verkeerde kind voor het bord sleurt, nl. als de kinderen tussen het moment, dat zij voldaan geconstateerd heeft &quot;Zo, jij ben dus Jantje&quot; en het moment, dat zij, op grond van deze constatering haar hand naar het bijbehorend oor heeft uitgestoken, nog gauw van plaats verwisselen. In een informatieverwerkend proces zou dit neerkomen op een ramp. En dit is het einde van mijn tweede inleiding, waarvan ik hoop, dat zij U enig idee gegeven heeft van het soort probleem, dat wij tegen zullen komen.</p>
				<p>Aan het einde van mijn eerste inleiding heb ik twee oorzaken genoemd, die voor een groeiende belangstelling in minder strict sequenti&euml;le procesbeschrijvingen verantwoordelijk waren. Ik heb ze slechts luchtig aangestipt en het is U misschien niet opgevallen, dat ze aan bijna tegengestelde entourages ontleend waren. In het eerste geval noemde ik de toenemende complexiteit van machines, die nu opgebouwd zijn uit een aantal min of meer autonoom werkende onderdelen en de opgave was, om deze samen &eacute;&eacute;n proces uit te laten voeren. In het tweede geval, waar we de automaat in een z.g. &quot;real time application&quot; bekeken, werd het beeld opgeroepen van &eacute;&eacute;n enkel apparaat, dat de mogelijkheid had bij een verandering van de externe urgentiesituatie over te schakelen op het nu urgentste van zijn mogelijke taken. Deze twee arrangementen, een samenspel van een aantal machines aan &eacute;&eacute;n proces en omgekeerd, &eacute;&eacute;n machine zijn aandacht verdelend over een aantal processen, zijn lange tijd als elkaar wezensvreemd beschouwd. Men heeft er zelfs verschillende namen voor uitgevonden, het ene noemt men &quot;parallel programming&quot; en het andere noemt men &quot;multiprogramming maar U moet mij niet meer vragen wat wat, want dat kan ik niet meer onthouden, sinds ik ontdekt heb dat de logische problemen, die zij door de non-sequentialiteit van de procesdefinitie oproepen, in beide gevallen exact dezelfde zijn.</p>
				<p>Ik zal mij in het volgende bedienen van het beeld van een aantal, onderling zwak gekoppelde, op zichzelf sequenti&euml;le machines, daarbij aansluitend op de eerste entourage. Maar dit is slechts een beschrijvingswijze, want met wat ik in het vervolg een machine zal noemen komt niet noodzakelijkerwijze een discreet aanwijsbaar stuk apparatuur overeen: in het volgende zijn mijn onderscheiden machines mogelijk heel abstract en representeren zij niet meer dan een opzichzelf sequentieel deelproces. Dit komt onder andere daarin tot uiting, dat ik een grote voorliefde zal tonen voor een samenspel van <var>N</var> machines, <var>N</var> willekeurig. Als ik de term machine alleen maar bezigde voor een aanwijsbaar functioneel stuk apparatuur, dan zou ik het aantal machines voor elke installatie als vrij constant mogen beschouwen. Nu echter een machine, als personifi&euml;ring van een opzichzelf sequenti&euml;le deeltaak, door de gebruiker ad libitum gecre&euml;erd kan worden, is een dergelijke vaste bovengrens niet meer acceptabel. Ik ga dus praten over het samenspel van <var>N</var> machines, <var>N</var> niet alleen willekeurig, maar als het moet zelfs tijdens het proces variabel. Overtollige machines kunnen vernietigd worden, nieuwe machines kunnen naar behoefte er bij gecre&euml;erd worden en in het samenspel der overigen worden opgenomen. Ik hoop, dat U thans op mijn gezag wilt aannemen, danwel na afloop zelf inziet, dat wij ons zonder de algemeenheid te schaden kunnen beperken tot sequenti&euml;le machines, die een of ander cyclisch proces uitvoeren.</p>
				<p>Laat ons beginnen met een heel eenvoudig probleem. Gegeven twee machines <var>A</var> en <var>B</var>, beide bezig met een cyclisch proces. In de cyclus van machine <var>A</var> komt een zeker critisch traject voor, <var>TA</var> genaamd, en in die van machine <var>B</var> komt een critisch traject <var>TB</var> voor. De opgave is om er voor te zorgen, dat nooit gelijktijdig de beide machines elk aan hun critische traject bezig zijn. (In termen van onze tweede inleiding: machine <var>A</var> zou kunnen zijn de juffrouw, traject <var>TA</var> het selectieproces van een nieuwe leerling, die voor het bord gehaald moet worden, terwijl het traject <var>TB</var> het proces &quot;kinderpermutatie&quot; representeert.) Er mogen geen veronderstellingen gemaakt worden over de relatieve snelheden der machines <var>A</var> en <var>B</var>, de snelheid, waarmee zij werken hoeft zelfs niet constant te zijn. Het is duidelijk, dat wij de wederzijdse uitsluiting van het critische traject slechts kunnen realiseren, als de twee machines op een of andere manier met elkaar kunnen communiceren. Voor deze communicatie stellen wij enig gemeenschappelijk geheugen ter beschikking, dwz. een aantal variabelen, die voor beide machines in beide richtingen toegankelijk zijn, dwz. waaraan beide machines een waarde kunnen toekennen en waarvan beide machines naar de heersende waarde kunnen informeren. Deze twee handelingen, toekennen van een nieuwe waarde en informeren naar de heersende waarde gelden als ondeelbare handelingen, dwz. als beide machines &quot;tegelijkertijd&quot; een waarde aan een gemeenschappelijke variabele willen toekennen, dan is de waarde na afloop of de ene, of de andere toegekende waarde, maar niet een of ander mengsel. Evenzo: als de ene machine informeert naar de waarde van een gemeenschappelijke variabele op het moment, dat de andere machine er een nieuwe waarde aan toekent, dan dringt tot de vragende machine of de oude, of de nieuwe, maar niet een wilde waarde door. Het zal blijken, dat we ons voor dit doel kunnen beperken tot gemeenschappelijke logische variabelen, dwz. variabelen met slechts twee mogelijke waarden, die we in aansluiting op standaardtechnieken met &quot;<b>true</b>&quot; respectievelijk &quot;<b>false</b>&quot; aangeven. Voorts nemen wij aan, dat beide machines slechts naar 1 gemeenschappelijke variabele tegelijkertijd kunnen refereren, en dan ook alleen of om een nieuwe, waarde toe te kennen of om naar de heersende waarde te informeren. In figuur 1 is in blokschemavorm een tentatieve oplossing gegeven voor de structuur van de programma's voor beide machines. Elk blok heeft zijn ingang boven en zijn uitgang onder. Bij een blok met een dubbele uitgang wordt de keuze bepaald door de waarde van de zojuist aangevraagde logische variabele: heeft deze de waarde <b>true</b>, dan is de uitgang rechtsonder bedoeld, heeft deze de waarde <b>false</b>, dan kiezen we de uitgang linksonder.</p>
				<p>Er komen in dit schema twee gemeenschappelijke logische variabelen voor, <var>LA</var> en <var>LB</var>. <var>LA</var> betekent: machine <var>A</var> is in zijn critische sectie, <var>LB</var> betekent: machine <var>B</var> is in zijn critische sectie. De schema's in fig 1 zijn duidelijk. In het blok bovenaan wacht machine <var>A</var> indien hij daar aankomt op een ogenblik, dat machine <var>B</var> in sectie <var>TB</var> bezig is, totdat machine <var>B</var> zijn critische traject heeft verlaten, wat door de toekenning &quot;<var>LB</var>:= <b>false</b>&quot; gemarkeerd wordt, waardoor dan de wacht van machine <var>A</var> wordt opgeheven. En omgekeerd. De schema's mogen dan eenvoudig zijn, ze zijn helaas ook fout, want ze zijn wat te optimistisch: ze sluiten nl. niet uit, dat beide machines tegelijkertijd in hun respectievelijke critische trajecten terecht komen. Als, beide machines buiten hun critische traject zijn &#x2014;zeg ergens in het blanco gelaten blok&#x2014; dan zijn zowel <var>LA</var> als <var>LB</var> <b>false</b>. Komen ze nu tegelijkertijd in hun bovenste blok, dan vinden ze beide, dat de andere machine hen geen strobreed in de weg legt, en ze gaan beide door en komen tegelijkertijd in hun critische sectie.</p>
				<p><img src="EWD35fig.1.gif" alt="" width="90%" border="0"></p>
				<p>We zijn dus wat te optimistisch geweest. De fout is geweest, dat de ene machine niet wist, of de ander al naar zijn staat van vordering informeerde. De schema's van fig.2 maken een veel betrouwbaardere indruk en het is gemakkelijk te verifi&euml;ren, dat zij volslagen veilig zijn. Bv. machine <var>A</var> kan slechts aan traject <var>TA</var> beginnen, nadat tijdens het <b>true</b>-zijn van <var>LA</var> geconstateerd is, dat <var>LB</var> <b>false</b> is, en ongeacht hoe snel na deze kennis van machine <var>A</var> dit feit weer obsoleet wordt, doordat machine B gauw zijn bovenste blok &quot;<var>LB</var>:= <b>true</b>&quot; uitvoert, machine <var>A</var> kan dan veilig traject <var>TA</var> ingaan, omdat machine <var>B</var> toch netjes opgehouden wordt totdat <var>LA</var> na afloop van traject <var>TA</var> op <b>false</b> gezet wordt. Deze oplossing is dus volkomen veilig, maar we moeten niet denken, dat we hiermee het probleem opgelost hebben, want deze oplossing is te veilig, er bestaat nl. de kans, dat het hele samenspel van deze machines vastloopt. Als zij tegelijkertijd het bovenste blok van hun schema uitvoeren, dan lopen beide machines in de daarop volgende wacht en blijven tot in eeuwigheid van dagen beleefd voor dezelfde deur staan, zeggende &quot;Na U&quot; ,&quot;Na U&quot;. We zijn te pessimistisch geweest.</p>
				<p><img src="EWD35fig.2.gif" alt="" width="90%" border="0"></p>
				<p>U ziet, dat het probleem niet triviaal is. Het was mij althans, na deze twee probeersels, helemaal niet zonneklaar, dat er een veilige oplossing bestond, die niet tevens de mogelijkheid van een doodlopende weg in zich hield. Ik heb het probleem toen in deze vorm aan mijn toenmalige collegae van de Rekenafdeling van het Mathematisch Centrum voorgelegd, er bij vertellend, dat ik niet wist, of het oplosbaar was. Aan Dr. T.J. Dekker komt de eer toe als eerste een oplossing gevonden te hebben, die bovendien symmetrisch in de beide machines was. Deze oplossing is weergegeven in fig. 3. Er is een derde logische variabele ingevoerd, nl. <var>AP</var>, die betekent, dat in geval van twijfel machine <var>A</var> prioriteit heeft. Door de asymmetrische betekenis van deze logische variabele zijn gedeelten van deze programma's min of meer elkaars spiegelbeeld, functioneel is de oplossing echter helemaal symmetrisch en is niet de ene machine bevoorrecht boven de ander. Om te bewijzen, dat deze oplossing aan de gestelde eisen voldoet, constateren we eerst, dat de trajecten <var>TA</var> en <var>TB</var> voorafgegaan worden door de sluis, die we in figuur 2 al als veilig herkend hebben. Simultane uitvoering is dus onmogelijk. We hoeven slechts te verifi&euml;ren, dat het nu bovendien uitgesloten is, dat beide machines voor hun critische sectie blijven wachten. In deze wachtcycli wordt de waarde van <var>AP</var> niet gewijzigd. Beperken we ons tot het geval, dat <var>AP</var> <b>true</b> is, dan kan machine <var>A</var> slechts blijven cyclen als ook <var>LB</var> <b>true</b> is; onder de voorwaarde <var>AP</var> <b>true</b> kan machine <var>B</var> echter alleen rond blijven lopen in de cyclus, die <var>LB</var> op <b>false</b> zet, dwz. machine <var>A</var> uit zijn cyclus forceert. In het geval <var>AP</var> <b>false</b> verloopt de analyse op dezelfde manier. Omdat <var>AP</var> als logische variabele of <b>true</b> of <b>false</b> is, is daarmee de mogelijkheid van eeuwig op elkaar blijyen wachten eveneens uitgesloten. Q.E.D.</p>
				<p><img src="EWD35fig.3.gif" alt="" width="90%" border="0"></p>
				<p>Dekker's oplossing dateert uit 1959 en bijna drie jaar heeft deze oplossing voortgeleefd als &quot;curiositeit&quot;, totdat dit soort problematiek aan het begin van 1962 voor mij plotseling weer actueel werd en Dekker's oplossing als uitgangspunt van mijn volgende pogingen gefungeerd heeft.</p>
				<p>De probleemstelling was inmiddels wel drastisch veranderd. In 1959 was het de vraag of de beschreven communicatiemogelijkheid tussen twee machines het mogelijk maakte om twee machines zodanig te koppelen, dat de uitvoeringen van de critische trajecten elkaar in de tijd wederzijds uitsloten. In 1962 werd een veel wijdere groep problemen bekeken en werd bovendien de vraagstelling veranderd in &quot;Welke communicatiemogelijkheden tussen machines zijn gewenst, om dit soort spelletjes zo sierlijk mogelijk te spelen?&quot;</p>
				<p>Dekker's oplossing heeft op verschillende manieren als uitgangspunt gefungeerd. Omdat het in deze oplossing onduidelijk is, hoe men te werk moet gaan, wanneer het aantal machines uitgebreid wordt, en de opgave blijft om te garanderen, dat er op elk moment hoogstens 1 critische sectie onder behandeling is, was zij een aansporing om naar andere wegen te zoeken. Door een analyse van de moeilijkheden, die Dekker moest overwinnen, konden wij een aanwijzing krijgen wat een hoopvollere weg zou zijn om in te slaan.</p>
				<p>De moeilijkheden ontstaan, doordat als een van de machines geinformeerd heeft naar de waarde van een gemeenschappelijke logische variabele, deze informatie onmiddellijk daarna al weer obsoleet kan zijn, nog voordat de informerende machine er effectief op gereageerd heeft, in het bijzonder: nog voordat de informerende machine aan zijn partners heeft kunnen meedelen, dat hij van de waarde van een gemeenschappelijke variabele. &quot;een momentopname gemaakt heeft&quot;. De hint, die uit deze bespiegeling gehaald kan worden, is dat men moet zoeken naar machtigere &quot;elementaire&quot; operaties op de gemeenschappelijke variabelen, in het bijzonder naar operaties, waarin voor de informatietransport tussen machine en gemeenschappelijk geheugen niet meer de beperking van het &eacute;&eacute;nrichtingverkeer geldt.</p>
				<p>De meestbelovende operatie, die we hebben kunnen bedenken, is de operatie &quot;<var>falsify</var>&quot;. Deze informeert naar de waarde van een logische variabele en het feit, dat deze operatie is uitgevoerd wordt in de helft van de gevallen kenbaar gemaakt: de operatie falsify laat de logische variabele, waarop hij geopereerd heeft nl. met de waarde &quot;<b>false</b>&quot; achter.</p>
				<p>De operatie &quot;<var>falsify</var>&quot; kan als volgt gedefinieerd worden:</p>
				<p class="noindent">&quot;<b>boolean</b> <b>procedure</b> <var>falsify</var>(<var>S</var>); <b>boolean</b> <var>S</var>;</p>
				<p class="nospace"><b>begin</b> <b>boolean</b> <var>Q</var>; <var>falsify</var>:= <var>Q</var>:= <var>S</var>; <b>if</b> <var>Q</var> <b>then</b> <var>S</var>:= <b>false</b> <b>end</b>&quot; ,</p>
				<p class="noindent">mits we hierbij vermelden, dat de operatie <var>falsify</var>, in weerwil van zijn sequenti&euml;le definitie, beschouwd moet worden als elementaire opdracht van het repertoire der machines, waarbij &quot;elementair&quot; in dit geval betekent, dat gedurende de operatie falsify door &eacute;&eacute;n van de machines de logische variabele in kwestie ontoegankelijk is voor alle andere machines.</p>
				<p>Dat deze operatie een stap in de goede richting is, volgt wel uit het feit, dat we nu meteen de oplossing hebben voor een wolkje machines <var>X</var><sub>1</sub>, <var>X</var><sub>2</sub>, <var>X</var><sub>3</sub>, ..... , elk met zijn critisch traject <var>TX<sub>i</sub></var>, die elkaar nu alle in de tijd moeten uitsluiten. We kunnen dit spelen met 1 gemeenschappelijke logische variabele, zeg <var>SX</var> die aangeeft, dat geen van de machines in zijn critische traject bezig is. De programma's vertonen nu alle dezelfde structuur:</p>
				<p class="noindent">&quot;<var>LX<sub>i</sub></var>: <b>if</b> <b>non</b> <var>falsify</var>(<var>SX</var>) <b>then</b> <b>goto</b> <var>LX<sub>i</sub></var>; <var>TX<sub>i</sub></var>; <var>SX</var>:= <b>true</b>; <var>proces X<sub>i</sub></var>; <b>goto</b> <var>LX<sub>i</sub></var>&quot;</p>
				<p class="noindent">waarbij we de aandacht er op vestigen, dat in de programma's voor de aparte machines <var>X<sub>i</sub></var> nergens tot uiting komt, hoeveel machines <var>X<sub>i</sub></var> er eigenlijk zijn: we kunnen dus door loutere toevoeging het wolkje machines <var>X<sub>i</sub></var> uitbreiden.</p>
				<p>Het geprogrammeerde wachtcyclusje, dat hierin voorkomt, is natuurlijk heel aardig, maar het beantwoordt wat weinig aan ons doel. Een wachtcyclusje is immers de manier om een machine &quot;zonder effect&quot; bezig te houden. Maar als we nu bedenken, dat het merendeel van deze machines door een centrale computer gesimuleerd zal worden, zodat elke actie in de ene machine slechts plaats kan vinden ten koste van de effectieve snelheid van de andere machines, dan is het wel erg begrotelijk om in een wachtcyclusje aandacht van de centrale computer op te gaan eisen voor iets volslagen nutteloos. Zolang het wachtcyclusje niet verlaten kan worden, mag wat ons betreft de snelheid van deze wachtende machine tot nul zakken, Om dit tot uitdrukking te brengen voeren we in plaats van het wachtcyclusje een statement in, een elementaire opdracht van het repertoire van de machines, die heel heel lang kan duren. We geven dit aan met een P (van Passering); vooruitlopend op latere behoeften representeren we de statement &quot;<var>SX</var>:= <b>true</b>&quot; door &quot;V(<var>SX</var>) -met de V van Vrijgave. (Deze terminologie is ontleend aan het spoorwegwezen: in een eerder stadium heetten de gemeenschappelijke logische variabelen &quot;Seinpalen&quot; en als hun naam met een <var>S</var> begint, dan is dat nog een reminiscentie daaraan.) De text van de programma's luidt in deze nieuwe notatie:</p>
				<p class="noindent">&quot;<var>LX<sub>i</sub></var>: P(<var>SX</var>); <var>TX<sub>i</sub></var>; V(<var>SX</var>); <var>proces</var> <var>X<sub>i</sub></var>; <b>goto</b> <var>LX<sub>i</sub></var>&quot; .</p>
				<p>De operatie P is een tentatieve passering. Het is een operatie, die slechts be&euml;indigd kan worden op een moment, dat de er bij opgegeven logische variabele de waarde <b>true</b> heeft, beindiging van de operatie P houdt tevens in, dat aan de logische variabele in kwestie weer de waarde <b>false</b> wordt toegekend. Operaties P kunnen wel simultaan plaatsvinden, het beindigen van een P-operatie wordt echter weer beschouwd als een ondeelbare gebeurtenis.</p>
				<p>De invoering van de operatie V is meer dan een verkorte schrijfwijze invoeren. Immers: toen wij het wachtcyclusje met behulp van de operatie falsify nog hadden, rustte de detectieplicht ten aanzien van het gelijk <b>true</b> worden van de gemeenschappelijke logische variabelen op de individuele machines, die op deze gebeurtenis stonden te wachten en in die zin was het wachten een tamelijk actieve bezigheid op een betrekkelijk neutrale gebeurtenis. Met de invoering van de P-operatie hebben wij zo ongeveer bereikt, dat wij tegen een machine, die voorlopig niet verder kan, zeggen: &quot;Ga maar slapen, we maken je wel weer wakker, als je verder mag.&quot; Maar dit betekent, dat het op <b>true</b> zetten van een gemeenschappelijke logische variabele, waarop misschien een machine staat te wachten, niet meer een neutrale gebeurtenis is als ieder andere waardetoekenning: hier kan nl. het neveneffect aan verbonden moeten worden, dat een van de &quot;slapende&quot; machines &quot;gewekt&quot; moet worden. Het betekent, dat de logische variabelen, die gedurende <b>false</b>-zijn &eacute;&eacute;n of meer machines op kunnen houden, niet permanent geobserveerd hoeven te worden, mits bij overgang naar de waarde <b>true</b> een &quot;centrale wekker&quot; op deze overgang attent gemaakt kan worden. Als de centrale wekker per gemeenschappelijke logische variabele een administratie bij houdt, welke machines op elke logische variabele op het ogenblik wachten, dan kan de centrale wekker, mits deze expliciet op het <b>true</b> worden van een dergelijke gemeenschappelijke logische variabele geattendeerd wordt, snel decideren, of er op grond van deze overgang een slapende machine gewekt kan worden en zo ja welke. De operatie V kan nu opgevat worden als een combinatie van het toekennen van de waarde <b>true</b> aan een seinpaal, plus het attenderen van de centrale wekker op deze gebeurtenis. Het is duidelijk, dat deze centrale wekker zijn werk niet kan doen, als we toestaan, dat de gemeenschappelijke logische variabelen ook nog, door normale waardetoekenningen (van het neutrale type &quot;<var>S</var>:= <b>true</b>&quot;), &quot;stiekem&quot;, ondershands gewijzigd kunnen worden. Om dit verbod te onderstrepen, noem ik de gemeenschappelijke logische variabelen van nu af aan &quot;seinpalen&quot; en stel ik, dat de enige mogelijkheid, waarop een machine met een bestaande seinpaal zal kunnen communiceren, zal zijn de P-operatie en de V-operatie.</p>
				<p>En hiermede is de operatie &quot;<var>falsify</var>&quot;, die ons door de aantrekkelijkheid van zijn eenvoud bij de begripsvorming zo behulpzaam is geweest, weer van het toneel verdwenen en de vraag is gerechtvaardigd, of we door de introductie van de seinpaal, die slechts via de operaties P en V toegankelijk is, het kind niet met het badwater hebben weggegooid. Dit is gelukkig niet het geval. Door de operatie &quot;falsify&quot; van het elementaire repertoire van de onderscheiden machines af te voeren en daar de operaties P en V voor in de plaats te geven, hebben wij niets verloren: wil de invoering van de operaties P en V niet een lege geste zijn, dan moet er dus minstens 1 seinpaal zijn, waarop zij kunnen werken. Deze ene seinpaal &#x2014;noem hem &quot;<var>SG</var>&quot;, de Seinpaal Generaal&#x2014; is echter al voldoende om de operatie falsify op een willekeurige gemeenschappelijke logische variabele toe te voegen aan het repertoire van alle machines. Immers:</p>
				<p class="noindent">Als wij in elke machine defini&euml;ren:</p>
				<p class="noindent">&quot;<b>boolean</b> <b>procedure</b> <var>falsify</var>(<var>GB</var>); </p>
				<p class="continue"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;boolean</b> <var>GB</var>; </p>
				<p class="nospace"><b>begin</b> <b>boolean</b> <var>Q</var>; </p>
				<p class="nospace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P(<var>SG</var>); <var>falsify</var>:= <var>Q</var>:= <var>GB</var>; </p>
				<p class="nospace"><b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if</b> <var>Q</var> <b>then</b> <var>GB</var>:= <b>false</b>; V(<var>SG</var>) </p>
				<p class="nospace"><b>end</b>&quot;</p>
				<p class="noindent">en wij voorts afspreken, dat elke referentie naar een gemeenschappelijke logische variabele in elke machine ingekapseld zal worden tussen de statements &quot;P(<var>SG</var>)&quot; en &quot;V(<var>SG</var>)&quot; (zodat de assignment &quot;<var>GB</var>1:= <b>true</b>&quot; nu de vorm zal hebben &quot;P(<var>SG</var>); <var>GB</var>1:= <b>true</b>; V(<var>SG</var>)&quot;, dan hebben wij hiermee verzekerd dat aan de bijvoorwaarde voldaan is, dat &quot;gedurende de operatie falsify door &eacute;&eacute;n van de machines de logische variabele in kwestie ontoegankelijk is voor alle andere machines.&quot; We hebben met de ruil dus niet in eigen vlees gesneden.</p>
				<p>Wij gaan nu laten zien, dat de operaties P en V in hun toepassingsgebied niet beperkt zijn tot wederzijdse uitsluiting, maar dat we ze ook kunnen gebruiken, om twee machines ten opzichte van elkaar te synchroniseren. Stel, dat wij twee cyclische machines hebben, zeg <var>X</var> en <var>Y</var>, die elk in hun cyclus 'n critische sectie hebben, zeg <var>TX</var> resp. <var>TY</var>, waarbij de volgende eisen gesteld zijn: </p>
				<p class="continue">1) de uitvoering van de critische sectie <var>TX</var> mag in de tijd niet samenvallen met die van <var>TY</var>; </p>
				<p class="continue">2) de uitvoeringen van de secties <var>TX</var> en <var>TY</var> moeten alternerende gebeurtenissen zijn (op deze voorwaarde doelden we, toen we spraken van &quot;onderlinge synchronisatie&quot;).</p>
				<p>Als U zich een entourage wilt voorstellen, waarin men voor dit probleem gesteld wordt, denkt U dan maar aan het volgende. Proces <var>X</var> is een cijferproducerend proces (een rekenproces), proces <var>Y</var> is een cijferconsumerend proces (een schrijfmachine) en deze twee processen zijn gekoppeld door een &quot;toonbank&quot; met de capaciteit van &eacute;&eacute;n cijfer. De handeling <var>TX</var> is het neerleggen van het volgende te typen cijfer op een lege toonbank, het stuk <var>TY</var> representeert het afnemen van het cijfer van de volle toonbank. De stricte alternering vloeit voort uit de eis dat enerzijds geen enkel aan de toonbank aangeboden cijfer &quot;weg mag raken&quot; maar inderdaad getypt moet worden, en dat anderzijds -als er een tijdje geen aanbod is- de schrijfmachine niet zijn tijd moet gaan vullen met het nog maar eens typen van het laatste cijfer.</p>
				<p>Wij kunnen dit bereiken met twee seinpalen, zeg <var>SX</var> en <var>SY</var>, waarbij: <var>SX</var> betekent, dat nu eerst een sectie <var>TX</var> aan de beurt is, en <var>SY</var> betekent, dat er nu eerst een sectie <var>TY</var> aan de beurt is. Voor machines <var>X</var> en <var>Y</var> luiden de programma's nu:</p>
				<p class="noindent">&quot;<var>LX</var>: P(<var>SX</var>); <var>TX</var>; V(<var>SY</var>); <var>proces</var> <var>X</var>; <b>goto</b> <var>LX</var>&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; en</p>
				<p class="continue">&quot;<var>LY</var>: P(<var>SY</var>); <var>TY</var>; V(<var>SX</var>); <var>proces</var> <var>Y</var>; <b>goto</b> <var>LY</var>&quot; &nbsp;&nbsp;&nbsp;.</p>
				<p>Wij kunnen dit direct op twee verschillende manieren uitbreiden. Indien wij de machine <var>X</var> vervangen door een wolkje machines <var>X<sub>i</sub></var>, die allemaal van dezelfde toonbank gebruik willen maken om hun productie te lozen, en de machine <var>Y</var> vervangen door een wolkje machines, die allemaal bereid zijn, om informatie van de toonbank af te nemen (ongeacht, door welke van de machines <var>X<sub>i</sub></var> het er op is gelegd, het beeld van de schrijfmachines gaat hier dus niet meer op), dan luiden de programma's voor machines <var>X<sub>i</sub></var> en <var>Y<sub>j</sub></var> analoog aan de boven gegeven programma's:</p>
				<p class="noindent">&quot;<var>LX<sub>i</sub></var>: P(<var>SX</var>); <var>TX<sub>i</sub></var>; V(<var>SY</var>); <var>proces</var> <var>X<sub>i</sub></var>; <b>goto</b> <var>LX<sub>i</sub></var>&quot; &nbsp;&nbsp;&nbsp;&nbsp;en</p>
				<p class="continue">&quot;<var>LY<sub>j</sub></var>: P(<var>SY</var>); <var>TY<sub>j</sub></var>; V(<var>SX</var>); <var>proces</var> <var>Y</var><sub>j</sub>; <b>goto</b> <var>LY<sub>j</sub></var>&quot;&nbsp;&nbsp;&nbsp; .</p>
				<p class="noindent">Hadden we ook nog een groepje machines <var>Z<sub>k</sub></var> gehad, en was de opgave geweest, dat de uitvoering van een <var>TX</var>-sectie, een <var>TY</var>-sectie en een <var>TZ</var>-sectie elkaar in die volgorde cyclisch moesten opvolgen, dan hadden de programma's geluid:</p>
				<p class="noindent">&quot;<var>LX<sub>i</sub></var>: P(<var>SX</var>); <var>TX<sub>i</sub></var>; V(<var>SY</var>); <var>proces X<sub>i</sub></var>; <b>goto</b> <var>LX<sub>i</sub></var>&quot; &nbsp;&nbsp;&nbsp;&nbsp;en</p>
				<p class="continue">&quot;<var>LY<sub>j</sub></var>: P(<var>SY</var>); <var>TY<sub>j</sub></var>; V(<var>SZ</var>); <var>proces</var> <var>Y<sub>j</sub></var>; <b>goto</b> <var>LY<sub>j</sub></var>&quot;&nbsp;&nbsp;&nbsp;&nbsp; en</p>
				<p class="continue">&quot;<var>LZ<sub>k</sub></var>: P(<var>SZ</var>); <var>TZ<sub>k</sub></var>; V(<var>SX</var>); <var>proces</var> <var>Z<sub>k</sub></var>; <b>goto</b> <var>LZ<sub>k</sub></var>&quot; &nbsp;&nbsp;.</p>
				<p class="noindent">Wij merken hierbij op, dat in de laatste twee voorbeeldjes de machines <var>X<sub>i</sub></var> gelijk zijn: zij representeren uitsluitend, dat de handelingen <var>TX</var> ergens door ge&iuml;nterspati&euml;erd moeten worden, zij laten in het midden, hoe complex deze tussenliggende handelingen gerealiseerd zullen worden.</p>
				<p>Een volgende opgave moge aantonen, dat onze operaties P en V in hun huidige vorm nog niet helemaal machtig genoeg zijn. Wij beschouwen daartoe de volgende configuratie. We hebben twee machines <var>A</var> en <var>B</var>, elk met hun critische sectie <var>TA</var> respectievelijk <var>TB</var>; deze secties zijn volledig onafhankelijk van elkaar, maar er is nog een derde machine <var>C</var> in het spel met zijn critische sectie <var>TC</var> en de uitvoering van <var>TC</var> mag in de tijd niet samen vallen met die van <var>TA</var>, noch met die van <var>TB</var>. We kunnen dit doen met twee seinpalen zeg: <var>SA</var> en <var>SB</var>. Voor machines <var>A</var> en <var>B</var> is het programma eenvoudig, nl.</p>
				<p class="noindent">&quot;<var>LA</var>: P(<var>SA</var>); <var>TA</var>; V(<var>SA</var>); <var>proces</var> <var>A</var>; <b>goto</b> <var>LA</var>&quot; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;en</p>
				<p class="continue">&quot;<var>LB</var>: P(<var>SB</var>); <var>TB</var>; V(<var>SB</var>); <var>proces</var> <var>B</var>; <b>goto</b> <var>LB</var>&quot; ,</p>
				<p class="noindent">maar voor machine <var>C</var> is het volgende programma. hoewel veilig, onacceptabel:</p>
				<p class="noindent">&quot;<var>LC</var>: P(<var>SA</var>); P(<var>SB</var>); <var>TC</var>; V(<var>SB</var>); V(<var>SA</var>); <var>proces</var> <var>C</var>; <b>goto</b> <var>LC</var>&quot; .</p>
				<p class="noindent">Immers: machine <var>C</var> zou de statement P(<var>SA</var>) succesvol voltooid kunnen hebben op een moment, dat machine <var>B</var> in sectie <var>TB</var> bezig is. Zolang sectie <var>TB</var> nu nog niet voltooid is, kan machine <var>C</var> niet verder &#x2014;dat is correct&#x2014; maar ook machine <var>A</var> kan zijn sectie <var>TA</var> niet meer uitvoeren en dat is niet correct: indirect, via machine <var>C</var> zijn hier de secties <var>TA</var> en <var>TB</var> toch weer gekoppeld. Door de operatie P(<var>SA</var>) van machine <var>C</var> is de seinpaal <var>SA</var> overhaast op <b>false</b> gezet, daarmee machine <var>A</var> onnodig hinderend.</p>
				<p>Wij gaan daarom de operaties P en V uitbreiden tot operaties, die we een willekeurig aantal argumenten mee kunnen geven &#x2014;daarmee de grenzen van ALGOL 60 overschrijdend, maar dat doet er in dit verband bitter weinig toe. Voor de V-operatie is de betekenis duidelijk: het is niet anders dan de simultaneous assignment, die aan alle meegegeven seinpalen gelijktijdig de waarde <b>true</b> toekent. De P-operatie met een aantal argumenten, bv. &quot;P(<var>S1</var>,&nbsp;<var>S2</var>,&nbsp;<var>S3</var>)&quot;, is een operatie, die slechts be&euml;indigd kan worden op een ogenblik, dat alle meegegeven seinpalen de waarde <b>true</b> hebben (in ons voorbeeld dus een ogenblik, waarop geldt: &quot;<var>S1</var> <b>and</b> <var>S2</var> <b>and</b> <var>S3</var>&quot;), beindiging van een P-operatie houdt dan in, dat aan alle meegegeven seinpalen simultaan de waarde <b>false</b> toegekend wordt. Ook na deze uitbreiding wordt de beindiging van een P-operatie weer beschouwd als een ondeelbare gebeurtenis.</p>
				<p>Met deze uitbreiding zijn we in staat machine <var>C</var> zodanig te defini&euml;ren, dat het gesignaleerde bezwaar niet meer optreedt:</p>
				<p class="noindent">&quot;<var>LC</var>: P(<var>SA</var>, <var>SB</var>); <var>TC</var>; V(<var>SA</var>; <var>SB</var>); <var>proces</var> <var>C</var>; <b>goto</b> <var>LC</var>&quot;.</p>
				<p>Tenslotte wil ik, hoewel dit beslist niet de toepassing is, waarvoor de P- en V-operaties geconcipieerd zijn, laten zien, hoe we hiermee het scalair product van twee vectoren kunnen berekenen, zonder dat we ons vast leggen op de volgorde, waarin de producten der elementen bij elkaar opgeteld worden.</p>
				<p>Stel, dat we uit willen rekenen de som SIGMA(<var>i</var>,1,5,<var>A</var>[<var>i</var>] * <var>B</var>[<var>i</var>]) &#x2014;in woorden: de som, voor <var>i</var> lopend van 1 t/m 5, van (<var>A</var>[<var>i</var>] * <var>B</var>[<var>i</var>])&#x2014;; </p>
				<p class="nospace">stel, dat ingevoerd zijn de 7 seinpalen: <var>Ssom</var>, <var>Sklaar</var> en de vijf seinpalen <var>Sterm</var>[<var>i</var>] met <var>i</var>=1,2,3,4 en 5; alle 7 met de beginwaarde <b>false</b>; </p>
				<p class="nospace">stel, dat inmiddels gecreerd zijn vijf machines van de structuur (<var>i</var>=1,2,3,4,5):</p>
				<p class="noindent">&quot;<var>Lterm</var>[<var>i</var>]: P(<var>Ssom</var>, <var>Sterm</var>[<var>i</var>]);</p>
				<p class="nospace"><var>scapro</var>:= <var>scapro</var> + <var>A</var>[<var>i</var>] * <var>B</var>[<var>i</var>]; </p>
				<p class="nospace"><var>n</var>:= <var>n</var> - 1; </p>
				<p class="nospace"><b>if</b> <var>n</var> = 0 <b>then</b> V(<var>Sklaar</var>) <b>else</b> V(<var>Ssom</var>); </p>
				<p class="nospace"><b>goto</b> <var>Lterm</var>[<var>i</var>] &quot; , </p>
				<p class="noindent">alle bezig aan hun &#x2014;enige&#x2014; P-operatie;</p>
				<p>Beschouw nu een zesde machine, die onder bovengenoemde voorwaarden juist zal beginnen aan de volgende statements:</p>
				<p class="noindent"> &quot;.....; <var>n</var>:= 5; </p>
				<p class="nospace"><var>&nbsp;&nbsp;scapro</var>:= 0; </p>
				<p class="nospace">&nbsp;&nbsp;V(<var>Ssom</var>, <var>Sterm</var>[1], <var>Sterm</var>[2], <var>Sterm</var>[3], <var>Sterm</var>[4], <var>Sterm</var>[5]); </p>
				<p class="nospace">&nbsp;&nbsp;&quot;programma, dat genoemde seinpalen, scalairen en vectorelementen<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ongemoeid laat&quot;;</p>
				<p class="nospace">&nbsp;&nbsp;P(<var>Sklaar</var>);....&quot;</p>
				<p>Als de laatste P-operatie van de zesde machine voltooid is, heeft <var>n</var> de waarde 0, <var>scapro</var> heeft de waarde van de gevraagde som en alle seinpalen en de vijf eerstgenoemde machines zijn terug in hun oorspronkelijke toestand.</p>
			</div>
			<hr>
			<div id="footer">transcribed by Gerrit Jan Veltink<br>
				 revised <csobj format="MedDate" h="15" region="15" t="DateTime" w="110">Mon, 22 Mar 2010</csobj></div>
		</div>
	</body>
</html>
</x-html>

</div>
  <script>
$('.body').tweetSelection({
  ellipsis: '...',
  quoteLeft: '\'',
  quoteRight: '\'',
  via: 'raboofje'
});
  </script>
  </body>
  </html>
