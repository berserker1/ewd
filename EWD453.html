  <!DOCTYPE html>
  <html>
  <head>
    <title>Finding the maximal-strong components in a directed graph</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <link href="assets/tweet-selection.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.12.0.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="assets/tweet-selection.js"></script>
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: Finding the maximal-strong components in a directed graph" />
    <meta name="twitter:title" content="Finding the maximal-strong components in a directed graph" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>Finding the maximal-strong components in a directed graph</h1>
  <div class='body'><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1" />
    <title>E.W.Dijkstra Archive: Finding the maximal-strong components in a directed graph (EWD 453)</title>
      <link href="../transcriptions.css" rel="stylesheet" media="screen"/>
   </head>
  <body>
    <div id="frame" align="right">
         <div id="header" align="right">
        <a href="https://www.cs.utexas.edu/~EWD/ewd04xx/EWD453.PDF"
           title="Link to the PDF version of EWD453">EWD453</a></div></div>
    <hr />
<p class="noindent">NOTE: This transcription was contributed by Martin P.M. van der Burgt, who has devised a process for producing transcripts automatically. Although its markup is incomplete, we believe it serves a useful purpose by virtue of its searchability and its accessibility to text-reading software. It will be replaced by a fully marked-up version when time permits. &mdash;HR
<hr />
<p class="noindent">
<p><b>Finding the maximal-strong components in a directed graph</b>.
<p>Given a directed graph, i.e. a set of vertices and a set of directed
edges, each leading from one vertex to another, it is requested to partition
the vertices into so-cal1ed &ldquo;maximal strong components&rdquo;. A strong component
is a set of vertices, such that the edges between them provide a directed
path from any vertex of the set to any vertex of the set and vice versa;
a single vertex is a special case of a strong component: then the path can
be empty. A maximal strong component is a strong component to which no
further vertices can be added.
<p>In order to establish this partitioning, we have to be able to make
two kinds of assertions: the assertion that vertices belong to the same
strong component, but also &mdash;because we have to find maximal strong components&mdash;
the assertion that vertices do not belong to the same strong component.
<p>For the first type of assertion, we may use the following
<p class=noindent><b>Theorem 1</b>. Cyclically connected vertices belong to the same strong component.
<p>Besides (directed) connections between individual vertices, we can
talk about directed connections between different strong components: we say
that there is a connection from a strong component A to a strong component
B if there exists a directed edge from a vertex of A to a vertex of B.
Because A and B are strong components; there is then a path from any
vertex of A to any vertex of B. And as a result, Theorem 1 can be 
generalized into
<p class=noindent><b>Theorem 1a</b>. Vertices of cyclically connected strong components belong to the
same strong component.
<p class=noindent><b>Corollary 1</b>. A non-empty graph has at least one maximal strong component
without outgoing edges.
<p>So much for theorems asserting that vertices belong to the same strong
component. Because for different points to be in the same strong component,
there must be paths between them in both ways, assertions that vertices do
not belong to the same strong component can be made on account of
<p class=noindent><b>Theorem 2.</b> If the vertices are subdivided into two sets svA and svB,
such that there exist no edges originating in a vertex of svA and 
terminating in a vertex of svB , then
<table width=100%><tr><td valign=top width=10%>
firstly:</td><td>the set of maximal strong components does not depend on
the presence or absence of edges originating in a vertex
of svB and terminating in a vertex of svA , and
</td></tr>
<tr><td valign=top>
secondly:</td><td>no strong component comprises vertices from both sets.
</td>  </tr>  </table>
<p>From Theorem 2 it follows that as soon as a strong component without
outgoing edges has been found, we can take its vertices as set svA and
conclude that this strong component is a maximal strong component and that
all ingoing edges of svA can further be ignored. We conclude
<p class=noindent><b>Theorem 2a</b>. A strong component whose outgoing edges, if any, are all ingoing
edges of maximal strong components, is itself a maximal strong component.
<p>Or, to put it in another way: once the first maximal strong component
without outgoing edges &mdash;the existence of which is guaranteed by Corollary 1&mdash;
has been found &mdash; identified as such by being a strong component without 
outgoing edges&mdash; the remaining maximal strong components can be found by solving
the problem for the graph consisting of the remaining vertices and only the
given edges between them. Or, to put it in still another way, the maximal
strong components of a graph can be ordered according to &ldquo;age&rdquo;, such that
each maximal strong component has only outgoing edges to &ldquo;older&rdquo; ones.
<p>In order to be able to be a little bit more precise, we denote by
<table width=100%><tr><td valign=top width=10%>
sv:</td><td>the given set of vertices (a constant)
</td></tr>
<tr><td valign=top>
se:</td><td>the given set of edges (a constant)
</td></tr>
<tr><td valign=top>
pv:</td><td>a partitioning of the vertices of sv .
</td>  </tr>  </table>
The final relation to be established can then be written as
<table width=100%><tr><td valign=top width=10%>
R:</td><td>pv = MSC(se)
</td>  </tr>  </table>
in which for the fixed set sv the function MSC, i.e. the partitioning in
Maximal Strong Components, is regarded as a function of the set of edges se.
<p>The corresponding invariant relation is suggested by the standard 
technique of replacing a constant by a variable, se1 say, whose value will
always be a subset of se:
<table width=100%><tr><td valign=top width=10%>
P:</td><td>pv = Msc(se1)        .
</td>  </tr>  </table>
Relation P is easily initialized for empty se1 &mdash;i.e. each.vertex of. sv
is a maximal strong component all by itself&mdash; . Because se1 is bounded in
size by se , monotonically increasing se1 is guaranteed to terminate; if
we can accomplish this under invariance of P , relation R has been 
established by the time that se1 = se . In our discussions it will be convenient
also to have a name, se2 say, for the remaining edges, i.e. se = se1 <sub>&#x23c9;</sub> se2
<p>Our task is clearly to discover the most convenient order in which edges
are to be added to se1 , where &ldquo;convenience&rdquo; is related to the ease with
which the invariance of relation P is maintained. This, as we know, can also
be phrased as: what is our general intermediate state, what types of pv-values
do we admit? In order to describe such a general intermediate state, it seems
practical to group the vertices of sv also in disjoint subsets (as we have
done for the edges: sel and se2 ). After all: we are interested in 
partitioning vertices!
<p>The general intermediate state should be a generalization of both initial
and final state. At the beginning, for none of the vertices it has been 
established to which maximal strong component in MSC(se) they belong, eventually
it has been established for all vertices. Analogous to se1 we can introduce
(initially empty and finally comprising all vertices) sv1, where
<table width=100%><tr><td valign=top width=10%>
sv1</td><td>contains all vertices of sv , for which the maximal strong component
</td></tr>
<tr><td valign=top>
</td><td>in MSC(se) to which they belong has been identified.
</td>  </tr>  </table>
<p>We intend to use Theorem 2a for deciding that a strong component is at
maximal one, that is, after having established something about all its 
outgoing edges, when we now identify:
<table width=100%><tr><td valign=top width=10%>
se1</td><td>with the set of all processed edges, and
</td></tr>
<tr><td valign=top>
se2</td><td>with the set of all unprocessed edges, i.e. edges whose presence has not
</td></tr>
<tr><td valign=top>
</td><td>yet been taken into account,
</td>  </tr>  </table>
then we see that 
<table width=100%><tr><td valign=top width=10%>
P1:</td><td>all outgoing edges of vertices in sv1 are in se1.
</td>  </tr>  </table>
<p>It is, however, too crude to group all remaining vertices in a single
set sv2. The way in which sv1 is defined implies that, each time a new
maximal strong component of MSC(se) has been identified, all the vertices
of that maximal strong component have to be transferred <b>together</b> to svl
Between two such transfers, in general a number of edges have to be processed
(i.e. transferred from se2 to se1 ), and for the description of the 
intermediate states that have to be taken into account with respect to &ldquo;processing
one edge at a time&rdquo;, the remaining vertices have to be separated a little bit
more subtly, viz, into two disjoint subsets, sv2 and sv3 say, (with
sv = sv1 <sub>&#x23c9;</sub> sv2 <sub>&#x23c9;</sub> sv3 ), where sv3 contains the totally unprocessed vertices,
P2: no edge in se1 begins or ends at a vertex in sv3,
sv3 is initially equal to sv and finally empty).
<p>Transfer from sv3 to sv1 can then take place in two steps:
from sv3 to sv2 (on at a time) and from sv2 to sv1 (together with all
other vertices from the same definite maximal strong component).
<p>In other words: among the vertices of sv2 we shall try to build up
(by enlarging sel) the next maximal strong component of MSC(se1) to be 
transferred to sv1, The maximal strong components in MSC(se1) &mdash;note the argument!&mdash;
are such that they comprise either vertices from sv1 only, or vertices from
sv2 only, or a (single) vertex from sv3 . We propose a limitation on the
connections that the edges of se1 provide between the maximal strong 
components in MSC(se1) that contain nodes from sv2 only: between those maximal
strong components the edges of se1 shall provide no more and no less than a
single directed path, leading from the &ldquo;oldest&rdquo; to the &ldquo;youngest&rdquo; one. We
call these maximal strong components &ldquo;the elements of the chain&rdquo;. This choice
is suggested by the following considerations.
<p>Firstly, we are looking for a cyclic path that would allow us to apply
Theorem 1 or 1a , in order to decide that different vertices belong to the
same maximal strong component. Under the assumption that we are free to 
prescribe which edge will be the next one to be added to se1 , there does not 
seem to be much advantage in introducing disconnected maximal strong components
in MSC(se1) among those built up from vertices of sv2 .
<p>Secondly, the directed path from the &ldquo;oldest&rdquo; to the &ldquo;youngest&rdquo; 
component in the chain &mdash;as &ldquo;cycle in statu nascendi&rdquo;&mdash; is easily maintained, as
is shown by the following analysis.
<p>Suppose that se2 contains an edge that is outgoing from one of the
vertices of the youngest maximal strong component in the chain. Such an edge
&ldquo;e&rdquo; is then transferred from se2 to se1 , and the state of affairs is 
easily maintained:
<table width=100%><tr><td valign=top width=10%>
1)</td><td>if e leads to a vertex from sv1, it can be ignored on account of
Theorem 2;.
</td>  </tr>  <tr><td valign=top>
2)</td><td>if e leads to a vertex from sv2 , the youngest element of the chain can be combined
</td>  </tr>  </table>
 with zero or more next older elements to form the new youngest
element of the chain; more precisely: if e leads to a vertex in the youngest
element, it can be ignored, if it leads to an older element in the chain, a
cycle between strong components has been detected and then Theorem 1a tells
us, that a number of the younger elements of the chain have to be combined
into a single one, thus reducing the length of the chain, measured in number
of elements.
<table width=100%><tr><td valign=top width=10%>
3)</td><td>if e leads to a vertex from sv3, that latter vertex is transferred to sv2 and
</td>  </tr>  </table>
 as new youngest element (a maximal strong component in MSC(se1)
all by itself) it is appended to the chain, whose length is increased by one.
<p>If there exists no such edge &ldquo;e&rdquo;, there are two possibilities. Either
the chain is non-empty, but then Theorem 2a tells us, that this maximal
strong component of MSC(se1) is a maximal strong component of MSC(se) as
well: the youngest element is removed from the chain and its vertices are
transferred from sv2 to sv1. Or the chain is empty: if sv3 is not empty,
an arbitrary element of sv3 can be transferred to sv2 , otherwise the
computation is finished. 
<p>In the above degree of detail we can describe our algorithm as follows:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 8>
      se1, se2, sv1, sv2, sv3 := empty, se, empty, empty, sv;                       </td> </tr> <tr> <td></td> <td colspan = 8>
      <b>do</b> sv3 &ne; empty &rarr; {the chain is empty} .                        </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 7>
         transfer a vertex v from sv3 to sv2 and initialize the                     </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; </td> <td colspan = 5>
              chain with {v};                                                       </td> </tr> <tr> <td></td> <td></td> <td colspan = 7>
         <b>do</b> sv2 &ne; empty &rarr; {the chain is non-empty}                   </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 6>
            <b>do</b> se2 contains an edge starting in a vertex of the youngest     </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td colspan = 4>
               element of the chain &rarr;                                          </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
                  transfer such an edge e from se2 tot se1 ;                        </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td colspan = 3>
                  <b>if</b> e leads to a vertex vi in svl &rarr; skip               </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td colspan = 2>
                   &#x25af; e leads to a vertex v in sv2 &rarr; compaction          </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td colspan = 2>
                   &#x25af; e leads to a vertex v in sv3 &rarr; extend chain and    </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;  &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                                                         transfer v from sv3 to sv2 </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td colspan = 3>
                  <b>fi</b>                                                         </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 6>
            <b>od</b> {the chain is non-empty}                                      </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 6>
            remove youngest element and transfer its vertices from. sv2 to svl      </td> </tr> <tr> <td></td> <td></td> <td colspan = 7>
         <b>od</b> {the chain is again empty}                                       </td> </tr> <tr> <td></td> <td colspan = 8>
      <b>od</b>                                                                     </td> </tr>
</table>
<p class=noindent><b>Note 1</b>. As soon as vertices are transferred from sv2 to sv1 , their 
incoming edges (if any) that are still in se2 could be transferred 
simultaneously from se2 to se1 , but the price for this &ldquo;advanced&rdquo; processing
&mdash;the gain of which is doubtful&mdash; is that we have to be able to select for
a given vertex the set of its incoming edges: as the algorithm is described,
we only need to find for each vertex its outgoing edges. Hence the above
arrangement. (End of note 1.)
<p class="noindent"><b>Note 2</b>. Termination of the innermost repetition is guaranteed by decrease
of the number of edges in se2; termination of the next embracing repetition
is guaranteed by decrease of the number of vertices in sv2 <sub>&#x23c9;</sub> sv3 ; termination
of the outer repetition is guaranteed by decrease of the number of vertices
in sv3 . The mixed reasoning, sometimes in terms of edges and sometimes in
terms of vertices, is a symptom of the non-triviality of the algorithm we
are developing. (End of note 2.)
<p>To the degree of detail in which we have described our algorithm, each
edge is transferred once from se2 to se1 and each vertex is transferred
once from sv3 via sv2 to sv1 : as such our algorithm implies an amount
of work linear in the number of edges and vertices. In our next refinement,
we should try not to spoil that pleasant property, as we would do if, for
instance, the test, whether v is in sv1 , sv2 or sv3 &mdash;which occurs
within the innermost repetition!&mdash; implied a search with a computation time
proportional to the number of vertices. The restricted way in which our
vertex sets are manipulated, in particular the fact that the vertices enter
and leave the chain in last-in-first-out fashion, can be exploited for this
purpose.  
<p>We consider our vertices consecutively numbered and tabulate the function
&ldquo;rank(v)&rdquo;, where v ranges over all vertex numbers; we assume NV to denote
the number of vertices:
<p class="noindent">rank(v) = 0 means: vertex nr. v is in sv3
<div class="noindent">rank(v) &gt; 0 means: vertex nr. v is in sv1 <sub>&#x23c9;</sub> sv2</div>
<br>(The sets sv2 and sv1 are, to start with, combined: one of the possible
forms of compaction is a skip!)
<p>If nvc equals the &ldquo;number of vertices in the chain&rdquo; &mdash;i.e. the number.
of vertices in sv2 &mdash; then
<br>1 &le; rank(v) &le; nvc  means: vertex v is in sv2
<br>rank(v) &ge; NV + 1 means: vertex v is in sv1
<br>All vertices in sv2 will have different rank-values, and as far as rank
and nvc are concerned, transferring vertex v from sv3 to sv2 will be
coded by         
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
          &ldquo;nvc:= nvc + 1; rank:(v) = nvc&rdquo; </td> </tr>
</table>
i.e. the vertices in the chain are &ldquo;ranked&rdquo; in the order of increasing &ldquo;age
in the chain&rdquo;. The latter convention allows us to represent, how the vertices
of sv2 are partitioned in strong components quite efficiently: vertices
belonging to the same element of the chain have consecutive values of rank ,
and for the elements themselves, the rank of their oldest vertex is an 
increasing function of the element age. Using cc(i) to denote the rank of the
oldest vertex of the i-th oldest element of the chain &mdash;we have then:
cc.dom = the number of elements in the chain&mdash; , as far as rank , nvc and
cc are concerned, we can code the alternative construct (combining the first
two alternatives) as follows:   
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      <b>if</b> rank(v) &gt; 0 &rarr; <b>do</b> cc.high &gt; rank:(v) &rarr; cc:hirem <b>od</b> </td> </tr> <tr> <td></td> <td>&nbsp; </td> <td>
       &#x25af; rank(v) = 0 &rarr; nvc:= nvc + 1; rank:(v)= nvc; cc:hiext(nvc)                  </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>fi</b>                                                                                 </td> </tr>
</table>
<p>In the mean time we have somewhat lost trace of the identity of the
vertices in the chain: if, for instance, we would like to transfer the
vertices of the youngest element of the chain from sv2 to sv1 , our current
tabulations would force us to scan the function rank for all values of v ,
such as to find those satisfying cc.high &le; rank(v) &le; nvc . We would not
like to do that, but thanks to the fact that at least for the vertices in
sv2 , all values of  rank(v)are different, we can also store the inverse
function:
<br>for 1 &le; r &le; nvc: rank(v) = r <=> knar(r) = v
<p>So much for keeping track of the vertices; let us now turn our attention
to the edges. The most crucial question with regard to the edges is, of course,
the guard of the innermost repetitive construct: &ldquo;se2 contains an edge starting
in a vertex of the youngest element of the chain&rdquo;. That question is answered
easily with the aid of a list of edges from se2 , outgoing from the vertices
of the youngest element of the chain. One of the ways in which the youngest
in the chain may change, however; is compaction: in order to maintain that
list we therefore, also need the corresponding lists for the older elements
of the chain. Because for those edges we are only interested in the identity
of their &ldquo;target vertex&rdquo;, we introduce as the next part of our chain 
administration two further array variables &mdash;with domain = 0 when the chain is empty&mdash;
called &ldquo;tv&rdquo; (for target vertices) and &ldquo;tvb&rdquo; (for &ldquo;tv-bounds&rdquo;).
<p>The domain of tvb will have one point for each element of the chain:
its value equals the number of outgoing edges of se2 from vertices of older
elements in the chain (the domain of tvb is all the time equal to that one
of cc , which also stores one value for each chain element). Each time
a new vertex v is transferred from sv3 to sv2 , the array tvb
is extended at the high end with the value of tv.dom , whereafter
tv is extended at the high end with the target vertices of the outgoing edges
of v . Denoting that latter operation with &ldquo;extend tv with targets of v &rdquo;
the whole inner repetition now becomes &mdash;taking knar , tv and tvb into
account as well&mdash;
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 5>
      &ldquo;inner loop&rdquo;:                                                   </td> </tr> <tr> <td></td> <td colspan = 5>
      <b>do</b> tv.dom &gt; tvb.high &rarr;                                       </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 4>
         v, tv:hipop                                                              </td> </tr> <tr> <td></td> <td></td> <td colspan = 4>
         <b>if</b> vrank(v) &gt; 0 &rarr;                                         </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td>
               <b>do</b> cc.high &gt; rank(v)&rarr; cc:hirem; tvb:hirem <b>od</b> </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; </td> <td colspan = 3>
          &#x25af; rank(v) = 0 &rarr;                                             </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
              nvc:= nvc + 1; rank:(v)= nvc; knar:hiext(v);                        </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td colspan = 2>
              cc:hiext(nvc); tvb:hiext(tv.dom);                                   </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td colspan = 2>
              &ldquo;extend tv with target of v &rdquo;                           </td> </tr> <tr> <td></td> <td></td> <td colspan = 4>
         <b>fi</b>                                                                </td> </tr> <tr> <td></td> <td colspan = 5>
      <b>od</b>                                                                   </td> </tr>
</table>
<p>We had introduced for vertices v in sv1 the convention:
rank(v) &gt; NV. We can make a stronger convention by numbering the maximal
strong component from 1 onwards (in the order in which they are detected)
and introducing the convention that for a vertex. v in sv1 we will have
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      rank(v) = NV&rsquo;+ v&rsquo;s maximal strong conponent number . </td> </tr>
</table>
with the variable &ldquo;strno&rdquo; (initially = 0), we can new code the
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
      &ldquo;middle loop&rdquo;:                               </td> </tr> <tr> <td></td> <td colspan = 3>
      <b>do</b> cc.dom &gt; 0 &rarr;                           </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
            &ldquo;inner loop&rdquo;;                          </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
            strno:= strno + 1;                                 </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
            <b>do</b> nvc &gt; cc.high &rarr;                  </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                  nvc:= nvc - 1; rank:(knar.high)= NV + strno; </td> </tr> <tr> <td></td> <td></td> <td></td> <td>
                  knar:hirem; sv1count:= sv1count + 1          </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
            <b>od</b>;                                         </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
            cc:hirem; tvb:hirem                                </td> </tr> <tr> <td></td> <td colspan = 3>
      <b>od</b>                                                </td> </tr>
</table>
(The variable sv1count &mdash;initially = 0&mdash; counts the number of vertices in
sv1 : then sv1count = NM will be the criterion for completion of the task.
<p>We assume the vertices numbered from 1 through NV , and the edges
to be given by means of two array constants &ldquo;edge&rdquo; and &ldquo;edgeb&rdquo;, such that
for 1 &le; i &le; NV the values of edge(j) for edgeb(i) &le; j &lt; edgeb(i + 1) 
give the numbers of the vertices to which the edges outgoing from vertex 
nr. i lead. We can then code
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      &ldquo;extend tv with targets of v &rdquo;:                                   </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>begin</b> <b>glocon</b> edge, edgeb, v; <b>glovar</b> tv; <b>privar</b> j; </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td>
         j <b>vir</b> int := edgeb(v + 1);                                          </td> </tr> <tr> <td></td> <td></td> <td>
         <b>do</b> j &gt; edgeb(v) &rarr; j=: j - l; tv:hiext(edge(j)) <b>od</b>    </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>end</b>                                                                    </td> </tr>
</table>
<p>The last problem to be solved is the selection of an arbitrary vertex
v from sv3 for the initialization of the chain. If each time the search
would start at vertex nr. 1 , computation time could be proportional to NV<sup>2</sup>,
but again this can be avoided by taking a relation outside the repetition and
introducing at the outer level a variable &ldquo;cand&rdquo; (initially = 1) with the
property:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
       sv3 contains no vertex v with v &lt; cand . </td> </tr>
</table>
<p class="noindent">
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 4>
      <b>begin</b> <b>glocon</b> edge, edgeb, NV; <b>virvar</b> rank; <b>privar</b> sv1count, cand, strno; </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
         rank <b>vir</b> int array := (1); <b>do</b> rank.dom &ne; NV &rarr; rank:hiext(0) <b>od</b>;      </td> </tr> <tr> <td></td> <td></td> <td colspan = 3>
         sv1count <b>vir</b> int, cand <b>vir</b> int, strno <b>vir</b> int := 0, 1, 0;                    </td> </tr> <tr> <td></td> <td></td> <td colspan = 3>
         <b>do</b> svlcount &ne; NV &rarr;                                                                 </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
            <b>begin</b> <b>glocon</b> edge, edgeb, NV; <b>glovar</b> rank, sv1count, cand, strno;         </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td>
               <b>privar</b> v, cc, tv, tvb, knar, nvc;                                                    </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>
               <b>do</b> rank(cand) &ne; 0 &rarr; cand:= cand + 1 <b>od</b>; v <b>vir</b> int := cand;     </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>
               nvc <b>vir</b> int := 1; rank:(v)= 1; knar <b>vir</b> int <b>array</b> := (1, 0);           </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>
               cc <b>vir</b> int <b>array</b> := (1, 1); tvb <b>vir</b> int <b>array</b> := (1, 0);        </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>
               tv <b>vir</b> int <b>array</b> := (1);                                                      </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>
               &ldquo;extend tv with targets of v &rdquo;;                                                 </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>
               &ldquo;middle loop&rdquo;                                                                   </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 2>
            <b>end</b>                                                                                     </td> </tr> <tr> <td></td> <td></td> <td colspan = 3>
         <b>od</b>                                                                                         </td> </tr> <tr> <td></td> <td colspan = 4>
      <b>end</b>                                                                                           </td> </tr>
</table>
<p class="noindent"><b>Note 1</b>. A very similar algorithm has been developed independently by Robert
Tarjan. (End of note 1.)
<p class="noindent"><b>Note 2</b>. In retrospect we see that the variable &ldquo;nvc&rdquo; is superfluous, because
nvc = knar.dom . (End of note 2.)
<p class="noindent"><b>Note 3</b>. The operation &ldquo;extend tv with the targets of v &rdquo; is used twice.
(End of note 3.)
<p class="noindent"><b>Remark 1</b>. The reader will have noticed that in this example the actual code
development took place in a different order than in the development of the
program for the convex hull in three dimensions. The reason is &mdash;I think&mdash;
the following. In the case of the convex hull, the representation had already
been investigated very carefully as part of the logical analysis of the problem.
In this example the logical analysis had been largely completed when we faced
the task of selecting a representation that would admit an efficient execution
of the algorithm we had in mind. It is then natural to focus one&rsquo;s attention
on the most crucial part first, i.e. the innermost loop. (End of remark 1.)
<p class="noindent"><b>Remark 2</b>.It is worth noticing the various steps in which we arrived at our
solution. In the first stage our main concern has been to process each edge
only once, forgetting for the time being about the dependence of the computation
time on the number of vertices. This is fully correct, because, in general, the
number of edges can be expected to be an order of magnitude larger than the
number of vertices; (As a matter of fact, my first solution for this problem
&mdash;not recorded in this chapter&mdash; was linear in the number of edges but quadratic,
in the number of vertices.) It was only in the second stage that we started to 
worry about linear dependence on the number of vertices as well. How effective
this &ldquo;separation of concerns&rdquo; has been is strikingly illustrated by the fact that
in that second stage, graph theory did no longer enter our considerations at all!
(End of remark 2.)
<hr />
   <p class="noindent"><font size="-1">Transcribed by Martin P.M. van der Burgt<br />
    Last revision
    <csobj format="MedDate" h="13" region="15" t="DateTime" w="90">
      <!-- #BeginDate format:IS1 -->2014-11-15<!-- #EndDate -->
    </csobj>
  .</font></p>
  <p>&nbsp;</p>
</body></html></div>
  <script>
$('body').tweetSelection({
  height: 300,
  width: 600,
  minimumTextSelected: 3,
  shareClass: '.tweet-selection',
  ellipsis: '...',
  quoteLeft: '"',
  quoteRight: '"',
  via: 'raboofje'
});
  </script>
  </body>
  </html>
