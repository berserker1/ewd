  <!DOCTYPE html>
  <html>
  <head>
    <title>The problem of the maximum length of an ascending subsequence</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <link href="assets/tweet-selection.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.12.0.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="assets/tweet-selection.js"></script>
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: The problem of the maximum length of an ascending subsequence" />
    <meta name="twitter:title" content="The problem of the maximum length of an ascending subsequence" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>The problem of the maximum length of an ascending subsequence</h1>
  <div class='body'>				<p>We consider a sequence of &nbsp;&nbsp;<var>N</var>&nbsp;&nbsp; elements &nbsp;&nbsp;<var>A</var>(1)&nbsp;&nbsp; through &nbsp;&nbsp;<var>A</var>(<var>N</var>)&nbsp;&nbsp;. The order of increasing subscript value will be denoted by &#147;the order from left to right&#148;. From such a sequence we can take so-called &#147;subsequences of length <var>s</var>&#148; by the removal of an arbitrary collection of &nbsp;&nbsp;<var>N</var>&#150;<var>s</var>&nbsp;&nbsp; elements and retaining the remaining &nbsp;&nbsp;<var>s</var>&nbsp;&nbsp; elements in the order in which they occurred in the original sequence. When, in addition, each element has an integer value, we call a subsequence &quot;ascending&quot; iff it contains no element with a right-hand neighbour smaller than itself.</p>				<p class="noindent"><u>Note</u>. &nbsp;&nbsp;According to this definition, all &nbsp;&nbsp;<var>N</var>&nbsp;&nbsp; subsequences of length &nbsp;&nbsp;1&nbsp;&nbsp; and even the empty subsequence are ascending ones. (End of note.)</p>				<p>We look for an algorithm that determines for any given sequence (with <var>N</var> &gt; 0) the maximum length of an ascending subsequence that can be taken from it.</p>				<p class="noindent"><u>Note</u>. &nbsp;&nbsp;Although there need not be a unique longest ascending subsequence, the maximum length is unique, e.g. &nbsp;&nbsp;3&nbsp;1&nbsp;1&nbsp;2&nbsp;4&nbsp;3&nbsp;&nbsp; gives &nbsp;&nbsp;4&nbsp;&nbsp; for the maximum length, realized either by &nbsp;&nbsp;1&nbsp;1&nbsp;2&nbsp;4&nbsp;&nbsp; or by &nbsp;&nbsp;1&nbsp;1&nbsp;2&nbsp;3&nbsp;&nbsp;.  (End of note.)<br />				</p>				<p>If &nbsp;&nbsp;<var>k</var>&nbsp;&nbsp; represents the value we are looking for, we seek to establish the relation</p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td align="left" valign="top" width="14%">							<p class="noindent"><var>R</var>: &nbsp;&nbsp;&nbsp;<var>k</var> = </p>						</td>						<td align="left" valign="top">							<p class="noindent">the maximum length of an ascending subsequence taken from &nbsp;&nbsp;<var>A</var>(1)&nbsp;&nbsp; through &nbsp;&nbsp;<var>A</var>(N)</p>						</td>					</tr>				</table>				<p class="noindent">Because &nbsp;&nbsp;<var>R</var>&nbsp;&nbsp; contains the parameter &nbsp;&nbsp;<var>N</var>&nbsp;&nbsp;, it is strongly suggested to take as invariant relation &#151;or, as we shall see in a moment: as part of the invariant relation&#151;</p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td align="left" valign="top" width="22%">							<p class="noindent"><var>P</var>1(<var>k</var>, <var>n</var>): &nbsp;&nbsp;&nbsp;<var>k</var> = </p>						</td>						<td align="left" valign="top">							<p class="noindent">the maximum length of an ascending subsequence taken<br>															from &nbsp;&nbsp;<var>A</var>(1)&nbsp;&nbsp; through &nbsp;&nbsp;<var>A</var>(<var>n</var>)&nbsp;&nbsp;.</p>						</td>					</tr>				</table>				<p class="noindent">It has the virtues that it would do the job in the sense that &nbsp;&nbsp;(<var>P</var>1(<var>k</var>, <var>n</var>) <b>and</b> <var>n</var> = <var>N</var>) &#x21D2; <var>R</var>&nbsp;&nbsp; and is easily established, e.g. by &nbsp;&nbsp;<var>k</var>, <var>n</var> := 1, 1&nbsp;&nbsp;. These observations suggest to establish &nbsp;&nbsp;<var>P</var>1(<var>k</var>, <var>n</var>)&nbsp;&nbsp; for &nbsp;&nbsp;<var>n</var> = 1&nbsp;&nbsp; and then to increase &nbsp;&nbsp;<var>n</var>&nbsp;&nbsp; under invariance of <var>P</var>1(<var>k</var>, <var>n</var>)&nbsp;&nbsp; until &nbsp;&nbsp;<var>n</var> = <var>N</var>&nbsp;, more precisely: to increase &nbsp;&nbsp;<var>n</var>&nbsp;&nbsp; repeatedly by &nbsp;&nbsp;1&nbsp;&nbsp; and to restore each time, when destroyed, the truth of &nbsp;&nbsp;<var>P</var>1(<var>k</var>,<var> n</var>)&nbsp;&nbsp; by adjusting the value of &nbsp;&nbsp;<var>k</var>&nbsp;. Because extension with a next element can never decrease the maximum length of an ascending subsequence and can increase it by at most &nbsp;&nbsp;1&nbsp;&nbsp;, the adjustment of &nbsp;&nbsp;<var>k</var>&nbsp;&nbsp;, when needed, will have the form &nbsp;&nbsp;<var>k</var>:= <var>k</var> + 1&nbsp;&nbsp;. More precisely: because </p>				<p><var>P</var>1(<var>k</var>, <var>n</var>) = wp(&#147;<var>n</var>:= <var>n</var> + 1&#148;, <var>P</var>1(<var>k</var>, <var>n&#150;</var>1))</p>				<p class="noindent">we have to investigate after &nbsp;&nbsp;&#147;<var>n</var>:= <var>n</var> + 1&#148;&nbsp;&nbsp; under which circumstances no adjustment of &nbsp;&nbsp;<var>k</var>&nbsp;&nbsp; is needed, i.e. when</p>				<table width="100%">					<tr>						<td width="300">							<p><var>P</var>1(<var>k</var>, <var>n</var>&#150;1) &#x21D2; <var>P</var>1(<var>k</var>, <var>n</var>)</p>						</td>						<td width="200">							<p>,</p>						</td>						<td>							<div align="right">								(1)</div>						</td>					</tr>				</table>				<p class="noindent">and under what circumstances adjustment of &nbsp;&nbsp;<var>k</var>&nbsp;&nbsp; is needed, i.e. when</p>				<table width="100%">					<tr>						<td width="300">							<p><var>P</var>1(<var>k</var>, <var>n</var>&#150;1) &#x21D2; <var>P</var>1(<var>k</var>+1, <var>n</var>)</p>						</td>						<td width="200">							<p>,</p>						</td>						<td>							<div align="right">								(2)</div>						</td>					</tr>				</table>				<p class="noindent">Relation (2) holds iff &nbsp;&nbsp;<var>A</var>(<var>n</var>)&nbsp;&nbsp; can be used to extend an ascending subsequence of maximum length (&nbsp;= <var>k</var>) taken from &nbsp;&nbsp;<var>A</var>(1)&nbsp;&nbsp; through &nbsp;&nbsp;<var>A</var>(<var>n</var>&#150;1)&nbsp;; this is true iff</p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td align="left" valign="top">							<p class="noindent"><var>A</var>(<var>n</var>)&nbsp;&nbsp;&#x2265;&nbsp;&nbsp;</p>						</td>						<td align="left" valign="top">							<p class="noindent">the smallest rightmost value of an ascending subsequence of length <var>k</var>&nbsp;&nbsp; taken from &nbsp;&nbsp;<var>A</var>(1)&nbsp;&nbsp; through &nbsp;&nbsp;<var>A</var>(<var>n&#150;</var>1)&nbsp;&nbsp;.</p>						</td>					</tr>				</table>				<p class="noindent">This last inequality shows us, that besides &nbsp;&nbsp;<var>k</var>&nbsp;&nbsp; &#151;as defined by &nbsp;&nbsp;<var>P</var>1(<var>k</var>, <var>n</var>)&#151;&nbsp;&nbsp; we would also like to store the minimum rightmost value &#151;let us call it &nbsp;&nbsp;<var>m</var>&nbsp;&nbsp; for a moment&#151; of an ascending subsequence of maximal length. If (2) holds,&nbsp;&nbsp;<var>k</var>&nbsp;&nbsp; is obviously to be adjusted by &nbsp;&nbsp;<var>k</var>:= <var>k</var> + 1&nbsp;&nbsp;, and the assignment &nbsp;&nbsp;<var>m</var>:=&nbsp;<var>A</var>(<var>n</var>)&nbsp;&nbsp; would make &nbsp;&nbsp;<var>m</var>&nbsp;&nbsp; again equal to the minimum rightmost value of an ascending subsequence of maximum length (because, in this case, <i>all</i> ascending subsequences of maximal length taken from &nbsp;&nbsp;<var>A</var>(1)&nbsp;&nbsp; through &nbsp;&nbsp;<var>A</var>(<var>n</var>)&nbsp;&nbsp; will have <var>A</var>(<var>n</var>)&nbsp;&nbsp; as their rightmost element.)</p>				<p>The introduction of &nbsp;&nbsp;<var>m</var>&nbsp;&nbsp; as the minimum value of the rightmost value of an ascending subsequence of length &nbsp;&nbsp;<var>k</var>&nbsp;&nbsp;, presents, however, a problem in case (1). In that case, the extension with &nbsp;&nbsp;<var>A</var>(<var>n</var>)&nbsp;&nbsp;, although not leading to an increase of <var>k</var>&nbsp;&nbsp;, may require adjustment of &nbsp;&nbsp;<var>m</var>&nbsp;&nbsp; as it may lead to decrease of the minimum rightmost value of an ascending subsequence of that unchanged maximal length. This would be the case if the value &nbsp;&nbsp;<var>A</var>(<var>n</var>)&nbsp;&nbsp;&#151;which now satisfies &nbsp;&nbsp;<var>A</var>(<var>n</var>) &lt; <var>m</var>&nbsp;&#151; could be used to extend an ascending subsequence of length &nbsp;&nbsp;<var>k</var>&#150;1&nbsp;&nbsp;, taken from <var>A</var>(1)&nbsp;&nbsp; through &nbsp;&nbsp;<var>A</var>(<var>n</var>&#150;1)&nbsp;&nbsp;. In order to decide that, we would also need the minimum rightmost value of an ascending subsequence of length &nbsp;&nbsp;<var>k</var>&#150;1&nbsp;&nbsp;. Repeating the argument, we conclude that, instead of a scalar &nbsp;&nbsp;<var>m</var>&nbsp;&nbsp;, we need in addition to &nbsp;&nbsp;<var>k</var>&nbsp;&nbsp; an array variable &nbsp;&nbsp;<var>m</var>&nbsp;&nbsp; satisfying</p>				<table>					<tr>                        <td align="left" valign="top" width="124">							<p class="noindent"><var>P</var>2(<var>k</var>, <var>n</var>, <var>m</var>):</p>						</td>                        <td align="left" valign="top">							<p class="noindent">for all &nbsp;&nbsp;<var>j</var>&nbsp;&nbsp; satisfying &nbsp;&nbsp;1 &#x2264; <var>j</var> &#x2264; <var>k</var></p>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td align="left" valign="top" width="14%"><var>m</var>(<var>j</var>) =</td>									<td align="left" valign="top">the minimum rightmost value of an ascending subsequence of length &nbsp;&nbsp;<var>j</var>&nbsp;&nbsp; and taken from <var>A</var>(1)&nbsp;&nbsp; through &nbsp;&nbsp;<var>A</var>(<var>n</var>)&nbsp;&nbsp;.</td>								</tr>							</table>						</td>                    </tr>				</table>				<p class="noindent">Our total invariant relation will be &nbsp;&nbsp;<var>P</var>1 <b>and</b> <var>P</var>2&nbsp;&nbsp;.<br>				</p>				<p>Again, for &nbsp;&nbsp;<var>n</var> = 1, <var>P</var>2&nbsp;&nbsp; is easily initialized &nbsp;&nbsp;&#151;with &nbsp;&nbsp;<var>m</var>(1) = <var>A</var>(1)&#151;;&nbsp;&nbsp; we have to investigate, however, what updating obligations for the array variable &nbsp;&nbsp;<var>m</var>&nbsp;&nbsp; are implied by our duty to keep &nbsp;&nbsp;<var>P</var>2&nbsp;&nbsp; invariant. The crucial discovery in the analysis of our updating obligations for the array variable &nbsp;&nbsp;<var>m</var>&nbsp;&nbsp; is that the elements of &nbsp;&nbsp;<var>m</var>&nbsp;&nbsp; itself are ascending, more precisely:</p>				<p>(1 &#x2264; <var>i</var> &lt; <var>j</var> &#x2264; <var>k</var>) &#x21D2; (<var>m</var>(<var>i</var>) &#x2264;<var> m</var>(<var>j</var>))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.</p>				<p class="noindent">This follows from the fact that &nbsp;&nbsp;1 &#x2264; <var>i</var> &lt; <var>j</var> &#x2264; <var>k</var> <b>and</b> <var>m</var>(<var>i</var>) &gt; <var>m</var>(<var>j</var>)&nbsp;&nbsp; leads to a contradiction: by removing from an ascending sequence of length &nbsp;&nbsp;<var>j</var>&nbsp;&nbsp; and with <var>m</var>(<var>j</var>)&nbsp;&nbsp; as its rightmost value the leftmost &nbsp;&nbsp;<var>j</var>&#150;<var>i</var>&nbsp;&nbsp; elements, an ascending sequence of length &nbsp;&nbsp;<var>i</var>&nbsp;&nbsp; with &nbsp;&nbsp;<var>m</var>(<var>j</var>)&nbsp;&nbsp; as rightmost value remains, and &nbsp;&nbsp;<var>m</var>(<var>i</var>)&nbsp;&gt;&nbsp;<var>m</var>(<var>j</var>)&nbsp;&nbsp; then contradicts &nbsp;&nbsp;<var>P</var>2&nbsp;&nbsp;.</p>				<p>Again we investigate the situation as reached after &nbsp;&nbsp;<var>n</var>:= <var>n</var> + 1&nbsp;&nbsp;, i.e. when <var>P</var>1(<var>k</var>, <var>n&#150;</var>1) <b>and</b> <var>P</var>2(<var>k</var>, <var>n</var>&#150;1, <var>m</var>)&nbsp;&nbsp; holds. Relation (2) holds iff &nbsp;&nbsp;<var>A</var>(<var>n</var>) &#x2265; <var>m</var>(<var>k</var>). The new element &nbsp;&nbsp;<var>A</var>(<var>n</var>)&nbsp;&nbsp; can be used to form a longer ascending sequence, &nbsp;&nbsp;<var>k</var>&nbsp;&nbsp; has to be increased and the sequence of values is extended with &nbsp;&nbsp;<var>A</var>(<var>n</var>)&nbsp;&nbsp; by</p>				<p><var>m </var>: <var>hiext</var>(<var>A</var>(<var>n</var>)) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;</p>				<p class="noindent">it is correct to leave the values &nbsp;&nbsp;<var>m</var>(<var>i</var>)&nbsp;&nbsp; with &nbsp;&nbsp;1 &#x2264; <var>i</var> &lt; <var>k</var>&nbsp;&nbsp; unchanged, for the new element &nbsp;&nbsp;<var>A</var>(<var>n</var>) &#x2265; <var>m</var>(<var>k</var>)&nbsp;&nbsp; and can never give rise to a smaller rightmost value for any of the ascending sequences shorter than the new maximum length &nbsp;&nbsp;<var>k</var>&nbsp;&nbsp;. Relation (1) holds iff &nbsp;&nbsp;<var>A</var>(<var>n</var>) &lt; <var>m</var>(<var>k</var>)&nbsp;&nbsp;. Remembering that after the increase <var>n</var>:= <var>n</var>&nbsp;+&nbsp;1&nbsp;&nbsp; the relation &nbsp;&nbsp;<var>P</var>2(<var>k</var>, <var>n</var>&#150;1, <var>m</var>)&nbsp;&nbsp; holds, we have to answer the question for which value(s) of &nbsp;&nbsp;<var>j</var>&nbsp;&nbsp; is the minimum rightmost value of an ascending sequence of length &nbsp;&nbsp;<var>j</var>&nbsp;&nbsp; taken from &nbsp;&nbsp;<var>A</var>(1)&nbsp;&nbsp; through &nbsp;&nbsp;<var>A</var>(<var>n</var>)&nbsp;&nbsp; smaller than taken from &nbsp;&nbsp;<var>A</var>(1)&nbsp;&nbsp; through &nbsp;&nbsp;<var>A</var>(<var>n</var>&#150;1)?&nbsp;&nbsp; This can only be the case if &nbsp;&nbsp;<var>A</var>(<var>n</var>)&nbsp;&nbsp; is its new rightmost element, which must be smaller than its old value &nbsp;&nbsp;<var>m</var>(<var>j</var>)&nbsp;&nbsp;. So we have</p>				<table width="100%">					<tr>						<td width="500">							<p><var>A</var>(<var>n</var>) &lt; <var>m</var>(<var>j</var>)</p>						</td>						<td>							<div align="right">								<p>(3)</p>							</div>						</td>					</tr>				</table>				<p>But &nbsp;&nbsp;<var>A</var>(<var>n</var>)&nbsp;&nbsp; can only be the rightmost element of an ascending sequence of length &nbsp;&nbsp;<var>j</var>&nbsp;&nbsp; if</p>				<table width="100%">					<tr>						<td width="500">							<p>either &nbsp;&nbsp;<var>j</var> = 1&nbsp;&nbsp; or &nbsp;&nbsp;<var>j</var> &gt; 1 <b>and</b> <var>m</var>(<var>j</var>&#150;1) &#x2264; <var>A</var>(<var>n</var>)</p>						</td>						<td>							<div align="right">								(4)</div>						</td>					</tr>				</table>				<p class="noindent">Combining (3) and (4) we find<br>					<var>j</var> = 1&nbsp;&nbsp; iff &nbsp;&nbsp;<var>A</var>(<var>n</var>) &lt; <var>m</var>(1)&nbsp;&nbsp; and otherwise &nbsp;&nbsp;<var>j</var> = the only(!) solution of &nbsp;&nbsp;<var>m</var>(<var>j</var>&#150;1) &#x2264; <var>A</var>(<var>n</var>) &lt; <var>m</var>(<var>j</var>)&nbsp;&nbsp;. This last solution is found in the program with a binary search; the invariant relation for the inner loop is &nbsp;&nbsp;<var>m</var>(<var>i</var>) &#x2264; <var>A</var>(<var>n</var>) &lt; <var>m</var>(<var>j</var>)&nbsp;&nbsp;.</p>				<p>Observing that &nbsp;&nbsp;<var>k</var> = <var>m</var>.<var>hib</var>&nbsp;&nbsp;, the current higher bound for the index, we can use for &nbsp;&nbsp;<var>m</var>(<var>k</var>) = <var>m</var>(<var>m</var>.<var>hib</var>)&nbsp;&nbsp; the usual abbrevation &nbsp;&nbsp;<var>m</var>.<var>high</var>&nbsp;&nbsp; and conclude that we don&#146;t need the variable &nbsp;&nbsp;<var>k</var>&nbsp;&nbsp; after all. For reasons of symmetry we denote &nbsp;&nbsp;<var>m</var>(1)&nbsp;&nbsp; by &nbsp;&nbsp;<var>m</var>.<var>low</var>&nbsp;&nbsp;, as &nbsp;&nbsp;<var>m</var>.<var>lob</var> = 1&nbsp;&nbsp;. Omitting all declarations we get the following program.</p>				<pre>n:= 1; m:= (1, A(1));<b>do</b> n &#x2260; N &#x2192;        n:= n + 1;        <b>if</b> A(n) &#x2265; m.high &#x2192;                m:hiext(A(n))            &#x2337; A(n) &lt; m.high &#x2192;                <b>if</b> m.low &gt; A(n) &#x2192;                        j:= 1                    &#x2337; m.low &#x2264; A(n) &#x2192;                        i, j := m.lob, m.hib;                        <b>do</b> i &#x2260; j - 1 &#x2192;                                h:= (i + j)<b>div</b> 2;                                <b>if</b> m(h) &#x2264; A(n) &#x2192; i:= h                                    &#x2337; A(n) &lt; m(h) &#x2192; j:= h                                <b>fi</b>                        <b>od</b>                <b>fi</b>;                m:(j)=A(n)        <b>fi</b><b>od</b>;print(m.hib)</pre>				<br /><br />			</div>			<table width="100%">			<tr>				<td width="227">Plataanstraat&nbsp;&nbsp;5</td>				<td>						<div align="right">							prof. dr. Edsger W. Dijkstra</div>					</td>			</tr>			<tr>				<td width="227">NL-4565&nbsp;&nbsp;&nbsp;&nbsp;NUENEN</td>				<td>						<div align="right">							Burroughs Research Fellow</div>					</td>			</tr>			<tr>					<td width="227">The Netherlands</td>				</tr>			</table>			<hr />			<div id="footer">				<font size="-1">					transcribed by Swarup Sahoo<br /> last revised  <csobj format="MedDate" h="16" region="15" t="DateTime" w="78">Tue, 5 Jul 2011</csobj></font>			</div>		</div>	</body></html></div>
  <script>
$('.body').tweetSelection({
  ellipsis: '...',
  quoteLeft: '\'',
  quoteRight: '\'',
  via: 'raboofje'
});
  </script>
  </body>
  </html>
