  <!DOCTYPE html>
  <html>
  <head>
    <title>The formal treatment of some small examples</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <link href="assets/tweet-selection.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.12.0.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="assets/tweet-selection.js"></script>
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: The formal treatment of some small examples" />
    <meta name="twitter:title" content="The formal treatment of some small examples" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>The formal treatment of some small examples</h1>
  <div class='body'>
<div id="frame" align="right">
<div id="header" align="right"><a href="https://www.cs.utexas.edu/~EWD/ewd04xx/EWD413.PDF" title="Link to the PDF version of EWD413">EWD413</a></div>
</div>
<hr />
<p class="noindent">NOTE: This transcription was contributed by Martin P.M. van der Burgt, who has devised a process for producing transcripts automatically. Although its markup is incomplete, we believe it serves a useful purpose by virtue of its searchability and its accessibility to text-reading software. It will be replaced by a fully marked-up version when time permits. —HR</p>
<hr />
<p class="noindent"></p>
<p><b>The formal treatment of some small examples</b>.</p>
<p>In this chapter I shall give the formal development of a series of small programs solving simple problems. This chapter should <b>not</b> be interpreted as my suggestion that these programs must or should be developed in such a way: such a suggestion would be somewhat ridiculous. I expect most of my readers to be familiar with most of the examples and, if not, they can probably write down a program, hardly aware of having to think about it.</p>
<p>The development, therefore, is given for quite other reasons. One reason is to make ourselves more familiar with the formalism as far as it has been developed up to now. A second reason is to convince ourselves that, in principle at least, the formalism is able to make explicit and quite rigourous what is often justified with a lot of hand-waving. A third reason is precisely that most of us are so familiar with them that we have forgotten how, a long time ago, we have convinced ourselves of their correctness: in this respect this chapter resembles the beginning lessons in plane geometry that are traditionally devoted to proving the obvious. Fourthly, we may occasionally get a little surprise and discover that a little familiar problem is not so familiar after all. Finally it may shed some light on the feasibility, the difficulties and the possibilities of automatic program composition or mechanical assistance in the programming process. This could be of importance even if we do not have the slightest interest in automatic program composition, for it may give us a better appreciation of the role that our inventive powers may or have to play. In my examples I shall state requirements of the form “for fixed x, y, ... ; this is an abreviation for “for any values X0 , y0, ... a post-condition of the form x = x0 <b>and</b> y = y0 <b>and</b> ... should give rise to a pre-condition implying x = x0 <b>and</b> y = y0 <b>and</b> ”. We shall guarantee this by treating such quantities as “temporary constants”, they will not occur to the left of an assigment statement.</p>
<p><b>First example</b>. Establish for fixed x and y the relation R(m):</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(m = x <b>or</b> m = y) <b>and</b> m ≥x <b>and</b> m ≥ y .</td>
</tr>
</table>
For general values of x and y the relation m = x can only be established by the assignment m:= x; as a consequence (m = x <b>or</b> m = y) can only be established by activating either m:= x or m:= y. In flow-chart form<br />
<img src="ewd413img1.png" border="0" /><br />
The point is that at the entry the good choice must be made so as to guarantee that upon completion R(m) holds. For this purpose we “push the post-condition through the alternatives”:<br />
<img src="ewd413img2.png" border="0" /><br />
and we have derived the guards! As
<table width="100%">
<tr>
<td valign="top" width="10%"></td>
<td>R(x) = ((x = x <b>or</b> x = y) <b>and</b> x ≥ x <b>and</b> x ≥ y) = (x ≥ y)</td>
</tr>
<tr>
<td valign="top">and</td>
<td>R(y) = ((y = x <b>or</b> y = y) <b>and</b> y ≥ x <b>and</b> y ≤ y) = (y ≥ x)</td>
</tr>
</table>
we arrive at our solution:
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp;</td>
<td><b>if</b> x .≥ y → x ▯ y ≥ x → m:= y <b>fi</b></td>
</tr>
</table>
Because (x ≥ y <b>or</b> y ≥ x) = T , the program will never abort (and in passing we have given an existence proof: for any values x and y there exists an m satisfying R(m) ). Because (x ≥ y <b>and</b> y ≥ x) ≠ F , our program is not necessarily deterministic: if initially x = y , it is undetermined which of the two assignments will be selected for execution; this non-determinacy is fully correct, because we have shown that the choice does not matter.
<p><b>Note</b>. If the function “max” had been an available primitive, we could have coded m:= max(x, y) because R(max(x, y)) = T (End of note.)</p>
<p>The program we have derived is not very impressive; on the other hand we observe that in the process of deriving the program from our postcondition next to nothing has been left to our invention.</p>
<p><b>Second example</b>.</p>
<p>For a fixed value of n (n &gt; 0) a function f(i) is given for 0 ≤ i &lt; n . Establish the truth of R:</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>0 ≤ k &lt; n <b>and</b> (<u>A</u> i: 0 ≤ i &lt; n: f(k) ≥ f(i)) .</td>
</tr>
</table>
Because our program must work for any positive value of n it is hard to see how R can be established without a loop; we are therefore looking for a relation P that is easily established to start with and such that eventually (P <b>and</b> <b>non</b> BB) ⇒ R . In search of P we are therefore looking for a relation weaker than R , in other words: we want a generalization of our final state. A standard way of generalizing a relation is the replacement of a constant by a variable —possibly with a restricted range— and here my experience suggests that we replace the constant n by a new variable, j say, and take for P:
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>0 ≤ k &lt; j ≤ n <b>and</b> (<u>A</u> i: 0 ≤ i &lt; j : f(k) ≥ f(i))</td>
</tr>
</table>
where the condition j ≤ n has been added in order to do justice to the finite domain of the function f . Then, with such a generalization, we have trivially
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(P <b>and</b> n = j) ⇒ R .</td>
</tr>
</table>
<p>In order to verify whether this choice of P can be used, we must have an easy way of establishing it to start with. Well, because</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(k = 0 <b>and</b> j = 1) ⇒ P .</td>
</tr>
</table>
we venture the following structure for our program -comments being added between braces
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>k, j:= 0, 1 {P has been established};</td>
</tr>
<tr>
<td></td>
<td><b>do</b> j ≠ n → a step towards j = n under invariance of P <b>od</b></td>
</tr>
<tr>
<td></td>
<td>{R has been established} .</td>
</tr>
</table>
<p>Again my experience suggests to choose as monotonicly decreasing function t of the current state t = (n - j) , which, indeed, is such that P ⇒ (t ≥0) . In order to ensure this monotonic decrease of t I propose to subject j to an increase by 1 and we can develop</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2">wp(“j:= j + 1”, P) =</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td>0 ≤ k &lt; j + 1 ≤ n <b>and</b> (<u>A</u> i:0 ≤ i &lt; j + 1: f(k) ≥ f(i)) =</td>
</tr>
<tr>
<td></td>
<td></td>
<td>0 ≤ k &lt; j + 1 ≤ n <b>and</b> (<u>A</u> i:0 ≤ i &lt; j: f(k) ≥ f(i)) and f(k) ≥ f(j).</td>
</tr>
</table>
The first two terms are implied by P <b>and</b> j ≠ n (for (j≤n <b>and</b> j≠n) ⇒ (j + 1 ≤ n) and this is the reason why we decided to increase j only by 1.) Therefore
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(P <b>and</b> j ≠ n <b>and</b> f(k) ≥ f(j)) ⇒ wp(“j:= j + 1”, P)</td>
</tr>
</table>
and we can take the last condition as guard. The program
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>k, j := 0, 1;</td>
</tr>
<tr>
<td></td>
<td><b>do</b> j ≠ n → <b>if</b> f(k) ≥ f(j) → j:= j + 1 <b>fi</b> <b>od</b></td>
</tr>
</table>
will indeed give the good answer when it terminates properly. Proper termination, however, is not guaranteed, because the alternative construct might lead to abortion —and it will certainly do so, if k = 0 does not satisfy R . If f(k) ≥ f(j) does not hold, we can make it hold by the assignment k:= j and therefore our next investigation is
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wp(“k, j:=j, j + 1”, P) =</td>
</tr>
<tr>
<td></td>
<td>0 ≤ j &lt; j + 1 ≤ n <b>and</b> (<u>A</u> i: 0 ≤_i &lt; j + 1: f(j) ≥ f(i)) =</td>
</tr>
<tr>
<td></td>
<td>0 ≤ j &lt; j + 1 ≤ n <b>and</b> (<u>A</u> i: 0 ≤_i &lt; j: f(j) ≥ f(i)) =</td>
</tr>
</table>
To our great relief we see that
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(P and j ≠ n <b>and</b> f(k) ≤ f(j))⇒ wp(“k, j:= j, j + 1”, P)</td>
</tr>
</table>
and the following program will do the job without the danger of abortion:
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="2">k, j:= 0, 1;</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>do</b> j ≠ n → <b>if</b> f(k) ≥ f(j) → j:= j + 1</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>▯ f(k) ≤ f(j) → k, j:= j, j + 1 <b>fi</b> <b>od</b> .</td>
</tr>
</table>
A few remarks are in order. The first one is that, as the guards of the alternative construct do not necessarily exclude each other, the program harbours the same kind of internal non-determinacy as the first example. Externally it may display this non-determinacy as well. The function f could be such that the final value of k is not unique: in that case our program can deliver any acceptable value!
<p>The second remark is that having developed a correct program does not mean that we are through with the problem. Programming is as much a mathematical discipline as an engineering discipline, correctness is as much our concern as, say, efficiency. Under the assumption that the computation of a value of the function f for a given argument is a relatively time-consuming operation, a good engineer should observe that in all probability this program will often ask for many re-computations of f(k) for the same value of k . If this is the case the trading of some storage space against some computation time is indicated. The effort to make our program more time-efficient, however, should never be an excuse to make a mess of it. (This is obvious, but I state it explicitly because so much messiness is so often defended by an appeal to efficiency considerations, while upon closer inspection the defense is always unvalid: it must be, for a mess is never defensible.) The orderly technique for trading storage space versus computation time is the introduction of one or more redundant variables, the value of which can be used because some relation is kept invariant. In this example the observation of the possibly frequent re-computation of f(k) for the same value of k suggests the introduction of a further variable, max say, and to extend the invariant relation with the further term</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>max = f(k) .</td>
</tr>
</table>
This relation must be established upon initialization of k and be kept invariant —by explicit assignment to max — upon modification of k . We arrive at the following program
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="2">k, j, max := 0, 1, f(0);</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>do</b> j ≠ n → <b>if</b> max ≥ f(j) → j:= j + 1</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>▯ max ≤ f(j) → k, j, max:= j, j + 1, f(k) <b>fi</b> <b>od</b></td>
</tr>
</table>
<p>This program is probably much more efficient than our previous version. If it is, a good engineer does not stop here, because he will now observe that for the same value of j he might order a number of times the computation of f(j). It is suggested to introduce a further variable, h say (short For “help”) and to keep</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>h = f(j)</td>
</tr>
</table>
invariant. This, however, is a thing that we cannot do on the same global level as with oux previous term: the value j = n is not excluded and for that value f(j) is not necessarily defined. The relation h = f(j) is therefore re-eslablished every time j ≠ n has just been checked; upon completion of the outer guarded command— “just before the <b>od</b>” so to speak— we have h = f(j - 1) but we don’t bother and leave it at that.
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2">k, j, max:= 0, 1, f(0);</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>do</b> j ≠ n → h:= f(j);</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td><b>if</b> max ≥ h → j:= j + 1</td>
</tr>
<tr>
<td></td>
<td></td>
<td>▯ max ≤ h → k, j, max:= j, j + 1, h <b>fi</b> <b>od</b></td>
</tr>
</table>
<p>A final remark is not so much concerned with our solution as with our considerations. We have had our mathematical concerns, we have had our engineering concerns and we have accomplished a certain amount of separation between them, now focussing our attention on this aspect and then on that aspect. While such a separation of concerns is absolutely essential when dealing with more complicated problems, I must stress that focussing one’s attention on one aspect does not mean completely ignoring the others. In the more mathematical part of the design activity we should not head for a mathematically correct program that is so badly engineered that it is beyond salvation. Similarly, while “trading” we should not introduce errors through sloppiness, we should do it careful and systematic; also, although the mathematical analysis as such has been completed, we should still understand enough about the problem to judge whether our considered changes are significant improvements.</p>
<p class="noindent"><b>Note</b>. Prior to my getting used to these formal developments I would always have used “j &lt; n” as the guard for this repetitive construct, a habit I still have to unlearn, for in a case like this, the guard “j ≠ n” is certainly to be preferred. The reason for the preference is twofold. The guard “j ≠ n” allows us to conclude j = n upon termination without an appeal to the invariant relation P and thus simplifies the argument about what the whole construct achieves for us compared with the guard “j &lt; n”. Much more important, however, is that the guard “j ≠ n” makes termination dependent upon (part of) the invariant relation, viz. j ≤ n and is therefore to be preferred for reasons of robustness. If the addition j:= j + 1 would erroneously increase j too much and would establish j &gt; n , then the guard “j &lt; n” would give no alarm, while the guard “j ≠ n” would at least prevent proper termination. Even without taking machine malfunctioning into account, this argument seems valid. Let a sequence x0, x1, x2, ... be given by a value for x0 and for i &gt; 0 by x<sub>i</sub>= f(x<sub>i-1</sub>) , where f is some computable function and let us carefully and correctly keep the relation X = x<sub>i</sub>, invariant. Suppose that we have in a program a monotonicly increasing variable n , such that for some values of n we are interested in x<sub>n</sub> . Provided n ≠ i , we can always establish X = x<sub>n</sub> by</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td><b>do</b> j ≠ n → i, X:= i+1, f(X) <b>od</b> .</td>
</tr>
</table>
If —due perhaps to a later change in the program with the result that it is no longer guaranteed that n can only increase as the computation proceeds— the relation n ≥ i does not necessarily hold, the above construct would (luckily!) fail to terminate, while the use of
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td><b>do</b> j &lt; n → i, X:= i+1, f(X) <b>od</b></td>
</tr>
</table>
would have failed to establish the relation X = x<sub>n</sub>. The moral of the story is that, all other things being equal, we should choose our guards as weak as possible. (End of note.)
<p><b>Third example</b>.</p>
<p>For fixed a (a ≥ 0) and d (d &gt; 0) it is requested to establish</p>
<table width="100%">
<tr>
<td valign="top" width="10%">R:</td>
<td>0 &lt; r &lt; d <b>and</b> (a - r)|d .</td>
</tr>
</table>
(Here the vertical bar “|” is to be read as: “is a multiple of”.) In other words we are requested to compute the smallest non-negative remainder r that is left after division of a by d . In order that the problem be a problem, we have to restrict ourselves to addition and subtraction as the only aritmetic operations. Because the term (a - r)|d is satisfied by r = a, an initialization that —on account of a ≥ 0— also satisfies 0 ≤ r , it is suggested to choose as invariant relation P:
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>0 ≤ r <b>and</b> (a - r)|d .</td>
</tr>
</table>
<p>For the function t , the decrease of which should ensure termination, we choose r itself; because the messaging of r must be such that the relation (a - r)|d is kept invariant, r may only be changed by a multiple of d , for instance d itself. Thus we find ourselves invited to evaluate</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2">wp(“r:= r - d”, P) <b>and</b> wdec(“r:= r - d”, r) =</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp;</td>
<td>0 ≤ r - d <b>and</b> (a - r + d &gt; 0 .</td>
</tr>
</table>
<p>Because the term d &gt; 0 could have been added to the invariant relation P , only the first term is then not implied; we find the corresponding guard “r ≥ d” and the tentative program:</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>if</b> a ≥ 0 <b>and</b> d &gt; 0 →</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td>r:= a;</td>
</tr>
<tr>
<td></td>
<td></td>
<td><b>do</b> r ≥ d → r:= r - d <b>od</b></td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>fi</b> .</td>
</tr>
</table>
Upon completion the truth of P <b>and</b> <b>non</b> r ≥ d has been established, a relation that implies R and thus the problem has been solved.
<p>Suppose now, that in addition it would have been required to assign to q such a value that finally we also have</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>a = d * q + r</td>
</tr>
</table>
—in other words it is requested to compute the quotient as well— then we can try to add this term to our invariant relation. Because
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(a = d * q + r) ⇒ (a = d *(q + 1)+(r - d))</td>
</tr>
</table>
we are led to the program:
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>if</b> a ≥ 0 <b>and</b> d &gt; 0 →</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td>q, r:= 0, a;</td>
</tr>
<tr>
<td></td>
<td></td>
<td><b>do</b> r ≥ d → q, r:= q + 1, r - d <b>od</b></td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>fi</b> .</td>
</tr>
</table>
The above programs are, of course, very time-consuming if the quotient is large. Can we speed it up? The obvious way to do that is to decrease r by larger multiples of d . Introducing for this purpose a new variable, dd say, the relation to be established and kept invariant is
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>dd|d <b>and</b> dd ≥ d</td>
</tr>
</table>
<p>We can speed up our first program by replacing “r:= r - d” by a possibly repeated decrease of r by dd , while dd , initially = d , is allowed to grow rather rapidly, e.g. by doubling it each time. So we are led to consider the following program</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="3"><b>if</b> a ≥ 0 <b>and</b> d &gt; 0 →</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2">r:= a;</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2"><b>do</b> r≥d →</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td>dd:= d;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td><b>do</b> r≥ dd → r - dd; dd + dd <b>od</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2"><b>od</b></td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>fi</b></td>
</tr>
</table>
The relation 0 ≤ r <b>and</b> (a - r)|d is clearly kept invariant and therefore this program establishes R if it terminates properly, but does it? Of course it does, because the inner loop —that terminates on account of dd &gt; 0 — is only activated with initial states satisfying r ≥ dd and therefore the decrease r:= r - dd is performed at least once for every repetition of the outer loop.
<p>But the above reasoning —although convincing enough!— is a very informal one and because this chapter is called “a formal treatment” we can try to formulate and prove the theorem to which we have appealed intuitively.</p>
<p>With the usual meanings of IF, DO and BB , let P be the relation that is kept invariant, i.e.</p>
<table width="100%">
<tr>
<td valign="top" width="10%"></td>
<td valign="top">(P <b>and</b> BB) ⇒ wp(IF, P) for all states</td>
<td align="right">(1)</td>
</tr>
</table>
and let furthermore i be an integer function such that for any value of t0 and for all states
<table width="100%">
<tr>
<td valign="top" width="10%"></td>
<td valign="top">(P <b>and</b> BB <b>and</b> t ≤ t0 + 1) ⇒ wp(IF, t ≤ t0)</td>
<td align="right">(2)</td>
</tr>
</table>
or —in an equivalent formulation—
<table width="100%">
<tr>
<td valign="top" width="10%"></td>
<td valign="top">(P <b>and</b> BB) ⇒ wdec(IF, t) for all states</td>
<td align="right">(3)</td>
</tr>
</table>
then for any value of t0 and for all states
<table width="100%">
<tr>
<td valign="top" width="10%"></td>
<td valign="top">(P <b>and</b> BB <b>and</b> wp(DO, T) <b>and</b> t ≤ t0 + 1) ⇒ wp(DO, t ≤ t0)</td>
<td align="right">(4)</td>
</tr>
</table>
or —in an equivalent formulation—
<table width="100%">
<tr>
<td valign="top" width="10%"></td>
<td valign="top">(P <b>and</b> BB <b>and</b> wp(DO, T) ⇒ wdec(DO, t) .</td>
<td align="right">(5)</td>
</tr>
</table>
In words: if the relation P that is kept invariant guarantees that each selected guarded command causes an effective decrease of t, then the repetitive construct will cause an effective decrease of t if it terminates properly after at least one execution of a guarded command. The theorem is so obvious, that it would be a shame if it were difficult to prove, but luckily it is not. We shall show that from (1) and (2) follows that for any a value t0 and all states
<table width="100%">
<tr>
<td valign="top" width="10%"></td>
<td valign="top">(P <b>and</b> BB <b>and</b> H<sub>k</sub>(T) <b>and</b> t ≤ t0 + 1) ⇒ H<sub>k</sub>(t ≤ t0)</td>
<td align="right">(6)</td>
</tr>
</table>
for all k ≥ 0. It holds for k = 0 —because (BB <b>and</b> H<sub>0</sub>(T)) = F — and we have to derive from the assumption that (6) holds for k = K , that it holds for k = K + 1 as well.
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2">(P <b>and</b> BB <b>and</b> H<sub>K+1</sub>(T) <b>and</b> t ≤ t0 + 1)</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp;</td>
<td>⇒ wp(IF, P) <b>and</b> wp(IF, H<sub>K</sub>(T)) <b>and</b> wp(IF, t ≤ t0)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>⇒ wp(IF, P <b>and</b> H<sub>K</sub>/(T) <b>and</b> t ≤ t0)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>⇒ wp(IF, <b>and</b> BB <b>and</b> H<sub>K</sub>/(T) <b>and</b> t ≤ t0 + 1) <b>or</b> (t ≤ t0 <b>and</b> <b>non</b> BB))</td>
</tr>
<tr>
<td></td>
<td></td>
<td>⇒ wp(IF, H<sub>K</sub>(t ≤ t0) or H<sub>0</sub>(t ≤ t0))</td>
</tr>
<tr>
<td></td>
<td></td>
<td>⇒ wp(IF, H<sub>K</sub>(t ≤ t0))</td>
</tr>
<tr>
<td></td>
<td></td>
<td>⇒ wp(IF, H<sub>K</sub>(t ≤ t0) <b>or</b> H<sub>0</sub>(t ≤ 0))</td>
</tr>
<tr>
<td></td>
<td></td>
<td>⇒ H<sub>K+1</sub>(t ≤ t0)</td>
</tr>
</table>
The first implication follows from (1), the definition of H<sub>K+1</sub>(T) and (2), the equality in the 3rd line is obvious, the implication in the 4th line is derived by taking the conjunction with (BB <b>or</b> <b>non</b> BB) and then weakening both terms, the implication in the 5th line follows from (6) for k = K and the definition of H<sub>0</sub>≤t0) and the rest is straightforward. Thus relation (6) has been proved for all k ≥ 0 and from that result (4) and (5) follow immediately.
<p class="noindent"><b>Exercise</b>. Modify also our second program in such a way that it computes the quotient as well and give a formal correctness proof for your program.</p>
<p>Let us assume next, that there is a small number, 3 say, by which we are allowed to multiply and to divide and that these operations are sufficiently fast so that they are attractive to use. We shall denote the product by “m * 3” —or by “3 * m”— and the quotient by “m / 3”; the latter expression will only be called for evalution provided initially m|3 holds. (We are working with integer numbers, aren’t we?)</p>
<p>Again we try to establish the desired relation R by means of a repetitive construct, for which the invariant relation P is derived by replacing a constant by a variable. Replacing the constant d by the variable dd , whose values will be restricted to d *(a power of 3) we come to the invariant relation P:</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>0 ≤ r &lt; dd <b>and</b> (a - r)|dd <b>and</b> (<u>E</u> i: i ≥ 0: dd = d * 3<sup>i</sup>)</td>
</tr>
</table>
We shall establish the relation and then try to reach, while keeping it invariant, a state satisfying d = dd . In order to establish it, we need a further repetitive construct: first we establish
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>0 ≤ r &lt; dd <b>and</b> (a - r)|dd <b>and</b> (<u>E</u> i: i ≥ 0: dd = d * 3<sup>i</sup>)</td>
</tr>
</table>
and then let dd grow until it is large enough and r &lt; dd is satisfied as well. The following program would do:
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="3"><b>if</b> a ≥ 0 <b>and</b> d &gt; 0 →</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp;</td>
<td colspan="2">r, dd = a, d;</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2"><b>do</b> r ≥ dd → dd:= dd * 3 <b>od</b>;</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2"><b>do</b> dd ≠ d → dd:= dd / 3;</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td><b>do</b> r ≥ dd → r:= r - dd <b>od</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2"><b>od</b></td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>fi</b></td>
</tr>
</table>
<p class="noindent"><b>Exercise</b>. Modify also the above program in such a way that it computes the quotient as well and give a formal correctness proof for your program. This proof has to demonstrate that whenever dd / 3 is computed, originally dd|3 holds. The above program exhibits a quite common characteristic. On the outer level we have two repetitive constructs in succession; when we have two or more repetitive constructs on the same level in succession, the guarded commands of the later ones lend to be more elaborate than those of the earlier ones. (This is known as “Dijkstra’s Law”, which does not always hold.) The reason for this tendency is clear: each repetitive construct adds his “<b>and</b> <b>non</b> BB” to the relation it keeps invariant and that additional relation has to be kept invariant by the next one as well. But for the inner loop, the second one is exactly the inverse of the first one; but it is precisely the function of the added statement <b>do</b> r ≥ dd → r:= r - dd <b>od</b> to restore the potentially destroyed relation r &lt; dd , i.e. the achievement of the first loop.</p>
<p><b>Fourth example</b>.</p>
<p>For fixed Q1 , Q2 , Q3 and Q4 it is requested to establish R where R is given as R1 <b>and</b> R2 with R1: The sequence of values (q1, q2, q3, q4) is a permutation of the sequence of values (Q1, Q2, Q3, Q4) R2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q1 ≤ q2 ≤ q3 ≤ q4 .</p>
<p>Taking R1 as relation P to be kept invariant a possible solution is</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="2">q1, q2, q3, q4:= Q1, Q2, Q3. Q4;</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>do</b> q1 &gt; q2 → q1, q2:= q2, q1</td>
</tr>
<tr>
<td></td>
<td>&nbsp;</td>
<td>▯ q2 &gt; q3 → q2, q3:= q3, q2</td>
</tr>
<tr>
<td></td>
<td></td>
<td>▯ q3 &gt; q4 → q3, q4:= q4, q3</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>od</b></td>
</tr>
</table>
The first assignment obviously establishes P and no guarded command destroys it. Upon termination we have <b>non</b> BB , and that is relation R2. The way in which people convince themselves that it does terminate depends largely on their background: a mathematician might observe that the number of inversions decreases,an operations researcher will interpret it as maximizing q1 + 2*q2 + 3*q3 + 4*q4 and I, as a physicist, just “see” the center of gravity moving in the one direction (to the right, to be quite precise). The program is remarkable in the sense that, whatever we would have chosen for the guards, never would there be the danger of destroying relation P : the guards are in this example a pure consequence of the requirement of termination.
<p class="noindent"><b>Note.</b> Observe that we could have added other alternatives such as</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>q1 &gt; q3 → q1, q3:= q3, q1</td>
</tr>
</table>
as well; they cannot be used to replace one of the given three. (End of note.)
<p>It is a nice example of the kind of clarity that our non-determinacy has made possible to achieve; needless to say, however, that I do not recommend to sort a large number of values in an analogous manner.</p>
<p><b>Fifth example</b>.</p>
<p>We are requested to design a program approximating a square root, more precisely: for fixed n (n ≥ 0) the program should establish</p>
<table width="100%">
<tr>
<td valign="top" width="20%">R:</td>
<td>a<sup>2</sup> ≤ n <b>and</b> (a + 1)<sup>2</sup> &gt; n .</td>
</tr>
</table>
<p>One way of weakening this relation is dropping one of the terms of the conjunction, e.g. the last one and focus upon</p>
<table width="100%">
<tr>
<td valign="top" width="20%">P:</td>
<td>a<sup>2</sup> ≤ n</td>
</tr>
</table>
a relation that is obviously satisfied by a 0 , so that the initialization need not bother us. We observe that if the second term is not satisfied this is due to the fact that a is too small and we could therefore consider the statement “a:= a + 1”. Formally we find
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wp(“a:= a + 1”, P) = ((a + 1)<sup>2</sup> ≤ n) .</td>
</tr>
</table>
Taking this condition as — the only!— guard, we have (P <b>and</b> <b>non</b> BB = R and therefore we are invited to consider the program
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="3"><b>if</b> n ≥ 0 →</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="2">a:= 0 {P has been established};</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2"><b>do</b>(a + 1)<sup>2</sup> ≤ n → a:= a + 1 {P has not been destroyed} <b>od</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp;</td>
<td>{R has been established}</td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>fi</b> {R has been established}</td>
</tr>
</table>
all under the assumption that the program terminates, what it does thanks to the fact that the square of a non-negative number is a monotonicly increasing function: we can take for t the function n - a<sup>2</sup>
<p>This program is not very surprising, it is not very efficient either: for large values of n it could be rather time-consuming. Another way of generalizing R is the introduction of another variable, b say —and again restricting its range— that is to replace part of R, for instance</p>
<table width="100%">
<tr>
<td valign="top" width="20%">P:</td>
<td>a<sup>2</sup> ≤ n <b>and</b> b<sup>2</sup> &gt; n <b>and</b> 0 ≤ a &lt; b</td>
</tr>
</table>
By the way this has been chosen it has the pleasant property that
<table width="100%">
<tr>
<td valign="top" width="20%"></td>
<td>(P <b>and</b> (a + 1 = b)) ⇒ R</td>
</tr>
</table>
Thus we are led to consider a program of the form —from now onwards omitting the <b>if</b> n ≥ → .... <b>fi</b>—
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>a, b:= 0, n + 1 {P has been established};</td>
</tr>
<tr>
<td></td>
<td><b>do</b> a + 1 ≠ b → decrease b - a under invariance of P <b>od</b></td>
</tr>
<tr>
<td></td>
<td>{R has been established} .</td>
</tr>
</table>
Let each time the guarded command is executed d be the amount by which the difference b - a is decreased. Decreasing this difference can he done by either decreasing b or by increasing a or both. Without loss of generality we can restrict ourselves to such steps in which either a or b is changed, but not both: if a is too small and b is too large and in one step only b is decreased, then a can be increased in a next step. This consideration leads to a program of the following form
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="3">a, b:= 0, n + 1 {P has been established};</td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>do</b> a + 1 ≠ b →</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2">d:= ... {d has a suitable value and P is still valid};</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2"><b>if</b> ... → a:= a + d {P has not been destroyed}</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td>▯ ... → b:= b - d {P has not been destroyed}</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2"><b>fi</b> {P has not been destroyed}</td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>od</b> {R has been established}</td>
</tr>
</table>
Now
<table width="100%">
<tr>
<td valign="top" width="20%"></td>
<td>wp(“a:= a + d”, P) = ((a + d)<sup>2</sup> ≤ n <b>and</b> b<sup>2</sup> &gt; n)</td>
</tr>
</table>
which, because p implies the second term leads to the first one as our first guard; the second guard is derived similarly and our next form is
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="3">a, b:= 0, n + 1</td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>do</b> a + 1 ≠ b → d:= ...;</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>if</b> {a + d<sup>2</sup>) ≤ n → a:= a + d</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td>▯ (b - d<sup>2</sup>) &gt; n → b:= b - d</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2"><b>fi</b> {P has not been destroyed}</td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>od</b> {R has been established}</td>
</tr>
</table>
We are still left with a suitable choice for d . Because we have chosen b - a —well: b - a → 1 actually— as our function t , effective decrease implies that d must satisfy d &gt; 0 . Furthermore the following alternative construct may not lead to abortion, i,e, at least one of the guards must be true. That is, the negation of the first: (a + d)<sup>2</sup> &gt; n must imply the other: (b . d)<sup>2</sup> &gt; n ; this is guaranteed if
<table width="100%">
<tr>
<td valign="top" width="20%"></td>
<td>a + d ≤ b - d</td>
</tr>
<tr>
<td valign="top">or</td>
<td>2 * d ≤ b - a .</td>
</tr>
</table>
Besides a lower bound we have also found an upper bound for d . We could choose d : 1 , but the larger d , the faster the program and therefore we propose:
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="3">a, b:= 0, n + 1</td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>do</b> a + 1 ≠ b → d:= (b - a) <b>div</b> 2;</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>if</b> {a + d<sup>2</sup>) ≤ n → a:= a + d</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td>▯ (b - d<sup>2</sup>) &gt; n → b:= b - d</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2"><b>fi</b> {P has not been destroyed}</td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>od</b> {R has been established}</td>
</tr>
</table>
where n <b>div</b> 2 is given by n/2 if n|2 and by (n - 1)/2 if (n - 1)|2 .
<p>The use of the operator <b>div</b> suggests that we should look what happens if we impose upon ourselves the restricition that whenever d is computed, b - a should be even. Introducing c = b - e and eliminating the b , we get the invariant relation</p>
<table width="100%">
<tr>
<td valign="top" width="10%">P:</td>
<td>a<sup>2</sup> ≤ n <b>and</b> (c + a)<sup>2</sup> &gt; n <b>and</b> (E i: i ≥ 0: c = 2<sup>i</sup>)</td>
</tr>
</table>
and the program (in which the roles of c and d have coincided)
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="3">a, c:= 0, 1;<b>do</b> c<sup>2</sup> ≤ n → c:= 2 * c <b>od</b></td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>do</b> c ≠ 1 → c:= c/2;</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>if</b> {a + c<sup>2</sup>) ≤ n → a:= a + c</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td>▯ (a + c<sup>2</sup>) &gt; n → skip</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2"><b>fi</b></td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>od</b> .</td>
</tr>
</table>
<b>Note</b>. This program is very much like the last program for the third example, the computation of the remainder under the assumption that we could multiply and divide by 3 . The alternative construct in our above program could have been replaced by
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td><b>do</b> (a + c)<sup>2</sup> ≤ n → a:= a + c <b>od</b></td>
</tr>
</table>
If the condition for the remainder 0 ≤ r &lt; d would have been rewritten as r &lt; d <b>and</b> (r + d) ≥ d the similarity would be even more striking. (End of note.)
<p>Under admission of the danger of beating this little example to death, I would like to submit the last version to yet another transformation. We have written the program under the assumption that sqaring a number is among the repertoire of available operations, but suppose it is not and suppose that multiplying and dividing by (small) powers of 2 are the only (semi-)multiplicative operations at our disposal. Then our last program as it stands is no good i.e. it is no good if we assume that the values of the variables as directly manipulated by the machine are to be equated to the values of the variables a and c if this computation were performed “in abstracto”. To put it in another way: we can consider a and c as abstract variables whose values are represented —according to a convention more complicated than just identity— by the values of other variables that are in fact manipulated by the machine. Instead of directly manipulating a and c , we can let the machine manipulate p , q and r , such that</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>p = a * c</td>
</tr>
<tr>
<td></td>
<td>q = c<sup>2</sup></td>
</tr>
<tr>
<td></td>
<td>r = n - a<sup>2</sup> .</td>
</tr>
</table>
It is a co-ordinate transformation and to each path through our (a,c)-space corresponds a path through our (p,q,r)-space. Not always the other way round, for the values of p , q and r are not independent: in terms of p , q and r we have redundancy and therefore the potential to trade some storage space against not only computation time but even against the need to square! (The transformation from a point in (a,c)-space to a point in (p,q,r)-space has quite clearly been constructed with that objective in mind.) We can now try to translate all boolean expressions and moves in (a,c)-space into the corresponding boolean expressions and moves in (p,q,r)-space. If this can be done in terms of the there permissible operations, we have been successful. The transformation suggested is indeed adequate and the following program is the result (the variable h has been introduced for a very local optimization):
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="3">p, q, r:=0, 1, n; <b>do</b> q≤ n → q:= q * 4 <b>od</b></td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>do</b> q ≠ 1 → q:= q / 4; h:= p + q; p:=p / 2 {h = 2 * p + q};</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>if</b> r ≥ h → p, r:=p + q, r - h</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td>▯ r &lt; h → skip</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2"><b>fi</b></td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>od</b> {p has the value desired for a}</td>
</tr>
</table>
<p>This fifth example has been included because it relates —in an embellished form— a true design history. When the youngest of our two dogs was only a few months old I walked with both of them one evening, preparing my lectures for the next morning, when I would have to address students with only a few weeks exposure to programming, and I wanted a simple problem such that I could “massage” the solutions. During that one hour walk the first, third and fourth program were developed in that order, but for the fact that the correct introduction of h in the last program was something I could only manage with the aid of pencil and paper after I had returned home. The second program, the one manipulating a and b , which here has been presented as a stepping stone to our third solution, was only discovered a few weeks later —be it in a less elegant form then presented here. A second reason for its inclusion is the relation between the third and the fourth program: with respect to the latter one the other one represents our first example of so-called representational abstraction.</p>
<p><b>Sixth example</b>.</p>
<p>For fixed X (X &gt; 1) and Y (Y ≥ 0) the program should establish</p>
<table width="100%">
<tr>
<td valign="top" width="20%">R:</td>
<td>z = X<sup>Y</sup></td>
</tr>
</table>
under the —obvious— assumption that exponentiation is not among the available repertoire. This problem can be solved with the aid of an “abstract variable” , h say; we shall do it with a loop, for which the invariant relation is
<table width="100%">
<tr>
<td valign="top" width="20%">P:</td>
<td>h * z = X<sup>Y</sup></td>
</tr>
</table>
and our (equally “abstract”) program could be
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>h, z:= X<sup>Y</sup> , 1 {P has been established};</td>
</tr>
<tr>
<td></td>
<td><b>do</b> h ≠ 1 → squeeze h under invariance of P <b>od</b></td>
</tr>
<tr>
<td></td>
<td>{R has been established}</td>
</tr>
</table>
The last conclusion is justified because (P <b>and</b> h = 1) ⇒ R . The above program will terminate under the assumption that a finite number of applications of the operation “squeeze” will have established h = 1. The problem, of course, is that we are not allowed to represent the value of h by that of a concrete variable directly manipulated by the machine: if we were allowed to do that, we could have assigned the value of X<sup>Y</sup> immediately to z , not bothering about introducing h at all. The trick is that we can introduce two —at this level concrete— variables, x and y say, to represent the current value of h and our first assignment suggests as convention for this representation
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>h = x<sup>y</sup></td>
</tr>
</table>
The condition “h ≠ 1” then translates into “y ≠ 0” and our next task is to discover an implementable operation “squeeze”. Because the product h * z must remain invariant under squeezing, we should divide h by the same value by which z is multiplied. In view of the way in which h is represented, the current value of x is the most natural candidate. Without any further problems we arrive at the translation of our abstract program
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>x, y, z:= X, Y, 1{P has been established};</td>
</tr>
<tr>
<td></td>
<td><b>do</b> y ≠ 0 → y, z:= y - 1, z * x {P has not been destroyed} <b>od</b></td>
</tr>
<tr>
<td></td>
<td>{R has been established} .</td>
</tr>
</table>
<p>Looking at this program we realize that the number of times control goes through the loop equals the original value Y and we can ask ourselves whether we can speed things up. Well, the guarded command has now the task to bring y down to zero: without changing the <b>value</b> of h , we can investigate whether we can change the <b>representation</b> of that value, in the hope of decreasing the value of y . We are just going to try to exploit that the concrete representation of a value of h as given by x<sup>y</sup> is by no means unique. If y is even we can halve y and square x, and this will not change h at all. Just before the squeezing operation we insert the transformation towards the most attractive representation of h and here is the next program:</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2">x, y, z:= X, Y, 1;</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>do</b> y ≠ 0 → <b>do</b> y|2 → x, y:= x * x, y / 2 <b>od</b>;</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>y, z:= y - 1, z * x</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>od</b> {R has been established}</td>
</tr>
</table>
There exists one value that can be halved indefinitely without becoming odd and that is the value 0, in other words: the outer guard ensures that the inner repetition terminates.
<p>I have included this example for various reasons. The discovery that a mere insertion of what on the abstract level acts like an empty statement could change an algorithm invoking a number of operations proportional to Y into one invoking a number of operations only proportional to log(Y) startled me when I made it. This discovery was a direct consequence of my forcing myself to think in terms of a single abstract variable. The exponentiation program I knew was the following:</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="2">x, y, z:= X, Y, 1;</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>do</b> y ≠ 0 → <b>if</b> <b>non</b> y|2 → y, z:= y - 1, z * x ▯ y|2 → skip <b>fi</b></td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>x, y:= x * x, y / 2</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>od</b></td>
</tr>
</table>
This latter program is very well known, it is a program that many of us have discovered independently of each other. Because the last squaring of x when y has reached the value 0 is clearly superfluous, this program has often been cited as supporting the need for what were called “intermediate exits”. in view of our second program I come to the conclusion that this support in weak.
<p><b>Seventh example</b>,</p>
<p>For a fixed value of n (n ≥ 0) a function f(i) is given for 0 ≤ i &lt; N . Assign to the boolean variable “allsix” the value such that eventually</p>
<table width="100%">
<tr>
<td valign="top" width="20%">R:</td>
<td>allsix = (<u>A</u> i: 0 ≤ i &lt; n: f(i) = 6)</td>
</tr>
</table>
holds. (This example shows some similarity to the Second Example of this chapter. Note, however, that in this example, n = 0 is allowed as well. In that case the range for i for the all-quantifier “<u>A</u>” is empty and allsix = true should hold.) Analogous to what we did in the second Example the invariant relation
<table width="100%">
<tr>
<td valign="top" width="20%">P:</td>
<td>(allsix = (<u>A</u> i: 0 ≤ i &lt; n: f(i) = 6)) <b>and</b> 0 ≤ j ≤ n</td>
</tr>
</table>
suggests itself, because it is easily established for j = 0 , while (P <b>and</b> i = n) ⇒ R . The only thing to do is to investigate how to increase j under invariance of P . We therefore derive
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>wp(“j:=j +1”. P) =</td>
</tr>
<tr>
<td></td>
<td>(allsix = (<u>A</u> i: 0 ≤ i &lt; j + 1: f(i)=6)) <b>and</b> 0 ≤ j + 1 ≤ n .</td>
</tr>
</table>
The last term is implied by P <b>and</b> j ≠ m ; it presents no problem because we had already decided that j ≠ n as a guard is weak enough to conclude R upon termination. The weakest pre-condition that the assignment
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>allsix;:= allsix and f(j) = 6</td>
</tr>
</table>
will establish the other term is
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(allsix <b>and</b> f(j) = 6) = (<u>A</u> i: 0 ≤ i &lt; j + 1: f(i) = 6) .</td>
</tr>
</table>
a condition that is implied by P. We thus arrive at the program
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2">allsix, j:= <b>true</b>, 0;</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>do</b> j ≠ n → allsix:= allsix and f(j) = 6;</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td>j:= j + 1</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>od</b></td>
</tr>
</table>
(In the guarded command we have not used the concurrent assignment for no particular reason.)
<p>By the time that we read this program —or perhaps already earlier— we should get the uneasy feeling that as soon as a function value ≠ 6 has been found, there is not much point in going on. And indeed, although (P <b>and</b> j = n) ⇒ R , we could have used the weaker</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>(P <b>and</b> (j = n <b>or</b> <b>non</b> allsix)) ⇒ R</td>
</tr>
</table>
leading to the stronger guard “j ≠ n and allsix” and to the program
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>allsix, j:= true, 0;</td>
</tr>
<tr>
<td></td>
<td><b>do</b> j ≠ n <b>and</b> allsix → allsix, j:= f(j) = 6, j + 1 <b>od</b> .</td>
</tr>
</table>
(Note the simplification of the assignment to allsix , a simplification that is justified by the stronger guard.)
<p class="noindent"><b>Exercise</b>. Give for the same problem the correctness proof for</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>if</b> n = 0 → allsix:= true</td>
</tr>
<tr>
<td></td>
<td colspan="2">▯ n &gt; 0 → j:= 0;</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td><b>do</b> j ≠ n - 1 <b>and</b> f(j) = 6 → j:= j + 1 <b>od</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td>allsix:= f(j) = 6</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>fi</b></td>
</tr>
</table>
and also for the still more tricky program (that does away with the need to invoke the function from more than one place in the program)
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>j:= 0;</td>
</tr>
<tr>
<td></td>
<td><b>do</b> j ≠ n <b>cand</b> f(j) = 6 → j:= j + 1 <b>od</b></td>
</tr>
<tr>
<td></td>
<td>allsix:= j = n</td>
</tr>
</table>
(Here the condition conjunction operator “<b>cand</b>” has been used in order to do justice to the fact that f(n) need not be defined.) The last program is one, that some people like very much.
<p><b>Eighth example</b>.</p>
<p>Before I can state our next problem, I must first give some definitions and a theorem. Let p = (p<sub>0</sub>, p<sub>1</sub>, ... , p<sub>n-1</sub>) be a permutation of n (n &gt; 1) different values p<sub>i</sub> (0 ≤ i &lt; n), i.e. (i ≠ j) ⇒ (P<sub>i</sub> ≠ P<sub>j</sub>) . Let q = (q<sub>0</sub>, q<sub>1</sub>, ... , q<sub>n-1</sub>) be a different permutation of the same set of n values. By definition “permutation p precedes q in the alphabetic order” if and only if for the minimum value of k such that p<sub>k</sub> ≠ q<sub>k</sub> we have p<sub>k</sub> &lt; q<sub>k</sub> .</p>
<p>The so-called “alphabetic index<sub>n</sub>” of a permutation of n different values is the ordinal number given to it when we number the n! possible permutation arranged in alphabetic order from 0 through n!-1 For instance, for n = 3 and the set of values 2, 4 and 7 we have</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>index<sub>3</sub>(2, 4, 7) = 0</td>
</tr>
<tr>
<td></td>
<td>index<sub>3</sub>(2, 7, 4) = 1</td>
</tr>
<tr>
<td></td>
<td>index<sub>3</sub>(4, 2, 7) = 2</td>
</tr>
<tr>
<td></td>
<td>index<sub>3</sub>(4, 7, 2) = 3</td>
</tr>
<tr>
<td></td>
<td>index<sub>3</sub>(7, 2, 4) = 4</td>
</tr>
<tr>
<td></td>
<td>index<sub>3</sub>(7, 4, 2) = 5</td>
</tr>
</table>
<p>Let (p<sub>0</sub> p<sub>1</sub> ... p<sub>n</sub>) denote the permutation of the n different values in monotonicly increasing order, i.e. index<sub>n</sub>((p<sub>0</sub> p<sub>1</sub> ... p<sub>n</sub>)) = 0. (For example (4 7 2) = (2, 4, 7) but also (7 2 4) = (2, 4, 7) .)</p>
<p>With the above notation we can formulate the following theorem for n &gt; 1:</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>index<sub>n</sub>(p<sub>0</sub>, p<sub>1</sub>, ..., p<sub>n-1</sub>) =</td>
</tr>
<tr>
<td></td>
<td>index<sub>n</sub>(p<sub>0</sub>,(p<sub>1</sub> p<sub>2</sub> ... p<sub>n-1</sub>)) + index<sub>n</sub>(p<sub>1</sub>, p<sub>2</sub>, ..., p<sub>n-1</sub>)</td>
</tr>
</table>
(e.g. index<sub>3</sub>(4, 7, 2) = index<sub>3</sub>(4, 2, 7) + index<sub>2</sub>(7, 2) = 2 + 1 = 3 .) In words: the index<sub>n</sub> of a permutation of n different values is the index<sub>n</sub> of the alphabeticaly first one with the same leftmost value increased by the index<sub>n-1</sub> of the permutation of the remaining rightmost n-1 values.<br />
As a corrolary: from
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>p<sub>n-k</sub> &lt; p<sub>n-k+1</sub> &lt; ... &lt; p<sub>n-1</sub></td>
</tr>
</table>
follows that index<sub>n</sub>(p<sub>0</sub>, p<sub>1</sub>, ... , p<sub>n-1</sub> ) is a multiple of k! and vice versa .
<p>After these preliminaries we can describe our problem. We have a row of n positions (n &gt; 1) numbered in the order from left to right from 0 through n-1 ; in each position lies a card with a value written on it such that no two different cards show the same value.</p>
<p>When at any moment c<sub>i</sub> (0 ≤ i &lt; n) denotes the value on the card in position i , we have initially</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>c0 &lt; c<sub>1</sub> &lt; ... &lt; c<sub>n-1</sub></td>
</tr>
</table>
(i.e. the cards lie sorted in the order of increasing value). For given value of r (0 ≤ r &lt; n!) we have to rearrange the cards such that in the
<table width="100%">
<tr>
<td valign="top" width="20%">R:</td>
<td>index<sub>n</sub>(c<sub>0</sub>, c<sub>1</sub>, ... , c<sub>n-1</sub>) = r .</td>
</tr>
</table>
the only way in which our mechanism can interfere with the cards is via the execution of the statement
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>cardswap(i, j) with 0 ≤ i, j &lt; n</td>
</tr>
</table>
that will interchange the cards in positions i and j if i ≠ j (and will do nothing if i = j).
<p>In order to perform this transformation we must find a class of states —all satisfying a suitable condition P1— such that both initial and final states are specific instances of that class. Introducing a new variable, s say, an obvious candidate for P1 is</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>index<sub>n</sub>(c<sub>0</sub>, c<sub>1</sub>, ... , c<sub>n-1</sub>) = s</td>
</tr>
</table>
as this is easily established initially (viz. by “s:= 0”) and (P1 <b>and</b> s = r) ⇒ R .
<p>Again we ask, whether we can think of restricting the range of s and in view of its initial value we might try</p>
<table width="100%">
<tr>
<td valign="top" width="20%">P1:</td>
<td>index<sub>n</sub>(c<sub>0</sub>, c<sub>1</sub>, ... , c<sub>n-1</sub>) = s <b>and</b> 0 ≤ s ≤ r</td>
</tr>
</table>
which would lead to a program of the form
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2">s:= 0 {P1 has been established};</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>do</b> s ≠ r → {P1 <b>and</b> s &lt; r}</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>increase s by a suitable amount under</td>
</tr>
<tr>
<td></td>
<td></td>
<td>invariance of P1 {P1 still holds}</td>
</tr>
<tr>
<td></td>
<td colspan="2"><b>od</b> {R has been established}</td>
</tr>
</table>
<p>Our next concern is, what to choose for “a suitable amount”. Because our increase of s must be accompanied by a reaarngement of the cards in order to keep P1 invariant, it seems wise to investigate whether we can find conditions, under which a single cardswap corresponds to a known increase of s . Let for a value of k satisfying 1 ≤ k &lt; n hold</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>c<sub>n-k</sub> &lt; c<sub>n-k+1</sub> &lt; ... &lt; c<sub>n-1</sub> ;</td>
</tr>
</table>
this assumption is equivalent with the assumption k!|s —read: “k! divides s”—. Let i = n-k-1 , i.e. c<sub>i</sub> is the value on the card to the immediate left of this sequence. Let furthermore c<sub>i</sub> &lt; c<sub>n-1</sub> and let c<sub>j</sub> be for j in the range n-k ≤ j &lt; n the minimum value such that c<sub>i</sub> &lt; c<sub>j</sub> (i.e. c<sub>j</sub> is the smallest value to the right of c<sub>i</sub> exceeding the latter). In that case the operation cardswap(i, j) leaves the rightmost k values in the same monotonic order and our theorem about permutations and their indices tells us that k! is the corresponding increase of s. It also tells us that when besides k!|s we have
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>s ≤ r &lt; s + k!</td>
</tr>
</table>
c<sub>0</sub> through c<sub>n-k-1</sub> have attained their final value.
<p>I therefore suggest to strengthen our original invariant relation P1 with the additional relation P2 —fixing the function of a new variable k —</p>
<table width="100%">
<tr>
<td valign="top" width="20%">P2:</td>
<td>1 ≤ k ≤ n <b>and</b> k!|s <b>and</b> r &lt; s + k!</td>
</tr>
</table>
which means that the rightmost k cards show still monotonicly increasing values, while the leftmost n-k cards are in their final positions: we have decided upon the “major steps” in which we shall walk towards our destination.
<p>In order to find “the suitable amount” for a major step the machine first determines the largest smaller value of k for which r &lt; s + k! no longer holds — c<sub>i</sub> with i = n-k-1 is then too small, but to the left of it they are all OK— and then increase s by the minimum multiple of k! needed to make r &lt; s + k! hold again; this is done in “minor steps” of k! at a time, simultaneously increasing c, with cards to the right of it. In the following program we introduce the additional variable kfac , satisfying</p>
<table width="100%">
<tr>
<td valign="top" width="20%">P3:</td>
<td>kfac = k!</td>
</tr>
</table>
and for the second inner repetition i and j , such that i = n-k-1 and either j = n or i &lt; j &lt; n <b>and</b> c<sub>j</sub> &gt; c<sub>i</sub> <b>and</b> c<sub>j-1</sub> &lt; c<sub>i</sub> .
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="6">s:= 0 {P1 has been established};</td>
</tr>
<tr>
<td></td>
<td colspan="6">kfac, k: 1, 1 {P3 has been established as well};</td>
</tr>
<tr>
<td></td>
<td colspan="6"><b>do</b> k ≠ n → kfac, k:= kfac *(k+1), k+1 <b>od</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td colspan="3">{P2 has been established as well};</td>
</tr>
<tr>
<td></td>
<td colspan="6"><b>do</b> s ≠ r → {s &lt; r, i.e, at least one, and therefore</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="2">at least two cards have not reached their</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="2">final position}</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td colspan="4"><b>do</b> r &lt; s + kfac → kfac, k:= kfac / k, k - 1 <b>od</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="2">{P1 and P3 have been kept true, but in P2</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="2">the last term is replaced by</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="2">s + kfac &lt; r &lt; s + (k + 1)* kfac};</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td colspan="4">i, j:= n - k - 1, n - k;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td colspan="4"><b>do</b> s + kfac ≤ r → {n - k ≤ j &lt; n}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td>s:= s + kfac; cardswap(i, j); j:= j + 1</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td colspan="4"><b>od</b> {P2 has been restored again: P1 <b>and</b> P2 <b>and</b> P3}</td>
</tr>
<tr>
<td></td>
<td>&nbsp;</td>
<td colspan="5"><b>od</b> {R has been established}</td>
</tr>
</table>
<b>Exercise</b>. Convince yourself of the fact that also the following rather similar program would have done the job:
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="3">s:= 0; kfac, k:=1, 1;</td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>do</b> k ≠ n → kfac, k:= kfac *(k +1), k +1 <b>od</b>;</td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>od</b> k ≠ 1 →</td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="2">kfac, k:= kfac / k, k - 1;</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2">i, j:= n - k - 1, n - k;</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2"><b>do</b> s + kfac ≤ r →</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td>s:= s + kfac; cardswap(i, j); j:= j +1</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2"><b>od</b></td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>od</b></td>
</tr>
</table>
(Hint: the monotonicly decreasing function t ≥ 0 for the outer repetition is t = r - s + k - 1 .)
<hr />
<p class="noindent"><font size="-1">Transcribed by Martin P.M. van der Burgt<br />
Last revision <!-- #BeginDate format:IS1 -->2014-11-15<!-- #EndDate -->
 .</font></p>
</div>
  <script>
$('.body').tweetSelection({
  ellipsis: '...',
  quoteLeft: '\'',
  quoteRight: '\'',
  via: 'raboofje'
});
  </script>
  </body>
  </html>
