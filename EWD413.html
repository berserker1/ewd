<!DOCTYPE html>
<html>
<head>
  <title>The formal treatment of some small examples</title>
  <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
  <link href="assets/transcriptions.css" rel="stylesheet">
  <meta name="generator" content="convertArticle.pl">
</head>
<body>
<div class="metabar">
  <a href="index.html">HOME</a>
</div>
<h1>The formal treatment of some small examples</h1>
<div class='body'><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
 
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1" />
    <title>E.W.Dijkstra Archive: The formal treatment of some small examples (EWD 413)</title>
      <link href="../transcriptions.css" rel="stylesheet" media="screen"/>
   </head>
  <body>
    <div id="frame" align="right">
         <div id="header" align="right">                
        <a href="https://www.cs.utexas.edu/~EWD/ewd04xx/EWD413.PDF"
           title="Link to the PDF version of EWD413">EWD413</a></div></div>
    <hr />
<p class="noindent">NOTE: This transcription was contributed by Martin P.M. van der Burgt, who has devised a process for producing transcripts automatically. Although its markup is incomplete, we believe it serves a useful purpose by virtue of its searchability and its accessibility to text-reading software. It will be replaced by a fully marked-up version when time permits. &mdash;HR
<hr />
<p class="noindent">
<p><b>The formal treatment of some small examples</b>.
<p>In this chapter I shall give the formal development of a series of
small programs solving simple problems. This chapter should <b>not</b> be 
interpreted as my suggestion that these programs must or should be developed
in such a way: such a suggestion would be somewhat ridiculous. I expect
most of my readers to be familiar with most of the examples and, if not,
they can probably write down a program, hardly aware of having to think
about it.
<p>The development, therefore, is given for quite other reasons. One
reason is to make ourselves more familiar with the formalism as far as it
has been developed up to now. A second reason is to convince ourselves
that, in principle at least, the formalism is able to make explicit and
quite rigourous what is often justified with a lot of hand-waving. A third
reason is precisely that most of us are so familiar with them that we have
forgotten how, a long time ago, we have convinced ourselves of their
correctness: in this respect this chapter resembles the beginning lessons
in plane geometry that are traditionally devoted to proving the obvious.
Fourthly, we may occasionally get a little surprise and discover that a
little familiar problem is not so familiar after all. Finally it may shed
some light on the feasibility, the difficulties and the possibilities of
automatic program composition or mechanical assistance in the programming
process. This could be of importance even if we do not have the slightest
interest in automatic program composition, for it may give us a better
appreciation of the role that our inventive powers may or have to play.
In my examples I shall state requirements of the form &ldquo;for fixed
x, y, ... ; this is an abreviation for &ldquo;for any values X0 , y0, ... a
post-condition of the form x = x0 <b>and</b> y = y0 <b>and</b> ... should give rise
to a pre-condition implying x = x0 <b>and</b> y = y0 <b>and</b> &rdquo;. We shall guarantee
this by treating such quantities as &ldquo;temporary constants&rdquo;, they will not
occur to the left of an assigment statement.
<p><b>First example</b>.
Establish for fixed x and y the relation R(m):
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      (m = x <b>or</b> m = y) <b>and</b> m &ge;x <b>and</b> m &ge; y   . </td> </tr>
</table>
For general values of x and y the relation m = x can only be established
by the assignment m:= x; as a consequence (m = x <b>or</b> m = y) can only be
established by activating either m:= x or m:= y. In flow-chart form
<br><img src="ewd413img1.png" border=0><br>
The point is that at the entry the good choice must be made so as
to guarantee that upon completion R(m) holds. For this purpose we &ldquo;push
the post-condition through the alternatives&rdquo;:
<br><img src="ewd413img2.png" border=0><br>
and we have derived the guards! As   
<table width=100%><tr><td valign=top width=10%>
</td><td>R(x) = ((x = x <b>or</b> x = y) <b>and</b> x &ge; x <b>and</b> x &ge; y) = (x &ge; y)
</td></tr>
<tr><td valign=top>
and</td><td>R(y) = ((y = x <b>or</b> y = y) <b>and</b> y &ge; x <b>and</b> y &le; y) = (y &ge; x)
</td>  </tr>  </table>
we arrive at our solution:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; </td> <td>
   <b>if</b> x .&ge; y &rarr; x &#x25af; y &ge; x &rarr; m:= y <b>fi</b> </td> </tr>
</table>
Because (x &ge; y <b>or</b> y &ge; x) = T , the program will never abort (and in passing
we have given an existence proof: for any values x and y there exists
an m satisfying R(m) ). Because (x &ge; y <b>and</b> y &ge; x) &ne; F , our program
is not necessarily deterministic: if initially x = y , it is 
undetermined which of the two assignments will be selected for execution; this
non-determinacy is fully correct, because we have shown that the choice
does not matter.
<p><b>Note</b>. If the function &ldquo;max&rdquo; had been an available primitive, we could
have coded  m:= max(x, y) because R(max(x, y)) = T (End of note.)
<p>The program we have derived is not very impressive; on the other
hand we observe that in the process of deriving the program from our 
postcondition next to nothing has been left to our invention.
<p><b>Second example</b>.
<p>For a fixed value of n (n &gt; 0) a function f(i) is given for
0 &le; i &lt; n . Establish the truth of R:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      0 &le; k &lt; n <b>and</b> (<u>A</u> i: 0 &le; i &lt; n: f(k) &ge; f(i))    . </td> </tr>
</table>
Because our program must work for any positive value of n it is
hard to see how R can be established without a loop; we are therefore
looking for a relation P that is easily established to start with and
such that eventually (P <b>and</b> <b>non</b> BB) &rArr; R . In search of P we are therefore
looking for a relation weaker than R , in other words: we want a 
generalization of our final state. A standard way of generalizing a relation is
the replacement of a constant by a variable &mdash;possibly with a restricted
range&mdash; and here my experience suggests that we replace the constant n
by a new variable, j say, and take for P:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      0 &le; k &lt; j &le; n <b>and</b> (<u>A</u> i: 0 &le; i &lt; j : f(k) &ge; f(i)) </td> </tr>
</table>
where the condition j &le; n has been added in order to do justice to the
finite domain of the function f . Then, with such a generalization, we
have trivially  
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                (P <b>and</b> n = j) &rArr; R      . </td> </tr>
</table>
<p>In order to verify whether this choice of P can be used, we must
have an easy way of establishing it to start with. Well, because
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      (k = 0 <b>and</b> j = 1) &rArr; P      . </td> </tr>
</table>
we venture the following structure for our program -comments being added
between braces
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      k, j:= 0, 1 {P has been established};                                          </td> </tr> <tr> <td></td> <td>
      <b>do</b> j &ne; n &rarr; a step towards j = n under invariance of P <b>od</b> </td> </tr> <tr> <td></td> <td>
      {R has been established}  .                                                    </td> </tr>
</table>
<p>Again my experience suggests to choose as monotonicly decreasing
function t of the current state t = (n - j) , which, indeed, is such
that P &rArr; (t &ge;0) . In order to ensure this monotonic decrease of t
I propose to subject j to an increase by 1 and we can develop
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
     wp(&ldquo;j:= j + 1&rdquo;, P) =                                                                   </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td>
        0 &le; k &lt; j + 1 &le; n <b>and</b> (<u>A</u> i:0 &le; i &lt; j + 1: f(k) &ge; f(i)) =               </td> </tr> <tr> <td></td> <td></td> <td>
        0 &le; k &lt; j + 1 &le; n <b>and</b> (<u>A</u> i:0 &le; i &lt; j: f(k) &ge; f(i)) and f(k) &ge; f(j). </td> </tr>
</table>
The first two terms are implied by P <b>and</b> j &ne; n (for (j&le;n <b>and</b> j&ne;n) &rArr;
(j + 1 &le; n) and this is the reason why we decided to increase j only by 1.)
Therefore 
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
            (P <b>and</b> j &ne; n <b>and</b> f(k) &ge; f(j)) &rArr; wp(&ldquo;j:= j + 1&rdquo;, P) </td> </tr>
</table>
and we can take the last condition as guard. The program
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      k, j := 0, 1;                                                                         </td> </tr> <tr> <td></td> <td>
      <b>do</b> j &ne; n &rarr; <b>if</b> f(k) &ge; f(j) &rarr; j:= j + 1 <b>fi</b> <b>od</b> </td> </tr>
</table>
will indeed give the good answer when it terminates properly. Proper 
termination, however, is not guaranteed, because the alternative construct
might lead to abortion &mdash;and it will certainly do so, if k = 0 does
not satisfy R . If f(k) &ge; f(j) does not hold, we can make it hold
by the assignment k:= j and therefore our next investigation is
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
     wp(&ldquo;k, j:=j, j + 1&rdquo;, P) =                                              </td> </tr> <tr> <td></td> <td>
     0 &le; j &lt; j + 1 &le; n <b>and</b> (<u>A</u> i: 0 &le;_i &lt; j + 1: f(j) &ge; f(i)) = </td> </tr> <tr> <td></td> <td>
     0 &le; j &lt; j + 1 &le; n <b>and</b> (<u>A</u> i: 0 &le;_i &lt; j: f(j) &ge; f(i)) =     </td> </tr>
</table>
To our great relief we see that
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      (P and j &ne; n <b>and</b> f(k) &le; f(j))&rArr; wp(&ldquo;k, j:= j, j + 1&rdquo;, P) </td> </tr>
</table>
and the following program will do the job without the danger of abortion:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
   k, j:= 0, 1;                                                                     </td> </tr> <tr> <td></td> <td colspan = 2>
   <b>do</b> j &ne; n &rarr; <b>if</b> f(k) &ge; f(j) &rarr; j:= j + 1              </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
            &#x25af; f(k) &le; f(j) &rarr; k, j:= j, j + 1 <b>fi</b> <b>od</b>    . </td> </tr>
</table>
A few remarks are in order. The first one is that, as the guards of
the alternative construct do not necessarily exclude each other, the program
harbours the same kind of internal non-determinacy as the first example.
Externally it may display this non-determinacy as well. The function f
could be such that the final value of k is not unique: in that case our
program can deliver any acceptable value!
<p>The second remark is that having developed a correct program does
not mean that we are through with the problem. Programming is as much a
mathematical discipline as an engineering discipline, correctness is as
much our concern as, say, efficiency. Under the assumption that the
computation of a value of the function f for a given argument is a
relatively time-consuming operation, a good engineer should observe that in
all probability this program will often ask for many re-computations of
f(k) for the same value of k . If this is the case the trading of some
storage space against some computation time is indicated. The effort to
make our program more time-efficient, however, should never be an excuse
to make a mess of it. (This is obvious, but I state it explicitly because
so much messiness is so often defended by an appeal to efficiency 
considerations, while upon closer inspection the defense is always unvalid: it
must be, for a mess is never defensible.) The orderly technique for trading
storage space versus computation time is the introduction of one or more
redundant variables, the value of which can be used because some relation
is kept invariant. In this example the observation of the possibly frequent
re-computation of f(k) for the same value of k suggests the introduction
of a further variable, max say, and to extend the invariant relation
with the further term
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
             max = f(k) . </td> </tr>
</table>
This relation must be established upon initialization of k and be kept
invariant &mdash;by explicit assignment to max &mdash; upon modification of k . We
arrive at the following program
<table> <tr> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
   k, j, max := 0, 1, f(0);                                                               </td> </tr> <tr> <td></td> <td colspan = 2>
   <b>do</b> j &ne; n &rarr; <b>if</b> max &ge; f(j) &rarr; j:= j + 1                     </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
            &#x25af; max &le; f(j) &rarr; k, j, max:= j, j + 1, f(k) <b>fi</b> <b>od</b>  </td> </tr>
</table>
<p>This program is probably much more efficient than our previous
version. If it is, a good engineer does not stop here, because he will now
observe that for the same value of j he might order a number of times
the computation of f(j). It is suggested to introduce a further variable,
h say (short For &ldquo;help&rdquo;) and to keep
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      h = f(j) </td> </tr>
</table>
invariant. This, however, is a thing that we cannot do on the same global
level as with oux previous term: the value j = n is not excluded and
for that value f(j) is not necessarily defined. The relation h = f(j)
is therefore re-eslablished every time j &ne; n has just been checked;
upon completion of the outer guarded command&mdash; &ldquo;just before the <b>od</b>&rdquo; so to
speak&mdash; we have h = f(j - 1) but we don&rsquo;t bother and leave it at that.
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
        k, j, max:= 0, 1, f(0);                                                        </td> </tr> <tr> <td></td> <td colspan = 2>
        <b>do</b> j &ne; n &rarr; h:= f(j);                                            </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                <b>if</b> max &ge; h &rarr; j:= j + 1                                  </td> </tr> <tr> <td></td> <td></td> <td>
                &#x25af; max &le; h &rarr; k, j, max:= j, j + 1, h <b>fi</b> <b>od</b> </td> </tr>
</table>
<p>A final remark is not so much concerned with our solution as with
our considerations. We have had our mathematical concerns, we have had
our engineering concerns and we have accomplished a certain amount of
separation between them, now focussing our attention on this aspect and
then on that aspect. While such a separation of concerns is absolutely
essential when dealing with more complicated problems, I must stress that
focussing one&rsquo;s attention on one aspect does not mean completely ignoring
the others. In the more mathematical part of the design activity we should
not head for a mathematically correct program that is so badly engineered
that it is beyond salvation. Similarly, while &ldquo;trading&rdquo; we should not
introduce errors through sloppiness, we should do it careful and systematic;
also, although the mathematical analysis as such has been completed, we
should still understand enough about the problem to judge whether our
considered changes are significant improvements.
<p class="noindent"><b>Note</b>. Prior to my getting used to these formal developments I would always
have used &ldquo;j &lt; n&rdquo; as the guard for this repetitive construct, a habit I
still have to unlearn, for in a case like this, the guard &ldquo;j &ne; n&rdquo; is
certainly to be preferred. The reason for the preference is twofold. The
guard &ldquo;j &ne; n&rdquo; allows us to conclude j = n upon termination without an
appeal to the invariant relation P and thus simplifies the argument about
what the whole construct achieves for us compared with the guard &ldquo;j &lt; n&rdquo;.
Much more important, however, is that the guard &ldquo;j &ne; n&rdquo; makes termination
dependent upon (part of) the invariant relation, viz. j &le; n and is therefore
to be preferred for reasons of robustness. If the addition j:= j + 1 would
erroneously increase j too much and would establish j &gt; n , then the
guard &ldquo;j &lt; n&rdquo; would give no alarm, while the guard &ldquo;j &ne; n&rdquo; would at
least prevent proper termination. Even without taking machine malfunctioning
into account, this argument seems valid. Let a sequence x0, x1, x2, ... be
given by a value for x0 and for i &gt; 0 by x<sub>i</sub>= f(x<sub>i-1</sub>) , where f is
some computable function and let us carefully and correctly keep the
relation X = x<sub>i</sub>, invariant. Suppose that we have in a program a monotonicly
increasing variable n , such that for some values of n we are interested
in x<sub>n</sub> . Provided n &ne; i , we can always establish X = x<sub>n</sub> by
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
     <b>do</b> j &ne; n &rarr; i, X:= i+1, f(X) <b>od</b> . </td> </tr>
</table>
If &mdash;due perhaps to a later change in the program with the result that it
is no longer guaranteed that n can only increase as the computation proceeds&mdash;
the relation n &ge; i does not necessarily hold, the above construct would
(luckily!) fail to terminate, while the use of
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      <b>do</b> j &lt; n &rarr; i, X:= i+1, f(X) <b>od</b> </td> </tr>
</table>
would have failed to establish the relation X = x<sub>n</sub>. The moral of the
story is that, all other things being equal, we should choose our guards
as weak as possible. (End of note.)
<p><b>Third example</b>.
<p>For fixed a (a &ge; 0) and d (d &gt; 0) it is requested to establish
<table width=100%><tr><td valign=top width=10%>
R:</td><td>0 &lt; r &lt; d <b>and</b> (a - r)|d .
</td>  </tr>  </table>
(Here the vertical bar &ldquo;|&rdquo; is to be read as: &ldquo;is a multiple of&rdquo;.) In other
words we are requested to compute the smallest non-negative remainder r
that is left after division of a by d . In order that the problem be
a problem, we have to restrict ourselves to addition and subtraction as
the only aritmetic operations. Because the term (a - r)|d is satisfied
by r = a, an initialization that &mdash;on account of a &ge; 0&mdash; also
satisfies 0 &le; r , it is suggested to choose as invariant relation P:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                 0 &le; r <b>and</b> (a - r)|d . </td> </tr>
</table>
<p>For the function t , the decrease of which should ensure termination,
we choose r itself; because the messaging of r must be such that the
relation (a - r)|d is kept invariant, r may only be changed by a
multiple of d , for instance d itself. Thus we find ourselves invited
to evaluate
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
         wp(&ldquo;r:= r - d&rdquo;, P) <b>and</b> wdec(&ldquo;r:= r - d&rdquo;, r) = </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; </td> <td>
           0 &le; r - d <b>and</b> (a - r + d &gt; 0   .                              </td> </tr>
</table>
<p>Because the term d &gt; 0 could have been added to the invariant
relation P , only the first term is then not implied; we find the
corresponding guard &ldquo;r &ge; d&rdquo; and the tentative program:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      <b>if</b> a &ge; 0 <b>and</b> d &gt; 0 &rarr;    </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td>
         r:= a;                                        </td> </tr> <tr> <td></td> <td></td> <td>
         <b>do</b> r &ge; d &rarr; r:= r - d <b>od</b> </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>fi</b>  .                                     </td> </tr>
</table>
Upon completion the truth of P <b>and</b> <b>non</b> r &ge; d has been established, a
relation that implies R and thus the problem has been solved.
<p>Suppose now, that in addition it would have been required to
assign to q such a value that finally we also have
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                a = d * q + r </td> </tr>
</table>
&mdash;in other words it is requested to compute the quotient as well&mdash; then we
can try to add this term to our invariant relation. Because
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      (a = d * q + r) &rArr; (a = d *(q + 1)+(r - d)) </td> </tr>
</table>
we are led to the program:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      <b>if</b> a &ge; 0 <b>and</b> d &gt; 0 &rarr;              </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td>
         q, r:= 0, a;                                            </td> </tr> <tr> <td></td> <td></td> <td>
         <b>do</b> r &ge; d &rarr; q, r:= q + 1, r - d <b>od</b> </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>fi</b>  .                                               </td> </tr>
</table>
The above programs are, of course, very time-consuming if the quotient
is large. Can we speed it up? The obvious way to do that is to decrease r
by larger multiples of d . Introducing for this purpose a new variable,
dd say, the relation to be established and kept invariant is
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
         dd|d <b>and</b> dd &ge; d  </td> </tr>
</table>
<p>We can speed up our first program by replacing &ldquo;r:= r - d&rdquo; by a
possibly repeated decrease of r by dd , while dd , initially = d ,
is allowed to grow rather rapidly, e.g. by doubling it each time. So we
are led to consider the following program
<table> <tr> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
   <b>if</b> a &ge; 0 <b>and</b> d &gt; 0 &rarr;              </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
       r:= a;                                                 </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
       <b>do</b> r&ge;d &rarr;                                </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td>
          dd:= d;                                             </td> </tr> <tr> <td></td> <td></td> <td></td> <td>
          <b>do</b> r&ge; dd &rarr; r - dd; dd + dd <b>od</b> </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
       <b>od</b>                                              </td> </tr> <tr> <td></td> <td colspan = 3>
   <b>fi</b>                                                  </td> </tr>
</table>
The relation 0 &le; r <b>and</b> (a - r)|d is clearly kept invariant and therefore
this program establishes R if it terminates properly, but does it? Of
course it does, because the inner loop &mdash;that terminates on account of
dd &gt; 0 &mdash; is only activated with initial states satisfying r &ge; dd and
therefore the decrease r:= r - dd is performed at least once for every
repetition of the outer loop.
<p>But the above reasoning &mdash;although convincing enough!&mdash; is a very
informal one and because this chapter is called &ldquo;a formal treatment&rdquo; we
can try to formulate and prove the theorem to which we have appealed
intuitively.
<p>With the usual meanings of IF, DO and BB , let P be the
relation that is kept invariant, i.e.
<table width=100%>
<tr><td valign=top width=10%>  </td></td><td valign=top>
(P <b>and</b> BB) &rArr; wp(IF, P) for all states</td><td align=right>(1)
</td>  </tr>  </table>
and let furthermore i be an integer function such that for any value
of t0 and for all states
<table width=100%>
<tr><td valign=top width=10%>  </td></td><td valign=top>
(P <b>and</b> BB <b>and</b> t &le; t0 + 1) &rArr; wp(IF, t &le; t0)</td><td align=right>(2)
</td>  </tr>  </table>
or &mdash;in an equivalent formulation&mdash;
<table width=100%>
<tr><td valign=top width=10%>  </td></td><td valign=top>
(P <b>and</b> BB) &rArr; wdec(IF, t) for all states</td><td align=right>(3)
</td>  </tr>  </table>
then for any value of t0 and for all states
<table width=100%>
<tr><td valign=top width=10%>  </td></td><td valign=top>
(P <b>and</b> BB <b>and</b> wp(DO, T) <b>and</b> t &le; t0 + 1) &rArr; wp(DO, t &le; t0)</td><td align=right>(4)
</td>  </tr>  </table>
or &mdash;in an equivalent formulation&mdash;
<table width=100%>
<tr><td valign=top width=10%>  </td></td><td valign=top>
(P <b>and</b> BB <b>and</b> wp(DO, T) &rArr; wdec(DO, t) .</td><td align=right>(5)
</td>  </tr>  </table>
In words: if the relation P that is kept invariant guarantees that each
selected guarded command causes an effective decrease of t, then the
repetitive construct will cause an effective decrease of t if it terminates
properly after at least one execution of a guarded command. The theorem is
so obvious, that it would be a shame if it were difficult to prove, but
luckily it is not. We shall show that from (1) and (2) follows that for any
a value t0 and all states
<table width=100%>
<tr><td valign=top width=10%>  </td></td><td valign=top>
(P <b>and</b> BB <b>and</b> H<sub>k</sub>(T) <b>and</b> t &le; t0 + 1) &rArr; H<sub>k</sub>(t &le; t0)</td><td align=right>(6)
</td>  </tr>  </table>
for all k &ge; 0. It holds for k = 0 &mdash;because (BB <b>and</b> H<sub>0</sub>(T)) = F &mdash; and we
have to derive from the assumption that (6) holds for k = K , that it
holds for k = K + 1 as well.
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      (P <b>and</b> BB <b>and</b> H<sub>K+1</sub>(T) <b>and</b> t &le; t0 + 1)                                                             </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; </td> <td>
        &rArr; wp(IF, P) <b>and</b> wp(IF, H<sub>K</sub>(T)) <b>and</b> wp(IF, t &le; t0)                                                  </td> </tr> <tr> <td></td> <td></td> <td>
        &rArr; wp(IF, P <b>and</b> H<sub>K</sub>/(T) <b>and</b> t &le; t0)                                                                 </td> </tr> <tr> <td></td> <td></td> <td>
        &rArr; wp(IF, <b>and</b> BB <b>and</b> H<sub>K</sub>/(T) <b>and</b> t &le; t0 + 1) <b>or</b> (t &le; t0 <b>and</b> <b>non</b> BB)) </td> </tr> <tr> <td></td> <td></td> <td>
        &rArr; wp(IF, H<sub>K</sub>(t &le; t0) or H<sub>0</sub>(t &le; t0))                                                                </td> </tr> <tr> <td></td> <td></td> <td>
        &rArr; wp(IF, H<sub>K</sub>(t &le; t0))                                                                                            </td> </tr> <tr> <td></td> <td></td> <td>
        &rArr; wp(IF, H<sub>K</sub>(t &le; t0) <b>or</b> H<sub>0</sub>(t &le; 0))                                                          </td> </tr> <tr> <td></td> <td></td> <td>
        &rArr; H<sub>K+1</sub>(t &le; t0)                                                                                                  </td> </tr>
</table>
The first implication follows from (1), the definition of H<sub>K+1</sub>(T) and (2),
the equality in the 3rd line is obvious, the implication in the 4th line
is derived by taking the conjunction with (BB <b>or</b> <b>non</b> BB) and then
weakening both terms, the implication in the 5th line follows from (6)
for k = K and the definition of H<sub>0</sub>&le;t0) and the rest is straightforward.
 Thus relation (6) has been proved for all k &ge; 0 and from that
result (4) and (5) follow immediately.
<p class="noindent"><b>Exercise</b>. Modify also our second program in such a way that it computes
the quotient as well and give a formal correctness proof for your program.
<p>Let us assume next, that there is a small number, 3 say, by which
we are allowed to multiply and to divide and that these operations are
sufficiently fast so that they are attractive to use. We shall denote
the product by &ldquo;m * 3&rdquo; &mdash;or by &ldquo;3 * m&rdquo;&mdash; and the quotient by &ldquo;m / 3&rdquo;;
the latter expression will only be called for evalution provided initially
m|3 holds. (We are working with integer numbers, aren&rsquo;t we?)
<p>Again we try to establish the desired relation R by means of
a repetitive construct, for which the invariant relation P is derived
by replacing a constant by a variable. Replacing the constant d by
the variable dd , whose values will be restricted to d *(a power of 3)
we come to the invariant relation P:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
     0 &le; r &lt; dd <b>and</b> (a - r)|dd <b>and</b> (<u>E</u> i: i &ge; 0: dd = d * 3<sup>i</sup>) </td> </tr>
</table>
We shall establish the relation and then try to reach, while keeping it
invariant, a state satisfying d = dd .
In order to establish it, we need a further repetitive construct:
first we establish
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
     0 &le; r &lt; dd <b>and</b> (a - r)|dd <b>and</b> (<u>E</u> i: i &ge; 0: dd = d * 3<sup>i</sup>) </td> </tr>
</table>
and then let dd grow until it is large enough and r &lt; dd is satisfied
as well. The following program would do:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
   <b>if</b> a &ge; 0 <b>and</b> d &gt; 0 &rarr;              </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; </td> <td colspan = 2>
     r, dd = a, d;                                            </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
     <b>do</b> r &ge; dd &rarr; dd:= dd * 3 <b>od</b>;        </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
     <b>do</b> dd &ne; d &rarr; dd:= dd / 3;                  </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
           <b>do</b> r &ge; dd &rarr; r:= r - dd <b>od</b>    </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
     <b>od</b>                                                </td> </tr> <tr> <td></td> <td colspan = 3>
   <b>fi</b>                                                  </td> </tr>
</table>
<p class="noindent"><b>Exercise</b>. Modify also the above program in such a way that it computes the
quotient as well and give a formal correctness proof for your program. This
proof has to demonstrate that whenever dd / 3 is computed, originally
dd|3 holds. 
The above program exhibits a quite common characteristic. On the
outer level we have two repetitive constructs in succession; when we
have two or more repetitive constructs on the same level in succession,
the guarded commands of the later ones lend to be more elaborate than those
of the earlier ones. (This is known as &ldquo;Dijkstra&rsquo;s Law&rdquo;, which does not
always hold.) The reason for this tendency is clear: each repetitive 
construct adds his &ldquo;<b>and</b> <b>non</b> BB&rdquo; to the relation it keeps invariant and that
additional relation has to be kept invariant by the next one as well.
But for the inner loop, the second one is exactly the inverse of the first
one; but it is precisely the function of the added statement
        <b>do</b> r &ge; dd &rarr; r:= r - dd <b>od</b>
to restore the potentially destroyed relation r &lt; dd , i.e. the achievement
of the first loop.
<p><b>Fourth example</b>.
<p>For fixed Q1 , Q2 , Q3 and Q4 it is requested to establish
R where R is given as R1 <b>and</b> R2 with
R1: The sequence of values (q1, q2, q3, q4) is a permutation of the
sequence of values (Q1, Q2, Q3, Q4)
R2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;q1 &le; q2 &le; q3 &le; q4    .                        
<p>Taking R1 as relation P to be kept invariant a possible solution is
<table> <tr> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
   q1, q2, q3, q4:= Q1, Q2, Q3. Q4;            </td> </tr> <tr> <td></td> <td colspan = 2>
   <b>do</b> q1 &gt; q2 &rarr; q1, q2:= q2, q1 </td> </tr> <tr> <td></td> <td>&nbsp; </td> <td>
    &#x25af; q2 &gt; q3 &rarr; q2, q3:= q3, q2 </td> </tr> <tr> <td></td> <td></td> <td>
    &#x25af; q3 &gt; q4 &rarr; q3, q4:= q4, q3 </td> </tr> <tr> <td></td> <td colspan = 2>
   <b>od</b>                                   </td> </tr>
</table>
The first assignment obviously establishes P and no guarded command
destroys it. Upon termination we have <b>non</b> BB , and that is relation R2.
The way in which people convince themselves that it does terminate depends
largely on their background: a mathematician might observe that the number
of inversions decreases,an operations researcher will interpret it as
maximizing q1 + 2*q2 + 3*q3 + 4*q4 and I, as a physicist, just &ldquo;see&rdquo;
the center of gravity moving in the one direction (to the right, to be
quite precise). The program is remarkable in the sense that, whatever we
would have chosen for the guards, never would there be the danger of
destroying relation P : the guards are in this example a pure consequence
of the requirement of termination.
<p class="noindent"><b>Note.</b> Observe that we could have added other alternatives such as
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
        q1 &gt; q3 &rarr; q1, q3:= q3, q1 </td> </tr>
</table>
as well; they cannot be used to replace one of the given three. (End of note.)
<p>It is a nice example of the kind of clarity that our non-determinacy
has made possible to achieve; needless to say, however, that I do not
recommend to sort a large number of values in an analogous manner.
<p><b>Fifth example</b>.                    
<p>We are requested to design a program approximating a square root,
more precisely: for fixed n (n &ge; 0) the program should establish
<table width=100%><tr><td valign=top width=20%>
R:</td><td>a<sup>2</sup> &le; n <b>and</b> (a + 1)<sup>2</sup> &gt; n     .
</td>  </tr>  </table>
<p>One way of weakening this relation is dropping one of the terms
of the conjunction, e.g. the last one and focus upon
<table width=100%><tr><td valign=top width=20%>
P:</td><td> a<sup>2</sup> &le; n
</td>  </tr>  </table>
a relation that is obviously satisfied by a 0 , so that the initialization
need not bother us. We observe that if the second term is not satisfied
this is due to the fact that a is too small and we could therefore
consider the statement &ldquo;a:= a + 1&rdquo;. Formally we find
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
     wp(&ldquo;a:= a + 1&rdquo;, P) = ((a + 1)<sup>2</sup> &le; n) . </td> </tr>
</table>
Taking this condition as &mdash; the only!&mdash; guard, we have (P <b>and</b> <b>non</b> BB = R
and therefore we are invited to consider the program
<table> <tr> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
   <b>if</b> n &ge; 0 &rarr;                                                                    </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      a:= 0 {P has been established};                                                           </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
      <b>do</b>(a + 1)<sup>2</sup> &le; n &rarr; a:= a + 1 {P has not been destroyed} <b>od</b> </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; </td> <td>
       {R has been established}                                                                 </td> </tr> <tr> <td></td> <td colspan = 3>
   <b>fi</b> {R has been established}                                                           </td> </tr>
</table>
all under the assumption that the program terminates, what it does thanks
to the fact that the square of a non-negative number is a monotonicly
increasing function: we can take for t the function n - a<sup>2</sup>
<p>This program is not very surprising, it is not very efficient either:
for large values of n it could be rather time-consuming. Another way of
generalizing R is the introduction of another variable, b say &mdash;and
again restricting its range&mdash; that is to replace part of R, for instance
<table width=100%><tr><td valign=top width=20%>
P:</td><td>a<sup>2</sup> &le; n <b>and</b> b<sup>2</sup> &gt; n <b>and</b> 0 &le; a &lt; b
</td>  </tr>  </table>
By the way this has been chosen it has the pleasant property that
<table width=100%><tr><td valign=top width=20%>
</td><td>(P <b>and</b> (a + 1 = b)) &rArr; R
</td>  </tr>  </table>
Thus we are led to consider a program of the form &mdash;from now onwards
omitting the <b>if</b> n &ge;  &rarr;  .... <b>fi</b>&mdash;
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      a, b:= 0, n + 1 {P has been established};                                    </td> </tr> <tr> <td></td> <td>
      <b>do</b> a + 1 &ne; b &rarr; decrease b - a under invariance of P <b>od</b> </td> </tr> <tr> <td></td> <td>
      {R has been established} .                                                   </td> </tr>
</table>
Let each time the guarded command is executed d be the amount by
which the difference b - a is decreased. Decreasing this difference can
he done by either decreasing b or by increasing a or both. Without loss
of generality we can restrict ourselves to such steps in which either a
or b is changed, but not both: if a is too small and b is too large
and in one step only b is decreased, then a can be increased in a
next step. This consideration leads to a program of the following form
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
     a, b:= 0, n + 1 {P has been established};                      </td> </tr> <tr> <td></td> <td colspan = 3>
     <b>do</b> a + 1 &ne; b &rarr;                                  </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
         d:= ... {d has a suitable value and P is still valid};     </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
         <b>if</b> ... &rarr; a:= a + d {P has not been destroyed}  </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; </td> <td>
           &#x25af; ... &rarr; b:= b - d {P has not been destroyed} </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
         <b>fi</b> {P has not been destroyed}                       </td> </tr> <tr> <td></td> <td colspan = 3>
     <b>od</b> {R has been established}                             </td> </tr>
</table>
Now
<table width=100%><tr><td valign=top width=20%>
</td><td>wp(&ldquo;a:= a + d&rdquo;, P) = ((a + d)<sup>2</sup> &le; n <b>and</b> b<sup>2</sup> &gt; n)
</td>  </tr>  </table>
which, because p implies the second term leads to the first one as our
first guard; the second guard is derived similarly and our next form is
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
     a, b:= 0, n + 1                                            </td> </tr> <tr> <td></td> <td colspan = 3>
     <b>do</b> a + 1 &ne; b &rarr; d:= ...;                     </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
         <b>if</b> {a + d<sup>2</sup>) &le; n &rarr; a:= a + d  </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; </td> <td>
           &#x25af; (b - d<sup>2</sup>) &gt; n &rarr; b:= b - d </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
         <b>fi</b> {P has not been destroyed}                   </td> </tr> <tr> <td></td> <td colspan = 3>
     <b>od</b> {R has been established}                         </td> </tr>
</table>
We are still left with a suitable choice for d . Because we have chosen
b - a &mdash;well: b - a &rarr; 1 actually&mdash; as our function t , effective
decrease implies that d must satisfy d &gt; 0 . Furthermore the following
alternative construct may not lead to abortion, i,e, at least one of the
guards must be true. That is, the negation of the first: (a + d)<sup>2</sup> &gt; n
must imply the other: (b . d)<sup>2</sup> &gt; n ; this is guaranteed if
<table width=100%><tr><td valign=top width=20%>
</td><td>a + d &le; b - d
</td></tr>
<tr><td valign=top>
or</td><td>2 * d &le; b - a .
</td>  </tr>  </table>
Besides a lower bound we have also found an upper bound for d . We could
choose d : 1 , but the larger d , the faster the program and therefore
we propose:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
     a, b:= 0, n + 1                                            </td> </tr> <tr> <td></td> <td colspan = 3>
     <b>do</b> a + 1 &ne; b &rarr; d:= (b - a) <b>div</b> 2;    </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
         <b>if</b> {a + d<sup>2</sup>) &le; n &rarr; a:= a + d  </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; </td> <td>
           &#x25af; (b - d<sup>2</sup>) &gt; n &rarr; b:= b - d </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
         <b>fi</b> {P has not been destroyed}                   </td> </tr> <tr> <td></td> <td colspan = 3>
     <b>od</b> {R has been established}                         </td> </tr>
</table>
where n <b>div</b> 2 is given by n/2 if n|2 and by (n - 1)/2 if (n - 1)|2 .
<p>The use of the operator <b>div</b> suggests that we should look what
happens if we impose upon ourselves the restricition that whenever d
is computed, b - a should be even. Introducing c = b - e and eliminating
the b , we get the invariant relation
<table width=100%><tr><td valign=top width=10%>
P:</td><td>a<sup>2</sup> &le; n <b>and</b> (c + a)<sup>2</sup> > n <b>and</b> (E i: i &ge; 0: c = 2<sup>i</sup>)
</td>  </tr>  </table>
and the program (in which the roles of c and d have coincided)
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
     a, c:= 0, 1;<b>do</b> c<sup>2</sup> &le; n &rarr; c:= 2 * c <b>od</b> </td> </tr> <tr> <td></td> <td colspan = 3>
     <b>do</b> c &ne; 1 &rarr; c:= c/2;                                    </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
         <b>if</b> {a + c<sup>2</sup>) &le; n &rarr; a:= a + c             </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; </td> <td>
           &#x25af; (a + c<sup>2</sup>) &gt; n &rarr; skip                 </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
         <b>fi</b>                                                         </td> </tr> <tr> <td></td> <td colspan = 3>
     <b>od</b>    .                                                        </td> </tr>
</table>
<b>Note</b>. This program is very much like the last program for the third example,
the computation of the remainder under the assumption that we could multiply
and divide by 3 . The alternative construct in our above program could
have been replaced by
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      <b>do</b> (a + c)<sup>2</sup> &le; n &rarr; a:= a + c <b>od</b> </td> </tr>
</table>
If the condition for the remainder 0 &le; r &lt; d would have been rewritten
as r &lt; d <b>and</b> (r + d) &ge; d the similarity would be even more striking.
(End of note.)
<p>Under admission of the danger of beating this little example to
death, I would like to submit the last version to yet another transformation.
We have written the program under the assumption that sqaring a number is
among the repertoire of available operations, but suppose it is not and
suppose that multiplying and dividing by (small) powers of 2 are the
only (semi-)multiplicative operations at our disposal. Then our last
program as it stands is no good i.e. it is no good if we assume that
the values of the variables as directly manipulated by the machine are
to be equated to the values of the variables a and c if this computation
were performed &ldquo;in abstracto&rdquo;. To put it in another way: we can consider
 a and c as abstract variables whose values are represented &mdash;according
to a convention more complicated than just identity&mdash; by the values of
other variables that are in fact manipulated by the machine. Instead of
directly manipulating a and c , we can let the machine manipulate
p , q and r , such that
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
    p = a * c                             </td> </tr> <tr> <td></td> <td>
    q = c<sup>2</sup>                     </td> </tr> <tr> <td></td> <td>
    r = n - a<sup>2</sup>               . </td> </tr>
</table>
It is a co-ordinate transformation and to each path through our (a,c)-space
corresponds a path through our (p,q,r)-space. Not always the other way
round, for the values of p , q and r are not independent: in terms of
p , q and r we have redundancy and therefore the potential to trade
some storage space against not only computation time but even against the
need to square! (The transformation from a point in (a,c)-space to a point
in (p,q,r)-space has quite clearly been constructed with that objective
in mind.) We can now try to translate all boolean expressions and moves
in (a,c)-space into the corresponding boolean expressions and moves in
(p,q,r)-space. If this can be done in terms of the there permissible
operations, we have been successful. The transformation suggested is
indeed adequate and the following program is the result (the variable
h has been introduced for a very local optimization):
<table> <tr> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
   p, q, r:=0, 1, n; <b>do</b> q&le; n &rarr; q:= q * 4 <b>od</b>            </td> </tr> <tr> <td></td> <td colspan = 3>
   <b>do</b> q &ne; 1 &rarr; q:= q / 4; h:= p + q; p:=p / 2 {h = 2 * p + q}; </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
       <b>if</b> r &ge; h &rarr; p, r:=p + q, r - h                          </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; </td> <td>
         &#x25af; r &lt; h &rarr; skip                                       </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
       <b>fi</b>                                                             </td> </tr> <tr> <td></td> <td colspan = 3>
   <b>od</b>  {p has the value desired for a}                                </td> </tr>
</table>
<p>This fifth example has been included because it relates &mdash;in an
embellished form&mdash; a true design history. When the youngest of our two
dogs was only a few months old I walked with both of them one evening,
preparing my lectures for the next morning, when I would have to address
students with only a few weeks exposure to programming, and I wanted a
simple problem such that I could &ldquo;massage&rdquo; the solutions. During that
one hour walk the first, third and fourth program were developed in that
order, but for the fact that the correct introduction of h in the last
program was something I could only manage with the aid of pencil and paper
after I had returned home. The second program, the one manipulating a
and b , which here has been presented as a stepping stone to our third
solution, was only discovered a few weeks later &mdash;be it in a less elegant
form then presented here. A second reason for its inclusion is the relation
between the third and the fourth program: with respect to the latter one
the other one represents our first example of so-called representational
abstraction.
<p><b>Sixth example</b>.
<p>For fixed X (X &gt; 1) and Y (Y &ge; 0) the program should establish
<table width=100%><tr><td valign=top width=20%>
R:</td><td>z = X<sup>Y</sup>
</td>  </tr>  </table>
under the &mdash;obvious&mdash; assumption that exponentiation is not among the
available repertoire. This problem can be solved with the aid of an
&ldquo;abstract variable&rdquo; , h say; we shall do it with a loop, for which
the invariant relation is
<table width=100%><tr><td valign=top width=20%>
P:</td><td>h * z = X<sup>Y</sup>
</td>  </tr>  </table>
and our (equally &ldquo;abstract&rdquo;) program could be
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
    h, z:= X<sup>Y</sup> , 1 {P has been established};                  </td> </tr> <tr> <td></td> <td>
    <b>do</b> h &ne; 1 &rarr; squeeze h under invariance of P <b>od</b> </td> </tr> <tr> <td></td> <td>
    {R has been established}                                            </td> </tr>
</table>
The last conclusion is justified because (P <b>and</b> h = 1) &rArr; R . The
above program will terminate under the assumption that a finite number
of applications of the operation &ldquo;squeeze&rdquo; will have established h = 1.
The problem, of course, is that we are not allowed to represent the value
of h by that of a concrete variable directly manipulated by the machine:
if we were allowed to do that, we could have assigned the value of X<sup>Y</sup>
immediately to z , not bothering about introducing h at all. The trick
is that we can introduce two &mdash;at this level concrete&mdash; variables, x and
y say, to represent the current value of h and our first assignment
suggests as convention for this representation
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                  h = x<sup>y</sup> </td> </tr>
</table>
The condition &ldquo;h &ne; 1&rdquo; then translates into &ldquo;y &ne; 0&rdquo; and our next
task is to discover an implementable operation &ldquo;squeeze&rdquo;. Because the
product h * z must remain invariant under squeezing, we should divide
h by the same value by which z is multiplied. In view of the way
in which h is represented, the current value of x is the most
natural candidate. Without any further problems we arrive at the
translation of our abstract program
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
     x, y, z:= X, Y, 1{P has been established};                                         </td> </tr> <tr> <td></td> <td>
     <b>do</b> y &ne; 0 &rarr; y, z:= y - 1, z * x {P has not been destroyed} <b>od</b> </td> </tr> <tr> <td></td> <td>
     {R has been established} .                                                         </td> </tr>
</table>
<p>Looking at this program we realize that the number of times
control goes through the loop equals the original value Y and we can
ask ourselves whether we can speed things up. Well, the guarded command
has now the task to bring y down to zero: without changing the <b>value</b>
of h , we can investigate whether we can change the <b>representation</b> of
that value, in the hope of decreasing the value of y . We are just
going to try to exploit that the concrete representation of a value of
h as given by x<sup>y</sup> is by no means unique. If y is even we can halve
y and square x, and this will not change h at all. Just before the
squeezing operation we insert the transformation towards the most attractive
representation of h and here is the next program:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
     x, y, z:= X, Y, 1;                                                            </td> </tr> <tr> <td></td> <td colspan = 2>
     <b>do</b> y &ne; 0 &rarr; <b>do</b> y|2 &rarr; x, y:= x * x, y / 2 <b>od</b>; </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
          y, z:= y - 1, z * x                                                      </td> </tr> <tr> <td></td> <td colspan = 2>
     <b>od</b> {R has been established}                                            </td> </tr>
</table>
There exists one value that can be halved indefinitely without becoming
odd and that is the value 0, in other words: the outer guard ensures
that the inner repetition terminates.
<p>I have included this example for various reasons. The discovery
that a mere insertion of what on the abstract level acts like an empty
statement could change an algorithm invoking a number of operations
proportional to Y into one invoking a number of operations only 
proportional to log(Y) startled me when I made it. This discovery was a direct
consequence of my forcing myself to think in terms of a single abstract
variable. The exponentiation program I knew was the following:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
   x, y, z:= X, Y, 1;                                                                                               </td> </tr> <tr> <td></td> <td colspan = 2>
   <b>do</b> y &ne; 0 &rarr; <b>if</b> <b>non</b> y|2 &rarr; y, z:= y - 1, z * x &#x25af; y|2 &rarr; skip <b>fi</b> </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
        x, y:= x * x, y / 2                                                                                         </td> </tr> <tr> <td></td> <td colspan = 2>
   <b>od</b>                                                                                                        </td> </tr>
</table>
This latter program is very well known, it is a program that many of us
have discovered independently of each other. Because the last squaring
of x when y has reached the value 0 is clearly superfluous, this
program has often been cited as supporting the need for what were called
&ldquo;intermediate exits&rdquo;. in view of our second program I come to the conclusion
that this support in weak.   
<p><b>Seventh example</b>,
<p>For a fixed value of n (n &ge; 0) a function f(i) is given for
0 &le; i &lt; N . Assign to the boolean variable &ldquo;allsix&rdquo; the value such that
eventually
<table width=100%><tr><td valign=top width=20%>
R:</td><td>allsix = (<u>A</u> i: 0 &le; i &lt; n: f(i) = 6) 
</td>  </tr>  </table>
holds. (This example shows some similarity to the Second Example of this
chapter. Note, however, that in this example, n = 0 is allowed as well.
In that case the range for i for the all-quantifier &ldquo;<u>A</u>&rdquo; is empty and
allsix = true should hold.) Analogous to what we did in the second Example
the invariant relation
<table width=100%><tr><td valign=top width=20%>
P:</td><td>(allsix = (<u>A</u> i: 0 &le; i &lt; n: f(i) = 6)) <b>and</b> 0 &le; j &le; n
</td>  </tr>  </table>
suggests itself, because it is easily established for j = 0 , while
(P <b>and</b> i = n) &rArr; R . The only thing to do is to investigate how to increase
j under invariance of P . We therefore derive
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
           wp(&ldquo;j:=j +1&rdquo;. P) =                                                        </td> </tr> <tr> <td></td> <td>
           (allsix = (<u>A</u> i: 0 &le; i &lt; j + 1: f(i)=6)) <b>and</b> 0 &le; j + 1 &le; n . </td> </tr>
</table>
 
The last term is implied by P <b>and</b> j &ne; m ; it presents no problem because
we had already decided that j &ne; n as a guard is weak enough to conclude
R upon termination. The weakest pre-condition that the assignment
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      allsix;:= allsix and f(j) = 6 </td> </tr>
</table>
will establish the other term is
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      (allsix <b>and</b> f(j) = 6) = (<u>A</u> i: 0 &le; i &lt; j + 1: f(i) = 6)   . </td> </tr>
</table>
a condition that is implied by P. We thus arrive at the program
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      allsix, j:= <b>true</b>, 0;                             </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>do</b> j &ne; n &rarr; allsix:= allsix and f(j) = 6; </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td>
         j:= j + 1                                            </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>od</b>                                               </td> </tr>
</table>
(In the guarded command we have not used the concurrent assignment for no
particular reason.)
<p>By the time that we read this program &mdash;or perhaps already earlier&mdash;
we should get the uneasy feeling that as soon as a function value &ne; 6 has
been found, there is not much point in going on. And indeed, although
(P <b>and</b> j = n) &rArr; R , we could have used the weaker
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
     (P <b>and</b> (j = n <b>or</b> <b>non</b> allsix)) &rArr; R </td> </tr>
</table>
leading to the stronger guard &ldquo;j &ne; n and allsix&rdquo; and to the program
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
     allsix, j:= true, 0;                                                                </td> </tr> <tr> <td></td> <td>
     <b>do</b> j &ne; n <b>and</b> allsix &rarr; allsix, j:= f(j) = 6, j + 1 <b>od</b> . </td> </tr>
</table>
(Note the simplification of the assignment to allsix , a simplification
that is justified by the stronger guard.)
<p class="noindent"><b>Exercise</b>. Give for the same problem the correctness proof for
<table> <tr> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
   <b>if</b> n = 0 &rarr; allsix:= true                                       </td> </tr> <tr> <td></td> <td colspan = 2>
   &#x25af; n &gt; 0 &rarr; j:= 0;                                            </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
        <b>do</b> j &ne; n - 1 <b>and</b> f(j) = 6 &rarr; j:= j + 1 <b>od</b> </td> </tr> <tr> <td></td> <td></td> <td>
        allsix:= f(j) = 6                                                     </td> </tr> <tr> <td></td> <td colspan = 2>
   <b>fi</b>                                                                  </td> </tr>
</table>
and also for the still more tricky program (that does away with the need
to invoke the function from more than one place in the program)
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
          j:= 0;                                                             </td> </tr> <tr> <td></td> <td>
          <b>do</b> j &ne; n <b>cand</b> f(j) = 6 &rarr; j:= j + 1 <b>od</b> </td> </tr> <tr> <td></td> <td>
          allsix:= j = n                                                     </td> </tr>
</table>
(Here the condition conjunction operator &ldquo;<b>cand</b>&rdquo; has been used in order to
do justice to the fact that f(n) need not be defined.) The last program
is one, that some people like very much.
<p><b>Eighth example</b>.
<p>Before I can state our next problem, I must first give some definitions
and a theorem. Let p = (p<sub>0</sub>, p<sub>1</sub>, ... , p<sub>n-1</sub>) be a permutation of n (n &gt; 1)
different values p<sub>i</sub> (0 &le; i &lt; n), i.e. (i &ne; j) &rArr; (P<sub>i</sub> &ne; P<sub>j</sub>) . Let
q = (q<sub>0</sub>, q<sub>1</sub>, ... , q<sub>n-1</sub>) be a different permutation of the same set of
n values. By definition &ldquo;permutation p precedes q in the alphabetic
order&rdquo; if and only if for the minimum value of k such that p<sub>k</sub> &ne; q<sub>k</sub> we
have p<sub>k</sub> &lt; q<sub>k</sub> .
<p>The so-called &ldquo;alphabetic index<sub>n</sub>&rdquo; of a permutation of n different
values is the ordinal number given to it when we number the n! possible
permutation arranged in alphabetic order from 0 through n!-1 For
instance, for n = 3 and the set of values 2, 4 and 7 we have
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      index<sub>3</sub>(2, 4, 7) = 0 </td> </tr> <tr> <td></td> <td>
      index<sub>3</sub>(2, 7, 4) = 1 </td> </tr> <tr> <td></td> <td>
      index<sub>3</sub>(4, 2, 7) = 2 </td> </tr> <tr> <td></td> <td>
      index<sub>3</sub>(4, 7, 2) = 3 </td> </tr> <tr> <td></td> <td>
      index<sub>3</sub>(7, 2, 4) = 4 </td> </tr> <tr> <td></td> <td>
      index<sub>3</sub>(7, 4, 2) = 5 </td> </tr>
</table>
<p>Let (p<sub>0</sub> p<sub>1</sub> ... p<sub>n</sub>) denote the permutation of the n different
values in monotonicly increasing order, i.e. index<sub>n</sub>((p<sub>0</sub> p<sub>1</sub> ... p<sub>n</sub>)) = 0.
(For example (4 7 2) = (2, 4, 7) but also (7 2 4) = (2, 4, 7) .)
<p>With the above notation we can formulate the following theorem for
n &gt; 1:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
           index<sub>n</sub>(p<sub>0</sub>, p<sub>1</sub>, ..., p<sub>n-1</sub>) =                                                                                           </td> </tr> <tr> <td></td> <td>
           index<sub>n</sub>(p<sub>0</sub>,(p<sub>1</sub> p<sub>2</sub> ... p<sub>n-1</sub>)) +  index<sub>n</sub>(p<sub>1</sub>, p<sub>2</sub>, ..., p<sub>n-1</sub>) </td> </tr>
</table>
(e.g. index<sub>3</sub>(4, 7, 2) = index<sub>3</sub>(4, 2, 7) + index<sub>2</sub>(7, 2) = 2 + 1 = 3 .)
In words: the index<sub>n</sub> of a permutation of n different values is the
index<sub>n</sub> of the alphabeticaly first one with the same leftmost value increased
by the index<sub>n-1</sub> of the permutation of the remaining rightmost n-1 values.
<br>As a corrolary: from
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      p<sub>n-k</sub> &lt; p<sub>n-k+1</sub> &lt; ... &lt; p<sub>n-1</sub> </td> </tr>
</table>
follows that index<sub>n</sub>(p<sub>0</sub>, p<sub>1</sub>, ... , p<sub>n-1</sub> ) is a multiple of k! and vice
versa .
<p>After these preliminaries we can describe our problem. We have a row
of n positions (n &gt; 1) numbered in the order from left to right from
0 through n-1 ; in each position lies a card with a value written on it
such that no two different cards show the same value.
<p>When at any moment c<sub>i</sub> (0 &le; i &lt; n) denotes the value on the card
in position i , we have initially
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
            c0<sub> </sub>&lt; c<sub>1</sub> &lt; ... &lt; c<sub>n-1</sub> </td> </tr>
</table>
(i.e. the cards lie sorted in the order of increasing value). For given
value of r (0 &le; r &lt n!) we have to rearrange the cards such that in the
<table width=100%><tr><td valign=top width=20%>
R:</td><td>index<sub>n</sub>(c<sub>0</sub>, c<sub>1</sub>, ... , c<sub>n-1</sub>) = r .
</td>  </tr>  </table>
the only way in which our mechanism can interfere with the cards is via
the execution of the statement
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
        cardswap(i, j) with 0 &le; i, j &lt; n </td> </tr>
</table>
that will interchange the cards in positions i and j if i &ne; j
(and will do nothing if i = j).
<p>In order to perform this transformation we must find a class of states 
&mdash;all satisfying a suitable condition P1&mdash; such that both initial and
final states are specific instances of that class. Introducing a new
variable, s say, an obvious candidate for P1 is
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
         index<sub>n</sub>(c<sub>0</sub>, c<sub>1</sub>, ... , c<sub>n-1</sub>) = s </td> </tr>
</table>
as this is easily established initially (viz. by &ldquo;s:= 0&rdquo;) and
(P1 <b>and</b> s = r) &rArr; R .
<p>Again we ask, whether we can think of restricting the range of s
and in view of its initial value we might try
<table width=100%><tr><td valign=top width=20%>
P1:</td><td>index<sub>n</sub>(c<sub>0</sub>, c<sub>1</sub>, ... , c<sub>n-1</sub>) = s <b>and</b> 0 &le; s &le; r
</td>  </tr>  </table>
which would lead to a program of the form
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      s:= 0 {P1 has been established};                   </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>do</b> s &ne; r &rarr; {P1 <b>and</b> s &lt; r} </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
          increase s by a suitable amount under          </td> </tr> <tr> <td></td> <td></td> <td>
          invariance of P1 {P1 still holds}              </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>od</b> {R has been established}                 </td> </tr>
</table>
<p>Our next concern is, what to choose for &ldquo;a suitable amount&rdquo;. Because
our increase of s must be accompanied by a reaarngement of the cards in
order to keep P1 invariant, it seems wise to investigate whether we can
find conditions, under which a single cardswap corresponds to a known
increase of s . Let for a value of k satisfying 1 &le; k &lt; n hold
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
         c<sub>n-k</sub> &lt; c<sub>n-k+1</sub> &lt; ... &lt; c<sub>n-1</sub> ; </td> </tr>
</table>
this assumption is equivalent with the assumption k!|s &mdash;read: &ldquo;k!
divides s&rdquo;&mdash;. Let i = n-k-1 , i.e. c<sub>i</sub> is the value on the card
to the immediate left of this sequence. Let furthermore c<sub>i</sub> &lt; c<sub>n-1</sub> and
let c<sub>j</sub> be for j in the range n-k &le; j &lt; n the minimum value such that
c<sub>i</sub> &lt; c<sub>j</sub> (i.e. c<sub>j</sub> is the smallest value to the right of c<sub>i</sub> exceeding the
latter). In that case the operation cardswap(i, j) leaves the rightmost
k values in the same monotonic order and our theorem about permutations
and their indices tells us that k! is the corresponding increase of s.
It also tells us that when besides k!|s we have
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
             s &le; r &lt; s + k! </td> </tr>
</table>
c<sub>0</sub> through c<sub>n-k-1</sub> have attained their final value.
<p>I therefore suggest to strengthen our original invariant relation P1
with the additional relation P2 &mdash;fixing the function of a new variable k &mdash;
<table width=100%><tr><td valign=top width=20%>
P2:</td><td>1 &le; k &le; n <b>and</b> k!|s <b>and</b> r &lt; s + k!
</td>  </tr>  </table>
which means that the rightmost k cards show still monotonicly increasing
values, while the leftmost n-k cards are in their final positions: we have
decided upon the &ldquo;major steps&rdquo; in which we shall walk towards our destination.
<p>In order to find &ldquo;the suitable amount&rdquo; for a major step the machine
first determines the largest smaller value of k for which r &lt; s + k!
no longer holds &mdash; c<sub>i</sub> with i = n-k-1 is then too small, but to the
left of it they are all OK&mdash; and then increase s by the minimum multiple
of k! needed to make r &lt; s + k! hold again; this is done in &ldquo;minor
steps&rdquo; of k! at a time, simultaneously increasing c, with cards to
the right of it. In the following program we introduce the additional
variable kfac , satisfying
<table width=100%><tr><td valign=top width=20%>
P3:</td><td>kfac = k!
</td>  </tr>  </table>
and for the second inner repetition i and j , such that i = n-k-1
and either j = n or i &lt; j &lt; n <b>and</b> c<sub>j</sub> &gt; c<sub>i</sub> <b>and</b> c<sub>j-1</sub> &lt; c<sub>i</sub>  .
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 6>
      s:= 0 {P1 has been established};                                          </td> </tr> <tr> <td></td> <td colspan = 6>
      kfac, k: 1, 1 {P3 has been established as well};                          </td> </tr> <tr> <td></td> <td colspan = 6>
      <b>do</b> k &ne; n &rarr; kfac, k:= kfac *(k+1), k+1 <b>od</b>            </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td colspan = 3>
          {P2 has been established as well};                                    </td> </tr> <tr> <td></td> <td colspan = 6>
      <b>do</b> s &ne; r &rarr; {s &lt; r, i.e, at least one, and therefore     </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
             at least two cards have not reached their                          </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td colspan = 2>
             final position}                                                    </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; </td> <td colspan = 4>
         <b>do</b> r &lt; s + kfac &rarr; kfac, k:= kfac / k, k - 1 <b>od</b>   </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td colspan = 2>
             {P1 and P3 have been kept true, but in P2                          </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td colspan = 2>
             the last term is replaced by                                       </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td colspan = 2>
             s + kfac &lt; r &lt; s + (k + 1)* kfac};                           </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 4>
         i, j:= n - k - 1, n - k;                                               </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 4>
         <b>do</b> s + kfac &le; r &rarr; {n - k &le; j &lt; n}                 </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td>
              s:= s + kfac; cardswap(i, j); j:= j + 1                           </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 4>
         <b>od</b> {P2 has been restored again: P1 <b>and</b> P2 <b>and</b> P3} </td> </tr> <tr> <td></td> <td>&nbsp; </td> <td colspan = 5>
       <b>od</b> {R has been established}                                       </td> </tr>
</table>
<b>Exercise</b>. Convince yourself of the fact that also the following rather
similar program would have done the job:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
    s:= 0; kfac, k:=1, 1;                                             </td> </tr> <tr> <td></td> <td colspan = 3>
    <b>do</b> k &ne; n &rarr; kfac, k:= kfac *(k +1), k +1 <b>od</b>; </td> </tr> <tr> <td></td> <td colspan = 3>
    <b>od</b> k &ne; 1 &rarr;                                         </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
       kfac, k:= kfac / k, k - 1;                                     </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
       i, j:= n - k - 1, n - k;                                       </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
       <b>do</b> s + kfac &le; r &rarr;                               </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td>
          s:= s + kfac; cardswap(i, j); j:= j +1                      </td> </tr> <tr> <td></td> <td></td> <td colspan = 2>
       <b>od</b>                                                      </td> </tr> <tr> <td></td> <td colspan = 3>
    <b>od</b>                                                         </td> </tr>
</table>
(Hint: the monotonicly decreasing function  t &ge; 0 for the outer repetition
is t = r - s + k - 1 .)
<hr />
   <p class="noindent"><font size="-1">Transcribed by Martin P.M. van der Burgt<br />
    Last revision
    <csobj format="MedDate" h="13" region="15" t="DateTime" w="90">
      <!-- #BeginDate format:IS1 -->2014-11-15<!-- #EndDate -->
    </csobj>
  .</font></p>

</body></html></div>
</body>
</html>
