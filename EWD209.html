<!DOCTYPE html>
<html>
<head>
  <title>A constructive approach to the problem of program correctness</title>
  <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
  <link href="assets/common.css" rel="stylesheet">
  <link href="assets/transcriptions.css" rel="stylesheet">
  <meta name="generator" content="convertArticle.pl">
</head>
<body>
<div class="metabar">
  <div class="metabar-inner">
    <a href="index.html">HOME</a>
  </div>
</div>
<h1>A constructive approach to the problem of program correctness</h1>
<div class='body'>				<h1>A Constructive Approach to the Problem of Program Correctness.</h1>				<h2>Summary.</h2>				<p>As an alternative to methods by which the correctness of given programs can be established a posteriori, this paper proposes to control the process of program generation such as to produce a priori correct programs. An example is treated to show the form that such a control then might take. This example comes from the field of parallel programming; the way in which it is treated is representative for the way in which a whole multiprogramming system has actually been contstructed.</p>				<h2>Introduction.</h2>				<p>The more ambitious we become in our machine applications, the more vital becomes the problem of program correctness. The growing attention being paid to this problem is therefore a quite natural and sound development. As far as I am aware, however, the problem has been tackled, posed roughly in the following form: &quot;Given an algorithm and given specifications of its desired dynamic behaviour, prove then that the dynamic behaviour of the given algorithm meets the given specifications.&quot; After sufficient formalization of the way in which the algorithm and specifications are given, we are faced with a well-posed problem that is apparently not without mathematical appeal.</p>				<p>In this paper I shall tackle the problem from the other side: &quot;Given the specifications of the desired dynamic behaviour, how do we derive from these an algorithm meeting them in its dynamic behaviour?&quot;. For certain mathematical minds the latter problem will be less attractive (for one thing: the algorithm to be desired is not uniquely defined by the specifications given); it seems, however, to be of much greater practical value because, as a rule, we have to construct the algorithm as well.</p>				<p>This paper has been written because the approach seems unusual, while we have followed it very consciously and seem to have done so to our great advantage. We also publish it in the hope that it may serve as a partial answer to the many doubts evoked by our claim to have constructed a multiprogramming system of proven flawlessness.</p>				<p>In this paper I shall illustrate the method by deriving an algorithm meeting very simple specifications, the simplicity being chosen in order to avoid an unneccessarily lengthy paper. In doing so I am running the risk of readers not believing in the practicability of the method when applied to large problems. To those I can only make the following remarks. Firstly, that the art of reasoning to be displayed below is faithfully representative of the way in which we have actually designed a multiprogramming system with fairly refined management rules. Secondly, that it is my firm belief that by consequent application of such methods our ability to deal with large problems will rather increase than decrease. Thirdly, that to anyone who doubts the practicability of the method I can only recommend to try to apply it. Finally, that I know only too well that I can force no one to share my beliefs.</p>				<h2>The problem.</h2>				<p>For the purpose of demonstration I have chosen the following problem. We consider two parallel, cyclic processes, called &quot;producer&quot; and &quot;consumer&quot; respectively. They are coupled to each other via a buffer (in this example of unlimited capacity) for &quot;portions&quot; of information. Once per cycle the producer puts a next portion into the buffer, once per cycle the consumer takes a portion from the buffer. The buffer is allocated in the universe surrounding the two processes; after introduction and initialization of this universe, the two processes are started in parallel, as indicated below by the bracket pair &quot;<u>parbegin</u>&quot; and &quot;<u>parend</u>&quot;. It is also indicated that the activity of the producer as well as the activitiy of the consumer can be regarded in this stage as an alternating succession of two actions. We depart in our example from the (hopefully now self-explanatory) structure given below; here the actions invoked are to be considered as available primitives.</p>				<pre><u>begin</u> initialize an empty buffer;    <u>parbegin</u>producer: <u>begin</u> local initialization of the producer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P1: produce next portion locally;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2: put portion into buffer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> P1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;consumer: <u>begin</u> local initialization of the consumer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C1: take portion from buffer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C2: consume new portion locally;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> C1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>&nbsp;&nbsp;&nbsp;&nbsp;<u>parend</u><u>end</u></pre>				<p>For the proper co-operation of the two processes as described above we must assume an implicit synchronization, preventing the consumer to try to take a portion from an empty buffer. In the following we shall refuse to make any assumptions about the speed ratio of the two processes and our task is to program the synchronization between the two processes explicitly. (The synchronizing primitives I intend to use for this solution will be described in due time.)</p>				<p><u>Note</u>. For brevity I omit the proof &#x2014;although for this simple example not too difficult&#x2014; that the above problem is well-posed in the sense that a synchronization satisfying the above requirement does not contain the danger of the so-called &quot;deadly embrace&quot;, i.e. one or more processes getting irrevocably stuck because they are waiting for each other. I do so because this proof is more concerned with the problem as posed than with the task of programming it and the latter is the true subject of this paper.</p>				<h2>Formalization of the required dynamic behaviour.</h2>				<p>Our first step is the introduction of suitable variables in terms of which we can give a more formal description of the specification of the required dynamic behaviour. Obviously, the number of portions in the buffer is a vital quantity. Therefore we introduce an integer variable, <var>n</var> say, whose value has to equal the number of portions in the buffer. The rule to be followed this time is particularly simple: first, initialize the value of <var>n</var> together with the initialization of the buffer, so that the relation</p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td>							<blockquote>								<var>n</var> = number of portions in the buffer</blockquote>						</td>						<td>							<div align="right">								(1)</div>						</td>					</tr>				</table>				<p class="continue">is satisfied to start with. From then onwards, adjust the value of the variable called &quot;<var>n</var>&quot; whenever the number of portions in the buffer is changed, i.e. at putting a portion into it or taking a portion from it. As a result the relation (1) will always be satisfied.</p>				<p>From now onwards the three actions initializing or changing the buffer contents are regarded as actions including the proper operation on the variable called &quot;<var>n</var>&quot;. To indicate this, we may write Version 1:</p>				<pre><u>begin</u> <u>integer</u> <var>n</var>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialize an empty buffer including &quot;<var>n</var> := 0&quot;;&nbsp;&nbsp;&nbsp;<u>parbegin</u>producer: <u>begin</u> local initialization of the producer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P1: produce next portion locally;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2: put portion into buffer including &quot;<var>n</var> := <var>n</var> + 1&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> P1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;consumer: <u>begin</u> local initialization of the consumer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C1: take portion from buffer including &quot;<var>n</var> := <var>n</var> - 1&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C2: consume new portion locally;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> C1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>&nbsp;&nbsp;&nbsp;<u>parend</u><u>end</u></pre>				<p>Thus we have achieved that the specification of the dynamic behaviour can be formulated by the requirement that the inequality</p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td>							<blockquote>								<var>n</var> &#x2265; 0</blockquote>						</td>						<td>							<div align="right">								(2)</div>						</td>					</tr>				</table>				will always be satisfied.				<p>(Remark. It may well be, that already in the transition from the original version to Version 1 we can observe one of the origins of the efficiency of the constructive approach. If we did regard the Version 1 as given and wanted to identify the current value of <var>n</var> with the current number of portions in the buffer, we would have to observe its initialization and its adjustments, but in excess to this we would have to read the whole program in order to verify that no other operations on it can occur.)</p>				<h2>Analysis of the formalized requirements.</h2>				<p>We now proceed from Version 1 and requirement (2). The latter requirement is satisfied by the universe as initialized, we have only to synchronize the two processes in such a way that it <em>remains</em> satisfied.</p>				<p>From the fact that requirement (2) concerns the value of the variable called &quot;<var>n</var>&quot; only, it follows that the processes can only effectuate violation by acting on this variable, i.e. only via the actions labelled &quot;P2&quot; and &quot;C1&quot; respectively. Closer inspection of the requirement (&quot;<var>n</var> &#x2265; 0&quot;) and the actions show that the action labelled &quot;P2&quot; (including &quot;<var>n</var> := <var>n</var> + 1&quot;) is quite harmless, because</p>				<blockquote>					<pre><var>n</var> &#x2265; 0 implies <var>n</var> + 1 &#x2265; 0,</pre>				</blockquote>				but that the action labelled &quot;C1&quot; (including &quot;<var>n</var> := <var>n</var>-1&quot;) may indeed cause a violation. More precisely, as				<blockquote>					<pre><var>n</var> &#x2265; 1 implies <var>n</var> - 1 &#x2265; 0,</pre>				</blockquote>				the action labelled &quot;C1&quot; is harmless when initiated with				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td>							<blockquote>								<var>n</var> &#x2265; 1</blockquote>						</td>						<td>							<div align="right">								(3)</div>						</td>					</tr>				</table>				while with <var>n</var> = 0 it would cause violation; under the latter circumstance it has to be postponed.				<p>(Remark. Our last conclusion is, that the only possible harm is trying to make the buffer more empty than empty. Its obviousness here is a direct consequence of the simplicity of this example. The point is, that this conclusion could be reached by inspection of the formalized requirement (2) and the operations on the variables concerned. In the case of a more refined management, the requirements analogous to (2) are no longer a simple inequalilty and their analysis will really tell you the danger points.)</p>				<h2>Consequence of the preceding analysis; the unstable situation.</h2>				<p>In the previous section we have concluded that the action labelled &quot;C1&quot; is the only danger point. Having here only one consumer, we could have solved the problem logically by inserting just in front of it a wait cycle</p>				<blockquote>					<pre>C0: if <var>n</var> = 0 then goto C0</pre>				</blockquote>				but we refused to implement this busy form of waiting, because in a multiprogrammed environment it seems a waste to spend central processor time on a process that has already established that for the time being it cannot go on. Therefore we have implemented means  &#x2014viz. the synchronizing primitives&#x2014 by which a process can go to sleep until further notice (a sleeping process being by definition no candidate for processor time), leaving of course to the other processes the obligation to give this &quot;further notice&quot; in due time. This is so closely analogous to usual optimizing techniques that I proceed with this multiprogramming example in full confidence that the uniprogrammer will be able to apply similar considerations to his own tasks.				<p>We see ourselves faced with the decision whether the action labelled &quot;C1&quot; should take place or not. Earlier we have seen that this decision depends on the current value of the variable called &quot;<var>n</var>&quot;. Recently we have seen that under certain curcumstances we refuse to regard this as a private decision of the consumer (this would imply the busy form of waiting) but wish to delegate it (via the mechanism of the further notice) to the producer. As long as it was a private decision of the consumer, inserting it at the right plalce in the consumer's text was a sufficient means to ensure that the decision was taken in accordance with the dynamic progress of the consumer. As soon as this decision may be taken by another process &#x2014here by the producer&#x2014 the dynamic progress of the consumer becomes a question of general interest, in particular whether the consumer is ready to perform the action labelled &quot;C1&quot;. We introduce a boolean variable, called &quot;<var>hungry</var>&quot; whose value has to indicate explicitly that the consumer's progress has reached the stage that the decision to execute or to postpone the action labelled &quot;C1&quot; is relevant.</p>				<p>To ensure that the variable called &quot;<var>hungry</var>&quot; has this meaning, we must</p>				<p class="noindent">1)&nbsp;&nbsp;&nbsp;&nbsp;insert within the consumer's cycle the assignment &quot;<var>hungry</var> := <u>true</u>&quot; just in front of the statement labelled &quot;C1&quot;;</p>				<p class="continue">2)&nbsp;&nbsp;&nbsp;&nbsp;include the assignment &quot;<var>hungry</var> := <u>false</u>&quot; as part of the action labelled &quot;C1&quot;;</p>				<p class="continue">3)&nbsp;&nbsp;&nbsp;&nbsp;initialize in the universe the variable called &quot;<var>hungry</var>&quot; in accordance with the starting point in the consumer's cycle.</p>				<p>The variable called &quot;<var>hungry</var>&quot; is an explicit coding of the consumer's progress, analogous to the variable called &quot;<var>n</var>&quot;, an explicit coding of the number of portions in the buffer. We arrive at Version 2:</p>				<pre><u>begin</u> <u>integer</u> <var>n</var>; <u>Boolean</u> <var>hungry</var>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialize an empty buffer including &quot;<var>n</var> := 0&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>hungry</var> := <u>false</u>;&nbsp;&nbsp;&nbsp;<u>parbegin</u>producer: <u>begin</u> local initialization of the producer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P1: produce next portion locally;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2: put portion into buffer including &quot;<var>n</var> := <var>n</var> + 1&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> P1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;consumer: <u>begin</u> local initialization of consumer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C0: <var>hungry</var> := <u>true</u>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C1: take portion from buffer including &quot;<var>n</var> := <var>n</var> - 1&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and &quot;<var>hungry</var> := <u>false</u>&quot;;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C2: consume new portion locally;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>&nbsp;&nbsp;&nbsp;<u>parend</u><u>end</u></pre>				<p>From relation (3) and the meaning of the variable called &quot;<var>hungry</var>&quot; we now deduce that the action labelled &quot;C1&quot; should take place whenever</p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td>							<blockquote>								<var>n</var> &#x2265; 1 and <var>hungry</var></blockquote>						</td>						<td>							<div align="right">								(4)</div>						</td>					</tr>				</table>								becomes <u>true</u>, the action labelled &quot;C1&quot; itself causing (4) to become <u>false</u> again. In other words: we must see to it that (4) characterizes what we could call &quot;an unstable situation&quot;, for as soon as it emerges it should be resolved by the action labelled &quot;C1&quot;.				<p>Having no permanently active observer that will give alarm whenever the unstable situation arises, we must allocate the inspection for the unstable situation (and if found its subsequent resolution by action &quot;C1&quot;) somewhere in the sequential processes. The necessary and sufficient measure is to attach this inspection as an appendix to each action that may have generated the unstable situation from a stable one, pinning the responsibility to resolve the unstable situation down on the process that has generated it.</p>				<p>Some elementary logic applied to (4) tells us that this transition can only be effected by an action assigning the value <u>true</u> to the variable called &quot;<var>hungry</var>&quot; or by an action increasing the value of the variable called &quot;<var>n</var>&quot; (or by an action doing both, not occurring in this example). In terms of Version 2: the instability may be reached as a result of the action labelled &quot;C0&quot; (on account of &quot;<var>hungry</var> := <u>true</u>&quot;) and by the action labelled &quot;P2&quot; (on account of &quot;<var>n</var> := <var>n</var> + 1&quot;). So the action labelled &quot;P2&quot; &#x2014allocated in the producer&#x2014 might get attached to it as an appendix the action labelled &quot;C1&quot;, originally allocated in the consumer!</p>				<p>At this stage of the discussion we must insert an interlude that has nothing to do with this particular problem, nor with the main train of thought of this paper. The interlude is inserted because I expect many a reader to be unfamiliar with the basic problems of programming parallel processes, a field from which our example happens to have been taken.</p>				<h2>Interlude on synchronizing primitives.</h2>				<p>We need primitives to control that processes may go to sleep or may be woken up. For the purposes of this we introduce</p>				<p class="continue">1)&nbsp;&nbsp;&nbsp;&nbsp;special purpose binary valued variables, called &quot;semaphores&quot;. A semaphore may have the values 0 and 1. Semaphores are allocated in the surrounding universe and are initialized before the parallel processes are started.</p>				<p class="continue">2)&nbsp;&nbsp;&nbsp;&nbsp;two special operations, called the P- and V-operation respectively.</p>				<p>The P-operation on a semaphore can only be completed at a moment that the semaphore value equals 1. Its completion implies that the semaphore value is reset to 0. If a process initiates a P-operation on a semaphore with at that moment a value equal to 0, &quot;the process goes to sleep, the P-operation remains pending on this semaphore&quot;.</p>				<p>The V-operation on a semaphore is only defined if its initial value equals 0. It will then set the semaphore to 1. If no P-operation is pending on this semaphore the V-operation has no further effect. If one or more P-operations are pending on it, the V-operation will have the further effect that exactly one of the pending P-operations will be completed (thereby resetting the semaphore to the value 0), i.e. the process in which this P-operation occurred is woken up again.</p>				<p>As a result a semaphore value equal to 1 implies that there are at that moment no P-operations pending on it.</p>				<p>The semaphores are used for two entirely distinct purposes; both standard usages will occur in the example.</p>				<p>On the one hand we have the so-called &quot;private semaphores&quot; each belonging to a specific sequential process, that will be the only one to perform a P-operation on it, viz. where the process might need to be delayed until some event has occurred: the semaphore values 0 and 1 at the initiation of the P-operation represent the situation that the event in question has not yet or has already occurred. As a rule the universe initiates private semaphores with the value 0.</p>				<p>On the other hand we have the semaphore(s) used for the implementation of so-called &quot;critical sections&quot;, the executions of which have to exclude each other in time. Such critical sections can be implemented by opening them with a P-operation and closing them with a V-operation, all on the same semaphore with initial value 1. At each moment the value of such a semaphore for mutual exclusion equals the number of processes allowed to enter a section critical to it. The purpose of critical sections is to cater for unambiguous modification and interpretation of universal variables (such as &quot;<var>n</var>&quot; and &quot;<var>hungry</var>&quot; in our example).</p>				<p>Alternatively: at a certain level of abstraction we can visualize a single sequential process as a succession of &quot;immediate actions&quot;; the time taken to perform them is logically immaterial, only the states (as given by the values of the variables) observable in between the actions have on that level a logical significance. It is only when we shift to a lower level of abstraction and implement the actions themselves by means of (smaller) sequential sub-processes, that the intermediate states as well as their periods of execution enter the picture. And it is only at this lower level that &quot;mutual exclusion in time&quot; has a significance. In a single sequential process successive actions (now regarded as sub-processes) exclude each other in time automatically, because the next one will only be initiated after the preceding has been completed. In multiprogramming the mutual exclusion at the lower level of abstraction is no longer automatically guaranteed and the fact that on the higher level we regard them as single &quot;immediate actions&quot; requires then explicit recognition. This is exactly what the critical sections cater for.</p>				<h2>Resolution of the unstable situation and synchronization of the processes.</h2>				<p>Our analysis of the unstable situation ended with the conclusion that the action labelled &quot;C1&quot;, originally allocated in the consumer, will be attached as a conditional appendix to the actions labelled &quot;C0&quot; and &quot;P2&quot; respectively, to the ones that might generate the unstable situation.</p>				<p>To pin the responsibility for the resolution of the unstable situation down on the process that has generated it, the latter one must be uniquely defined (which is not the case if the effective assignments &quot;<var>n</var> := 1&quot; as part of P2 and &quot;<var>hungry</var> := <u>true</u>&quot; as part of C0 are allowed to take place simultaneously) and it must have resolved the unstable situation before the other process may have discovered it. In other words, creation of the unstable situation and its subsequent resolution must be regarded as a single &quot;immediate action&quot; in the sense of the last paragraph of the interlude. We shall implement them by critical sections controlled by a semaphore, &quot;<var>mutex</var>&quot; say, that will be initialized with the value 1.</p>				<p>Finally, in Version 2 the sequential nature of the consumer guaranteed that each execution of the action labelled &quot;C2&quot; would be preceded by one execution of the action labelled &quot;C1&quot;. This implicit sequencing can be made explicit with the aid of a private semaphore of the consumer, &quot;<var>consem</var>&quot; say (to be initialized with the value 0) by concluding the action labelled &quot;C1&quot; with &quot;V(<var>consem</var>)&quot; and opening the action labelled &quot;C2&quot; with &quot;P(<var>consem</var>)&quot;. The sequencing has to be made explicit because the action labelled &quot;C1&quot; may now occur as an activity of the producer.</p>				<p>After these considerations the final version of the program is given. For reasons of clarity and economy (of writing and thinking) the action labelled &quot;C1&quot; has been included in the body of a procedure declared in the universe.</p>				<p class="noindent">Final Version:</p>				<pre><u>begin</u> <u>integer</u> <var>n</var>; <u>Boolean</u> <var>hungry</var>; <u>semaphore</u> <var>mutex</var>, <var>consem</var>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>procedure</u> resolve instability if present;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>if </u> <var>n</var> &gt;= 1 <u>and</u> <var>hungry</var> <u>then</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> take portion from buffer; <var>n</var> := <var>n</var> - 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>hungry</var> := <u>false</u>; V(<var>consem</var>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;initialize buffer; <var>n</var> := 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>hungry</var> := <u>false</u>; <var>mutex</var> := 1; <var>consem</var> := 0;&nbsp;&nbsp;&nbsp;<u>parbegin</u>producer: <u>begin</u> local initialization of producer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P1: produce next portion locally;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P2: P(<var>mutex</var>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;put portion into buffer; <var>n</var> := <var>n</var> + 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve instability if present&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V(<var>mutex</var>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> P1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;consumer: <u>begin</u> local initialization of consumer;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C0: P(<var>mutex</var>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>hungry</var> := <u>true</u>; resolve instability if present;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V(<var>mutex</var>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C2: P(<var>consem</var>); consume new portion locally;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>&nbsp;&nbsp;&nbsp;<u>parend</u><u>end</u></pre>				<p>The above is as faithful a reproduction as I can give of the kind of reasoning we applied in the construction of a multiprogrammng system, be it that it has been interlaced with explanatory paragraphs, covering the insights we had already gained at an earlier stage just by thinking about the problems involved in the programming of parallel processes. (At that stage, for instance, the semaphores were born.) At the end, when we were all familiar with this type of problem, the reasoning needed to derive the program from specifications much more complicated than the present example, used to be given on a single page or less.</p>				<h2>Concluding remarks.</h2>				<p>Firstly, one can remark that I have not done much more than to make explicit what the sure and competent programmer has already done for years, be it mostly intuitively and unconsciously. I admit so, but without any shame: making his behaviour conscious and explicit seems a relevant step in the process of transforming the Art of Programming into the Science of Programming. My point is that this reasoning can and should be done explicitly.</p>				<p>Secondly, I should like to stress that by using the verb &quot;to derive&quot; I do not intend to suggest any form of automatism, nor to underestimate the amount of mathematical invention involved in all non-trivial programming. (On the contrary!) But I do suggest the constructive approach sketched in this paper as an accompanying justification of his inventions, as a tool to check during the process of invention that he is not led astray, as a reliable and inspiring guide.</p>				<p>Thirdly, I am fully aware that the style of reasoning I have applied, though possibly appealing to some, might easily appall others. For this difference in taste I blame them as little as they should blame me. I can only hope that they will find a way to follow the constructive approach in a style satisfying to them.</p>				<p>Finally, I should like to point out that the constructive approach to program correctness sheds some new light on the debugging problem. Personally I cannot refrain from feeling that many debugging aids that are en vogue now are invented as a compensation for the shortcomings of a programming technique that will be denounced as obsolete within the near future.</p>				<h2>Acknowledgements.</h2>				<p>Acknowledgements are due to my closest collaborators C.Bron, A.N.Habermann, F.J.A.Hendriks, C.Ligtmans and P.A.Voorhoeve, for by working in the way they did they convinced me of the practicability of the constructive approach when faced with a large problem.</p>				<p>Acknowledgements are also due &#x2014;although they may be unaware of the fact&#x2014 to Peter Naur and my colleague Gerhard W. Veltkamp. To the first one because he convinced me that something should and could be done regarding program correctness, to the second one for his inspiring faith in my efforts, his patience when listening to me and his unrelenting pityless criticism whenever I indulged in disguising sloppy reasoning by means of a verbal show.</p>				<p class="noindent">Eindhoven, August 1967</p>				<hr>				<!-- name and date -->				<div id="footer">					<font size="-1">transcribed by Saleem Shafi<br>						 revised <csobj format="MedDate" h="13" region="15" t="DateTime" w="96">Thu, 13 Nov 2008</csobj></font></div>			</div>						</body></html></div>
</body>
</html>
