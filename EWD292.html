<html>
<head>
  <title>from E.W.Dijkstra to C.A.R.Hoare, monday 31 August 1970</title>
  <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
  <link href="assets/transcriptions.css" rel="stylesheet">
  <meta name="generator" content="convertArticle.pl">
</head>
<body>
<div class="metabar">
  <a href="index.html">HOME</a>
</div>
<h1>from E.W.Dijkstra to C.A.R.Hoare, monday 31 August 1970</h1>
<div class='body'>											<p class="noindent">to professor C.A.R.Hoare<br>							Department of Computer Science<br>							The Queen's University of Belfast<br>							BELFAST BT7 1NN<br>							Northern Ireland</p>					</div>					<div align="center">						<p>Monday 31 August 1970<br>						</p>					</div>					<div align="left">						<p>Dear Tony,</p>						<p>May I ask you a few things? My first question is very simple: I should like a new copy of &quot;FIND&quot;, the paper you sent to the members of WG2.3, because I lost mine &#x2014;someone borrowed mine&#x2014; before I had paid all attention to it that it deserves.</p>						<p>My second question is more demanding: I should like to have your comments on the following thoughts. I ask this to you because on the subjects dealt with I consider you to be the world's expert. (Yet I hesitate as my question might be very demanding: I cannot predict how much re-adjustment from your side is required to follow my considerations. In all probability I use the usual words &#x2014;such as &quot;value&quot; and &quot;reference&quot; in a slightly different meaning!)</p>						<p>I associate with a variable the following things:</p>						<ol>							<li type="1">it may have a name &#x2014;&quot;<var>x</var>&quot; say&#x2014; so that a program may refer to it							<li type="1">it will have a finite life-time, during which it will have a unique identity							<li type="1">it will be &quot;of a type&quot;, i.e. associated with it will be a collection of possible values							<li type="1">at any moment during its life-time it will have one of the values of its type (&quot;any moment&quot; with respect to a sufficiently coarse grain of time, in which &quot;changing its value&quot; is an instantaneous operation)							<li type="1">given the identity of a variable, its value is uniquely defined; as many variables may have equal values, given its value, its identity is in general not uniquely defined							<li type="1">if &quot;<var>x</var>&quot; is the name of a variable, in program texts &quot;<b>ref</b> <var>x</var>&quot; will stand for its identity, &quot;<var>x</var>&quot; will stand for its value with two exceptions, viz.,							<ol>								<li type="a">when preceded by &quot;<b>ref</b>&quot;								<li type="a">when standing at the left of an assignment operator							</ol>							<li type="1">besides the reference prefix we have the evaluation operator &quot;<b>val</b>&quot;. Its function is given by						</ol>						<blockquote>							<blockquote>								<p class="noindent"><b>val ref</b> <var>x</var> = <b>val</b> (<b>ref</b> <var>x</var>) = <var>x</var> .</p>							</blockquote>						</blockquote>						<p>Exception 6b) is introduced for compatibility reasons mainly. It allows us to write in the usual way</p>						<blockquote>							<p class="noindent"><var>x</var> := <var>x</var> + 1</p>						</blockquote>						<p class="noindent">instead of the more cumbersome</p>						<blockquote>							<p class="noindent"><b>ref</b> <var>x</var>:= <var>x</var> ;</p>						</blockquote>						<p class="noindent">if I wanted to do this with the assignment procedure &quot;assign&quot; I would have to write</p>						<blockquote>							<p class="noindent">assign(<b>ref</b> <var>x</var>, <var>x</var>+ 1).</p>						</blockquote>						<p class="noindent">If &quot;<var>y</var> = <b>ref</b> <var>x</var>&quot; then &quot;<b>val</b> <var>y</var> = <var>x</var>&quot;, so I could write also</p>						<blockquote>							<p class="noindent"><b>val</b> <var>y</var>:= <var>x</var> + 1 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assign(<var>y</var>, <var>x</var> + 1) .</p>						</blockquote>						<p>The assignment operator does two things: it assigns a new variable to a <em>variable</em> (with an identity, i.e. for which we need its identity), it also destroys its <em>old value</em>. Exception 6b) tells us that our notation convention is to write down the indication of the value destroyed, the value replaced:</p>						<blockquote>							<p class="noindent">&quot;<var>x</var>:= <var>x</var> + 1&quot; is read:</p>						</blockquote>						<p class="noindent">&quot;the value of <var>x</var> is replaced by its value plus one&quot;. If the left hand side starts with <b>val</b>, the reference in question is found by omitting &quot;<b>val</b>&quot;, otherwise by prefixing it with &quot;<b>ref</b>&quot;. (At the beginning I was very unhappy about this convention, after some time I found that it makes sense: you mention &quot;old&quot; and &quot;new&quot; value.)</p>						<p>If <var>y</var> is a value of type &quot;reference&quot; its type comprises the type of <b>val</b> <var>y</var></p>						<p class="noindent">Given three variables <var>a</var>, <var>b</var> and <var>c</var>, compare the two programs</p>						<p class="noindent">1) printing the maximum value.</p>				<blockquote>					<p class="noindent"><b>var</b> <var>max</var>: real</p>					<p class="continue"><b>if</b> <var>a</var> &gt; <var>b</var> <b>then</b> <var>max</var>:= <var>a</var> <b>else</b> <var>max</var>:= <var>b</var>;<br>						<b>if</b> <var>c </var>&gt; <var>max</var> <b>do</b> <var>max</var>:= <var>c</var>;<br>						print(<var>max</var>)</p>				</blockquote>				<p class="noindent">2) changing the sign of the maximum value</p>				<blockquote>							<p class="noindent"><b>var</b> <var>max</var>: <b>ref</b> real;<br>						<b>if</b> <var>a</var> &gt; <var>b</var> <b>then</b> <var>max</var>:= <b>ref</b> <var>a</var> <b>else</b> <var>max</var>:= <b>ref</b> <var>b</var>;<br>						<b>if</b> <var>c</var> &gt; <var>max</var> <b>do</b> <var>max</var>:= <b>ref</b> <var>c</var>;<br>						<b>val</b> <var>max</var>:= - <b>val</b> <var>max</var></p>						</blockquote>						<p>With the above two examples I have made my first point, viz. to find a clean interface expressing when evaluations have to take place, when I operate on values, when on identities. Any well-motivated suggestion about syntactic sugar (for the declaration for instance) is welcome.</p>						<p>The next point deals with types and type control. When declaring a variable its type should be given either</p>						<blockquote>							<p class="noindent"><b>var</b> <var>prime</var>: boolean</p>						</blockquote>						<p class="noindent">i.e. naming a type, or</p>						<blockquote>							<p class="noindent"><b>var</b> prime: (true, false)</p>						</blockquote>						<p class="noindent">i.e. enumerating its possible values.</p>						<p>The latter arrangement suggests to write</p>				<blockquote>					<p class="noindent"><b>type</b> bintree:</p>					<p class="continue">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tree1,</p>					<p class="continue">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tree2(<var>number</var>: real, <var>left</var>:bintree, <var>right</var>:bintree))</p>				</blockquote>				<p>Here we introduce a type called &quot;bintree&quot; with two mutually exclusive values, either &quot;tree1&quot;, which is used to denote the empty tree, or &quot;tree2&quot; which is a node comprising three variables called &quot;<var>number</var>&quot; (of type &quot;real&quot;), &quot;<var>left</var>&quot; and &quot;<var>right</var>&quot; both of type &quot;bintree&quot;. Upon assignment of the value tree2, three suitable values should be supplied as actual parameters.</p>				<p>We can now write the boolean procedure &quot;in&quot; testing whether a given value is in a tree or not and adding it to the tree when it is not.</p>						<p class="noindent"><b>boolean</b> <b>procedure</b> in(<var>T</var>: <b>ref</b> bintree, <var>num</var>: <b>val</b> real)<br>					<b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case</b> <b>val</b> <var>T</var> <b>of</b><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(= tree1: {<var>in</var>:= <b>false</b>; <b>val</b> <var>T</var>:= tree2(<var>num</var>, tree1, tree1)}<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;= tree2: {<b>case</b> <var>number</var>(<b>val</b> <var>T </var>) <b>of</b><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(= <var>num</var>: {<var>in</var>:= <b>true</b>}.<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&gt; <var>num</var>: {<var>in</var>:= in(<b>ref</b> left(<b>val</b> <var>T </var>), <var>num</var>)}.<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt; <var>num</var>: {in:= in(<b>ref</b> right(<b>val</b> <var>T </var>), <var>num</var>)})).</p>						<p class="noindent">or, if you prefer a non-recursive procedure</p>						<p class="noindent"><b>boolean</b> <b>procedure</b> in(<var>T</var>: <b>ref</b> bintree, <var>num</var>: <b>val</b> real)<br>					<b>begin</b> <b>var</b> <var>curtree</var> <b>ref</b> bintree:= <var>T </var>; (this is an initializing declaration.)<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>var</b> <var>found</var>: boolean:= <b>false</b>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>var</b> <var>diff</var>: real;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>while</b> <b>val</b> <var>curtree</var> = tree2 <b>and</b> <b>non</b> <var>found</var> <b>do</b><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>begin</b> <var>diff</var>:= number(<b>val</b> <var>curtree</var>) - <var>num</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <var>diff</var> = 0 <b>then</b> found:= <b>true</b><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>else</b><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>curtree</var>:= <b>if</b> <var>diff</var> &gt; 0 <b>then</b> <b>ref</b> left(<b>val</b> <var>curtree</var>)<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>else</b> <b>ref</b> right(<b>val</b> <var>curtree</var>)<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>end</b>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>if</b> <b>non</b> <var>found</var> <b>do</b> <b>val</b> <var>curtree</var>:= tree2(<var>num</var>, tree1, tree1);<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>in</var> := <var>found</var><br>					<b>end</b></p>						<p>To use the type and the procedure one can declare</p>						<p><b>var</b> <var>TREE</var>: bintree:= tree1; in(<b>ref</b> <var>TREE</var>, 3.25) .</p>						<p>A complication arises when we want to write a procedure removing the minimum element from a tree. In the heading we want to describe that initially it should be a non-empty tree; as a result of the call, however, it could become empty. I suggest as heading</p>						<p class="noindent"><b>real</b> <b>procedure</b> minmove(<var>T</var>: <b>ref</b> tree2 - bintree)</p>						<p class="noindent">telling that initially the actual parameter is restricted to the subtype &quot;tree2&quot; while eventually it may be of the general type bintree. A non-recursive version then is (after the above heading)</p>						<p class="noindent"><b>begin var</b> <var>curtree</var>: <b>ref</b> bintree:= <var>T</var>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>var</b> <var>leftree</var>: <b>ref</b> bintree:= <b>ref</b> left(<b>val</b> <var>T </var>);<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>while</b> <b>val</b> leftree = tree2 <b>do</b><br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<b>begin</b> <var>curtree</var>:= <var>leftree</var>; <var>leftree</var>:= <b>ref</b> left(<b>val</b> <var>leftree</var>) <b>end</b>;<br>					&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<var>minmove</var>:= number(<b>val</b> <var>curtree</var>); <b>val</b> <var>curtree</var>:= right(<b>val</b> <var>curtree</var>)<br>					<b>end</b></p>						<p class="noindent">(note: the heading of &quot;in&quot; could be:</p>						<p class="noindent"><b>boolean</b> <b>procedure</b> in(<var>T</var>: <b>ref</b> bintree - tree2, <var>num</var>: <b>val</b> real) )</p>						<p class="noindent">In all this I am aiming at an interface such that a translator can do all type checking. I have a strong feeling that if this cannot be done, one has the wrong concept of type! To ease this analysis I am willing to add syntactic sugar (in the form of the type-controlled <b>case</b> clause or the type-controlled <b>while</b> clause.) I hope that a translator can check that the call of &quot;minmove(<b>ref</b> TREE)&quot; will only occur with TREE = tree2.</p>						<p>I know that you have paid much attention to such questions in an earlier stage of your life; it is only now that I am beginning to become ripe for such questions and would value your comments very much. Yours are fine shoulders to stand upon!</p>						<p>Thank you for the handwritten letter with the sketch of a proof for the transposition algorithm. I am glad that you enjoyed the algorithm. Some fifteen years ago I was introduced to Christopher Strachey by Aad van Wijngaarden at some conference. Aad and I entered a restaurant and Christopher was sitting alone at a table. Aad asked whether we could join him and we were introduced. Christopher posed the problem and within five minutes &#x2014;this was a time when I was still a bright boy!&#x2014; I produced the solution. Some months ago the problem was posed to me again, I recognized the problem but had forgotten my solution; this second time it took me ten minutes to reconstruct it. this just shows what age does to you! My grapevine tells me that you have shown the algorithm both to Brian Randell and Niklaus Wirth. Small world we live in!</p>						<p>Returning for a last time to the main subject of this letter: I am looking for a program representation from which it is at any moment obvious which values are defined (and how) and which are not. The two mutually exclusive forms of the value of a variable of type bintree are suggested by the analogy of the recursive procedure which must contain a <em>condition</em> call upon itself. The node which is either empty or &quot;a set of fields&quot; is the spatial analogue of &quot;<b>if</b> <var>B</var> <b>do</b> <var>S</var>&quot; which, when executed, takes one of two mutually exclusive forms, either empty or <var>S</var>.</p>						<p>Shall I have the privilege of your answer to my questions?</p>					</div>					<div align="center">						<p>Yours ever</p>						<p>Edsger</p>						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prof.dr.Edsger W.Dijkstra</p>					</div>					<div align="left"></div>					<div align="left">						<p><u></u></p>					</div>					<hr>					<font size="-1">transcribed by Tristram Brelstaff<br>						revised <csobj format="MedDate" h="16" region="15" t="DateTime" w="96">Thu, 8 Jul 2010</csobj></font>			<p></p>			<p></p>			</body></html></div>
</body>
</html>
