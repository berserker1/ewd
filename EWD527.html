  <!DOCTYPE html>
  <html>
  <head>
    <title>On units of consistency</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <link href="assets/tweet-selection.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.12.0.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="assets/tweet-selection.js"></script>
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: On units of consistency" />
    <meta name="twitter:title" content="On units of consistency" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>On units of consistency</h1>
  <div class='body'>
			<p>(This is a replacement of EWD490 "Detection of malfetching of instructions", which never got completed.)</p>
			<p>I am getting more and more worried about reliability. My natural pessimism got new food when I was told that the chips of pocket calculators are, in general, totally unchecked: the manufacturers don't know how to do it, and the rule is, therefore, that, if the customer complains, he gets a new one. Isn't that a simple solution.....</p>
			<p>With regard to the reliability issue with large computers, we can try similar, but on closer inspection quite different things:
				<br/>a)&nbsp;&nbsp;&nbsp;&nbsp; reduce the probability of an undetected machine malfunctioning
				<br/>b)&nbsp;&nbsp;&nbsp;&nbsp; increase the probability that a correct result will be produced
				<br/>c)&nbsp;&nbsp;&nbsp;&nbsp; decrease the probability that a wrong result will be produced as if it were a correct one.
			</p>
			<p>Techniques primarily directed towards target (a) are parity checks and redundant execution of arithmetic operations. They are very popular, and their popularity is well-deserved. They are neutral &mdash;i.e. generally applicable&mdash; built-in checks of great diagnostic value as far as hardware maintenance is concerned. They only serve the next two targets under the additional assumption that detected errors have a much greater probability of occurrence than undetected ones, an assumption which, alas, is often unjustified.</p>
			<p>Techniques primarily directed towards target (b) combine &mdash;an effort at&mdash; error detection with &mdash;an effort at&mdash; error correction, under the motto "The show must go on." It may be a very local error correction, it may be a much more global recovery procedure. I have limited experience with such techniques, and, besides that, I have my doubts, because to the possibility of undetected errors the possibility of erroneously corrected errors has been added.</p>
			<p>Target (c) is the most modest one: we sincerely hope, that the machine performs so well that the correct result will be produced and would be happy if each harmful machine malfunctioning would lead to abortion before the wrong result has been produced. The latter goal was the one discussed in EWD482. We now return to it in a more restricted environment, viz. the problem of the fetching of instructions.</p>
			<p>
				In order to simplify my discussion I shall assume that programs are represented with one instruction per word, and that each word is stored with a parity bit. (The following is also valid under the assumption of a more redundant word-wise redundancy.) The question is: how certain are we, that the correct instructions are executed, i.e. that the correct bit-patterns appear in the instruction register? There seem to be roughly three things that can go wrong:
				<br/>a)&nbsp;&nbsp;&nbsp;&nbsp; while reading the instruction a multiple-bit error has occurred that has not been caught by the parity check
				<br/>b)&nbsp;&nbsp;&nbsp;&nbsp; the instruction that reached the instruction register is the result of the perfect reading of the wrong word
				<br/>c)&nbsp;&nbsp;&nbsp;&nbsp; the correct word has been read correctly, but the bit pattern has been corrupted somewhere on its way from the last checking station to the instruction register.
			</p>
			<p>
				Error (b) can be caused in two different ways:
				<br/>b1)&nbsp;&nbsp;&nbsp;&nbsp; the program is correctly stored, but the wrong word has been read because something happened in the instruction counter or in the way from instruction counter to memory selection register
				<br/>b2)&nbsp;&nbsp;&nbsp;&nbsp; one of the instructions of the stored program has erroneously been overwritten (with a perfect parity of course!).
			</p>
			<p>
				At least one system has been designed in which the instructions of a program are stored with a sum-check included, and, regularly, the machine interrupts its normal activities and inserts a sum-checking interlude in order to increase the confidence that all programs are still correctly stored. This approach, however, has a considerable number of unattractive consequences.
				<br/>1)&nbsp;&nbsp;&nbsp;&nbsp; because the sum-checking interludes have to be inserted at the expense of the machine's productivity, we have to settle the conflict, how frequently these interludes should be inserted
				<br/>2)&nbsp;&nbsp;&nbsp;&nbsp; in a paging machine, we have to perform the sum-check before a program page (of which I assume that it is not dumped) is overwritten by another page
				<br/>3)&nbsp;&nbsp;&nbsp;&nbsp; it only catches error (b2), and if errors (a), (b1) and (c) can occur as well &mdash;and why shouldn't they?&mdash; it is not very effective in view of our target (c). (In all fairness I should mention that the system in which this technique was applied had been designed for message switching, and in that area the usual attitude is that anything may go wrong, provided that the system comes in the air again. Whether this is a realistic and defensible attitude, is a question beyond the scope of this note.)
		  </p>
			<p>The only way to catch errors (a), (b) and (c), <u>all</u> at the same time, is to perform the sum-check &mdash;or the embellishment of a cyclic redundancy check as is done with words from a tape&mdash; on the successive contents of the instruction register, more precisely: each time <em>after</em> the instruction has been executed. (For the sake of simplicity I assume that during instruction execution the contents of the instruction register remains unchanged, knowing full well that there are machines for which this assumption does not hold: in that case the following can probably be made applicable by extracting for checking purposes the contents of the instruction register just before it is going to be modified. In the sequel we shall ignore the complication.)</p>
			<p>The considerations in the previous paragraph tie the checking to the sequencing of the control; to do justice to this we introduce the notion of "a chunk":</p>
			<blockquote>a chunk occupies a number of consecutively stored instructions, of which the first is always the only so-called "redundancy dummy" in the chunk, and the last one is the only jump-instruction in the chunk; each execution of the redundancy dummy of a chunk leads some time later to the execution of the terminal jump-instruction of that chunk &mdash;because no jump-instructions occur in the interior of a chunk; each execution of a terminal jump-instruction of a chunk has been preceded by a corresponding execution of the redundancy dummy at the beginning of that chunk, because no jump-instruction is expected to transfer control to anything else but a redundancy dummy of a chunk. <u>Note</u>. When for a conditional jump-instruction the condition is not satisfied and the jump-instruction acts like a skip, it is regarded "to transfer control" to the next instruction in store. (End of note.)</blockquote>
			<p>
				Behind the instruction register an extra register of the length of a word is introduced, the so-called Instruction Redundancy Register "IRR". Each instruction, as it has arrived and has been executed in the instruction register is added &mdash;without carry propagation, I presume, i.e. bit-wise modulo 2&mdash; to the IRR, after IRR has been "rotated" over one place to the left; I have put "rotated" between quotes: a pure rotation means that the digit pushed out at the left is added at the least significant position at the right-hand side of IRR, but in a general "rotation" that addition may take place at a number of other bit-positions as well. The processing of a jump-instruction &mdash;which is always a terminal jump-instruction&mdash; has two additional effects:
			  <br/>1)&nbsp;&nbsp;&nbsp;&nbsp; after the jump-instruction has been processed (its addition to the "rotated" IRR included) the contents of the IRR is required to be all zeros; with only target (c) in mind, the machine could stop immediately.
				<br/>2)&nbsp;&nbsp;&nbsp;&nbsp; the next word selected under control of the instruction counter and brought to the instruction register is by definition a redundancy dummy and, independent of its bit-pattern, its execution is further semantically equivalent to a skip.
			</p>
			<p>The additional storage space occupied by each chunk is the redundancy dummy at its begin; because the interpretation of the redundancy dummy is independent of its bit pattern, the redundancy dummy can always be determined such that, when the chunk was entered with IRR = 0 , it will be left with IRR = 0. This is the reason why IRR has been chosen with the length of one word = the length of one instruction: it may not have more bits than the redundancy dummy, which was supposed to occupy one word.</p>
			<p class="noindent"><u>Remark</u>. Not rotating IRR would make the check insensitive to the interchange of any two instructions; pure rotation would make it insensitive to the interchange of two instructions for which the addresses of the locations occupied by them have a difference equal to the word-length. "Rotation" can rule that out. (End of remark.)</p>
			<p align="center"><sup>*</sup> &nbsp; &nbsp; &nbsp; &nbsp; <sub>*</sub> &nbsp; &nbsp; &nbsp; &nbsp; <sup>*</sup></p>
			<p>Since the above was written I have been reading in <i>Algebraic Coding Theory</i> by Elwyn R.Berlekamp (McGraw-Hill Book Company, New York, 1968), in particular chapter 4 "The Structure of Finite fields"; for our purpose the most important mathematical result is the following. As operation on IRR we consider the following "rotating" step:</p>
			<blockquote>the contents of IRR are shifted over one place to the left and the bit shifted out is added (modulo 2) at a well-chosen number of bit positions in IRR (among which the right-most one). For any wordlength <var>n</var>&nbsp; the positions where the bit shifted out is added can be chosen in such a way that the step induces a cyclic order of the 2<sup><var>n</var></sup>-1 IRR-contents &#x2260; 0, in the sense that the step transforms each value into the next. Starting with a value &#x2260; 0, we have to repeat the step 2<sup><var>n</var></sup>-1 times, before the starting value reappears. The value 0 is obviously transformed by the step into itself.</blockquote>
<p>The above made me understand why I was so much attracted by the "rotating" step as described above: it gives a great protection if there is a relatively large probability that while reading and executing a chunk two instructions will be corrupted in the <em>same</em> bit positions &mdash;with a parallel data path transporting the instructions from memory to instruction register, this is indeed a form of malfunctioning that should be considered&mdash; . If we don't shift at all, two such equal corruptions will always cancel; in the case of a pure rotation, such a corruption has returned to its original position in IRR after every &nbsp;n&nbsp; steps, and, therefore, two identical misreadings will cancel if they occur in the same chunk &nbsp;<var>n</var>&nbsp; (or 2<var>n</var> or 3<var>n</var>, etc.) words apart. With the proper choice of a "rotating" step we can ensure that this distance should be &nbsp;2<sup><var>n</var></sup>-1 .</p>
			<p>With &nbsp;<var>n</var> = 30, we have the probability &nbsp;2<sup>-30</sup> = 10<sup>-9</sup>&nbsp; that the erroneous reading of a chunk will not be caught. If, for instance, half of the instructions of one chunk have been executed and the instruction counter contents is disturbed, and program execution is continued somewhere in another chunk, the probability that this error would escape the zero-check at the end of the second chunk is 10<sup>-9</sup>.</p>
			<p class="noindent"><u>Note</u>. Under the (unrealistic) assumption that "skipping" an instruction &mdash;i.e. increasing the instruction counter by 2 instead of by 1&mdash; is the only malfunctioning to guard against, our "rotating" step has a curious consequence. For each value of IRR there exists exactly <em>one</em> next instruction whose execution would not change the value of IRR. If that were the next instruction, skipping it would not be detected! And, if all our 10<sup>9</sup> instructions are equally probable, there would be a probability of 10<sup>-9</sup> that skipping an instruction would remain undetected. There is, however, a remedy against that. Let at a given place &nbsp;<var>Q</var>&nbsp; be the instruction whose skipping would not be detected. If &nbsp;<var>Q</var>&nbsp; is the skip-instruction, we don't need to continue our text with it, but we may (skipping the skip-instruction is a harmless error that we don't need to detect); if, however, &nbsp;<var>Q</var>&nbsp; is not the skip-instruction and it so happens that it is the next instruction with which we would like to continue our code, we can insert a skip-instruction. The execution of that skip-instruction would then change the contents of IRR and at the next place it is safe to place the instruction &nbsp;<var>Q</var> . The moral of this story is that either we accept the probability of 10<sup>-9</sup> that the skipping of an instruction will escape our check, or once every 10<sup>9</sup> instructions our compiler would have to insert a skip-instruction! As for other reasons we have to be content with the probability of 10<sup>-9</sup> for an undetected error, I would not burden a compiler with that obligation of inserting a skip; I only mention the result, because it is a remarkable one: I have never seen this form of trade off between reliability and storage space before. (End of note.)</p>
			<p align="center"><sup>*</sup> &nbsp; &nbsp; &nbsp; &nbsp; <sub>*</sub> &nbsp; &nbsp; &nbsp; &nbsp; <sup>*</sup></p>
			<p>The idea of this form of added protection to the reading of instructions emerged a year ago (December 1974, Tripreport EWD466:"on the way back I thought [...] on redundant object code representations. (To think again thoughts with a possibly direct bearing on machine design is great fun!) By the time I crossed the German/Dutch border I had arrived to a few firm conclusions. [...] I am not sure when I shall find the time to work this out and write a readable report about it."). Now it is eleven months later; the fact that the above was not written down earlier was, however, not the result of a lack of time, but was caused by the fact that I got stuck. As the design stands, there is one sequencing error that is not caught. At the end of the execution of a chunk it is checked whether IRR equals zero. (If the IRR-contents differ from zero but the check fails to discover it, the non-zero contents of IRR are "rotated" before the next redundancy dummy is added to it, so we have at the completion of the next chunk a second chance of detecting that IRR differs from all zeroes.) If, however, program execution now proceeds with the wrong chunk, it will <u>not</u> be detected! I tried all sorts of embellishments, but none of them was convincing. This report is written now, because I think that now I understand, why I failed.</p>
			<p>The word is the minimum unit of consistency, and is, as such, protected by the parity check. Even if this check is effective &mdash;many parity bits per word, say&mdash; , so effective in fact that the risk of undetected corruption internal to a word can be tolerated, error (b) of page 1: the <em>perfect</em> reading of the <em>wrong</em> word remains an unchecked risk.</p>
			<p>For that reason a next larger unit of consistency is introduced, viz. the chunk. The linear execution of all the individual instructions of a chunk and the check upon IRR = 0 is the perfect analogy of the parity bit! (Compare it with the parity bit for a serial store, delivering the bits of a word one after the other.) I now tend to consider it as the main function of the chunk with its redundancy to guard against error (b); the fact that it also picks up most of the "left-overs" of the parity check is a nice accidental feature &mdash;on account of which we may tell ourselves that a single parity bit per word will suffice&mdash;, but it is not the essential one: it does as a matter of fact, blur the picture. (With many parity bits per instruction, we could have sent them all to the instruction register and have performed the parity check form there, after instruction execution.)</p>
			<p>
				But now, IRR and the redundancy dummy per chunk appear as a completely independent check, that is active each time a whole chunk is executed. But just as this mechanism is independent of the parity bits &mdash;i.e. the internal protection of the next smaller unit of redundancy&mdash; in the same way a mechanism checking that we don't have the <em>perfect</em> execution of the <u>wrong</u> chunks should be designed independent of the internal protection of the chunks themselves. There are a number of reasons in favour of this separation.
				<br/>1)&nbsp;&nbsp;&nbsp;&nbsp; with a probability of 10<sup>-9</sup> of a left-over &mdash;i.e. an undetected error of the internal chunk consistency&mdash; I think that we can afford to forget about the left-overs
			  <br/>
			  2)&nbsp;&nbsp;&nbsp;&nbsp; IRR and the redundancy dummy are neutral in the sense that they can be built into <em>any</em> machine that has an instruction counter a jump instruction; I have considered additional techniques for checking the admissibility of the dynamic successor relation between chunks, but they turned out to assume some sequency discipline, at least more disciplined than wild <u>goto</u>'s. Perhaps I find a solution without such assumptions; in any way it makes clear that checking the sequencing from chunk to chunk is a separate issue.
			</p>
			<p>&nbsp;</p>
			<table width="100%" border="0" cellspacing="0" cellpadding="0">
			  <tr>
			    <td width="62%">10th November 1975<br />
		        Plataanstraat 5<br />
		        NUENEN - 4565, the Netherlands</td>
			    <td width="38%" valign="top">prof.dr.Edsger W.Dijkstra<br />
		        Burroughs Research Fellow</td>
		      </tr>
		  </table>
        </div>
		<div></div>
		<hr />
		<div id="footer">
			<font size="-1">
				transcribed by Chrys Alexander Panayiotou
				<br />revised <csobj format="MedDate" h="13" region="15" t="DateTime" w="96"><!-- #BeginDate format:En2 -->16-Aug-2013<!-- #EndDate --></csobj>
			</font>
		</div>
	</div>
</body>
</html>


</div>
  <script>
$('body').tweetSelection({
  height: 300,
  width: 600,
  minimumTextSelected: 3,
  shareClass: '.tweet-selection',
  ellipsis: '...',
  quoteLeft: '\'',
  quoteRight: '\'',
  via: 'raboofje'
});
  </script>
  </body>
  </html>
