  <!DOCTYPE html>
  <html>
  <head>
    <title>Concurrent programming: a preliminary investigation</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="Concurrent programming: a preliminary investigation" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>Concurrent programming: a preliminary investigation</h1>
  <div class='body'>
           <hr />
           <p class="noindent">NOTE: This transcription was contributed by Martin P.M. van der Burgt, who has devised a process for producing transcripts automatically. Although its markup is incomplete, we believe it serves a useful purpose by virtue of its searchability and its accessibility to text-reading software. It will be replaced by a fully marked-up version when time permits. &mdash;HR</p>
           <hr />
<p class="noindent">
  <p class="noindent">14th February 1975
  <p><b>Concurrent programming: a preliminary investigation</b>.
<p>(Instead of the usual term &ldquo;parallelism&rdquo; I prefer the term &ldquo;concurrency&rdquo;:
parallelism is a term that I would like to reserve for a number of rather
identical components, progressing &ldquo;in parallel&rdquo;, i.e. in rather strict
synchronism. The term &ldquo;concurrency&rdquo; only refers to the (possibility of)
simultaneous activity.)
<p>I observe that rather operational approaches to the problem of defining
the semantics of programming languages encounter problems when it is tried
to extend them to &ldquo;concurrent programming languages&rdquo;. The way in which the
problem manifests itself is that a set of sequential processes &mdash;all by
themselves well-understood&mdash; are allowed to operate in a common memory (at
some grain of interleaving) and that then the non-determinacy is 
investigated that is generated by this uncontrolled interleaving. This form of 
non-determinacy is &mdash;not surprisingly&mdash; rather hard to cope with.
<p>What I have done in the past year suggests a rather different attack.
In that year I have introduced &mdash;not necessarily deterministic&mdash; programs by
regarding them as (codes for) predicate transformers. During that stage it
is totally irrelevant that the program can also be interpreted as executable
code for a sequential machine (that is only a pleasant surprise when we try
to implement the programming language the next day). Because initial and final
states are by definition connected by a predicate transformer (and only 
tomorrow, when we consider implementations, by a long chain of intermediate
states) nothing in my language is &ldquo;sequential&rdquo; as long as I do not drag 
implementations into the picture. The result is that I do not truly understand
anymore what is meant by the usual phrase &ldquo;parallel programming languages&rdquo;,
and that I see only one feasible way of attacking the problem: designing a
programming language in my usual way, and then observing (tomorrow) that an
implementation with a lot of concurrency is possible. (The language design
may silently be motivated by that possibility, but that should not confuse
us today, when neither implementation, and a fortiori &ldquo;time&rdquo; nor &ldquo;concurrency&rdquo;
play any role at all.) It is fairly obvious that our programming language
should be non-deterministic, but that need not frighten me anymore: it is,
after all, now more than a year ago that I decided to regard non-determinacy
as the rule and determinacy as a &mdash;not very interesting&mdash; special case. This
report &mdash;of which I hope that it will be followed by others on the same topic&mdash;
is only a preliminary survey. (My intention to introduce the possibility of
concurrency dates &mdash;according to my notes&mdash; back to January 1973, but 
non-determinacy had to be catered for first &mdash;-fall 1973&mdash;. A new incentive to
take up this investigation I received at the IBM-Seminar at Newcastle in
September 1974, but I wanted to finish my book first.)
<p><b>The reversal of an algorithm</b>.
<p>This section records an observation that we made in the fall of 1974
&mdash;while we were playing with little programs&mdash; an observation to which we
did not pay much attention at the time (it was not even recorded). The other
week, when making programs fit for concurrent execution, we were suddenly
reminded of it .
<p>Our example dealt with a recognizer for the following syntax:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      &lt; <var>sentence</var> &gt; ::= &lt; <var>expression</var> &gt; ;                                     </td> </tr> <tr> <td></td> <td>
      &lt; <var>expression</var> &gt; ::= &lt; <var>primary</var> &gt; {&lt; <var>operator</var> &gt; &lt; <var>primary</var> &gt;} </td> </tr> <tr> <td></td> <td>
      &lt; <var>primary</var> &gt; ::= &lt; <var>digit</var> &gt; {&lt; <var>digit</var> &gt;} | (&lt; <var>expression</var> &gt;)  </td> </tr>
</table>
where the braces are to be read as &ldquo;followed by zero or more instances of
the enclosed&rdquo;.
<p>We assume that our recognizer finds the characters of the text in an
array variable &ldquo;in&rdquo;, where &ldquo;in.low&rdquo; is the currently &ldquo;lowest&rdquo; element &mdash;i.e.
the one with the lowest index value&mdash; and the operation &ldquo;in:lorem&rdquo; removes
from &ldquo;in&rdquo; this lowest element. (We have separated the reading of the next
symbol and the moving of the tape.) The call &ldquo;sent&rdquo; will do the recognition
&mdash;i.e. if &ldquo;in&rdquo; does not begin with a sentence, the program will abort&mdash; if we
assume the self-explanatory boolean procedures &ldquo;issemi&rdquo;, &ldquo;isopen&rdquo;, &ldquo;isclose&rdquo;,
&ldquo;isop&rdquo; and &ldquo;isdigit&rdquo; with a symbol as argument available.
<table> <tr> <td colspan = 4>
<b>proc</b> sent:   exp; <b>if</b> issemi(in.low) &rarr; in:lorem <b>fi</b> <b>corp</b>;                           </td> </tr> <tr> <td colspan = 4>
<b>proc</b> exp:    prim; <b>do</b> isop(in.low) &rarr; in:lorem; prim <b>od</b> <b>corp</b>;                      </td> </tr> <tr> <td colspan = 4>
<b>proc</b> prim:   <b>if</b> isdigit(in.low) &rarr; in:lorem; <b>do</b> isdigit(in.low) &rarr; in:lorem <b>od</b> </td> </tr> <tr> <td></td> <td>&nbsp; </td> <td colspan = 2>
              &#x25af; isopen(in.1ow) &rarr; in:lorem; exp;                                                        </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                          <b>if</b> isclose(in.low) &rarr; in.lorem <b>fi</b>                                      </td> </tr> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
             <b>fi</b> <b>corp</b> .                                                                               </td> </tr>
</table>
Here, sent , exp and prim try to remove from the low end of &ldquo;in&rdquo; the
largest &lt; <var>sentence</var> &gt;, &lt; <var>expression</var> &gt; and &lt; <var>primary</var> &gt; respectively that they
can find. If they cannot do so (because in.low is inacceptable) they abort.
Note, that there are only three reasons for abortion: a missing semicolon
where it is needed (e.g. on the text &ldquo;123(....&rdquo;) in sent, a missing digit
or open parenthesis (e.g. on the text &ldquo;123+)....&rdquo;) in prim, or a missing
closing parenthesis were it is needed (e.g. &ldquo;(123(...&rdquo;) in prim as well.
<p>The observation we made that the generator of an arbitrary &lt; <var>sentence</var> &gt;
&mdash;we take the liberty of not bothering about termination&mdash; can be derived from
the recognizer in a straightforward manner. (The operations &ldquo;out:hiext&rdquo;
add symbols at the high end of the array variable &ldquo;out&rdquo;, which is initially
assumed to be empty.)
<table> <tr> <td colspan = 4>
<b>proc</b> sent:  exp; out:hiext(semi) <b>corp</b>;                                                      </td> </tr> <tr> <td colspan = 4>
<b>proc</b> exp:   prim; <b>do</b> ?? &rarr; out:hiext(op); prim <b>od</b> <b>corp</b>;                   </td> </tr> <tr> <td colspan = 4>
<b>proc</b> prim:  <b>if</b> true &rarr; out:hiext(digit); <b>do</b> ?? &rarr; out:hiext(digit) <b>od</b> </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
                 &#x25af; true &rarr; out:hiext(open); exp;                                               </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                      out:hiext(close)                                                                    </td> </tr> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
            <b>fi</b> <b>corp</b>  .                                                                      </td> </tr>
</table>
(Here <b>do</b> ?? &rarr; S <b>od</b> means &ldquo;zero or more times S&rdquo;, i.e. it is short for
something like
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
     goon := true;                                                    </td> </tr> <tr> <td></td> <td>
     <b>do</b> goon &rarr; S &#x25af; goon - goon:= false <b>od</b> . </td> </tr>
</table>
This notation with questionmarks has been introduced here for convenience,
and also with the intention of presenting recognizer and generator with
exactly the same layout.) The transformation from generator to recognizer
is equally obvious.
<p>We liked the transformations and said to each other &ldquo;That is nice,
isn&rsquo;t it?&rdquo;, in my short enthousiasm I showed it twice to a colleague, and
then we turned to other matters. At that moment we had clearly other interests,
for none of us remarked that the output of such a generator could be fed
directly as input into a concurrent recognizer.
<p align="center" class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>*</p> 
<p><b>Buffering mosquitos</b>.
<p>A configuration that I would like to study at some state of the game
is a so-called &ldquo;elephant built from mosquitos&rdquo;. Mosquitos are little machines
and they have a few connections &mdash;&ldquo;legs&rdquo;&mdash; and an input-leg of one mosquito
is paired to the output-leg of another mostquito. When one mosquito transfers
information to another one, I shall use in the description of both mosquitos
the same name for the connection: if a sending mosquito transmits via leg
A the current value of its local variable x , we shall denote this in its
text by &ldquo;A:= x&rdquo; ; in the description of the receiving mosquito that
assigns the transmitted value to its local variable y , reception will be
indicated by &ldquo;y:= A&rdquo; and for the time being we shall assume that some magic
sees to it that these two statements are executed simultaneously, i.e. legs
are not supposed to contain memory elements.
<p>A one-place buffer is easily coded as a mosquito: let it have one
input leg, A say, and one output leg, B say; then its text can be:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
     <b>do</b> true &rarr; x:= A; B:= x <b>od</b> . </td> </tr>
</table>
This is a fully deterministic mosquito: after the one-place buffer has been
filled, we can only empty it and vice versa.
<p>More interesting is a mosquito buffering (FIFO) a maximum of, say, 20
values. Suppose that it has a classical array with twenty elements from
buf(0) through buf(l9) . In its simplest form &mdash;and too naive&mdash; we can code
it (with &ldquo;f&rdquo; for &ldquo;filling&rdquo; and &ldquo;e&rdquo; for &ldquo;emptying&rdquo;)
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      f, e := 0, 0;                                                </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>do</b> true &rarr; buf:(f)= A; f:= (f + 1) <b>mod</b> 20; </td> </tr> <tr> <td></td> <td>&nbsp; </td> <td>
       &#x25af; true &rarr; B:= buf(e); e:= (e + 1) <b>mod</b> 20  </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>od</b>  .                                                 </td> </tr>
</table>
But this is very naive, even if we assume that the selection of 
alternatives is dependent on whether the environment is ready to offer via A and/or
to accept via B a next value. We are making rather strong assumptions about
the decency of that environment and it seems nicer to make the mosquito
itself control its capacity and contents, i.e.
<p class="noindent">let nf be the number of values accepted via A
<br>let ne be the number of values delivered via B
<br>then the values accepted but not yet delivered should be stored (in order
of age) as the values buf(e) through buf((e + nf - ne -1)<b>mod</b> 20)
and the mosquito itself should maintain
<table width=100%><tr><td valign=top width=10%>
P:</td><td> 0 &le; nf - ne &le; 20        which leads to the program
</td>  </tr>  </table>
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      f, e := 0, 0; nf, ne := 0, 0;                                                       </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>do</b> nf - ne &lt; 20 &rarr; buf:(f)= A; f:= (f + 1) <b>mod</b> 20; nf:= nf + 1 </td> </tr> <tr> <td></td> <td>&nbsp; </td> <td>
       &#x25af; nf - ne &gt;  0 &rarr; B:= buf(e); e:= (e + 1) <b>mod</b> 20; ne:= ne + 1 </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>od</b> .                                                                         </td> </tr>
</table>
<p>We leave to the reader the exercise to convince himself that the
following program will do the job as well, provided K &ge; 21:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      f, e := 0, 0; n1, n2 := 0, 0;                                                                           </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>do</b> (n1 - n2) mod K &lt; 20 &rarr; buf:(f)= A; f:= (f + 1) <b>mod</b> 20; n1:= (n1 + 1) <b>mod</b> K </td> </tr> <tr> <td></td> <td>&nbsp; </td> <td>
       &#x25af; (n1 - n2) mod K &gt;  0 &rarr; B:= buf(e); e:= (e + 1) <b>mod</b> 20; n2:= (n2 + 1) <b>mod</b> K </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>od</b>  .                                                                                            </td> </tr>
</table>
(The easiest way to do this seems to maintain first the statements operating
on nf or ne and then to prove the invariance of P.)
<p>I would like to make the following remarks about the above programs.
<br><b>Remark 1</b>. I have not bothered about &ldquo;termination&rdquo; but that is so easily
fixed that I feel entitled to allow myself the convenience.(End of remark 1.)
<br><b>Remark 2</b>. From a time-less point of view, the FIFO buffer is strictly
deterministic: the output stream equals the input stream. It is only when
we consider the sequence of consumptions via A and production via B , that
the non-determinism shows itself. When we consider this program as working
in a fully cooperative environment &mdash;i.e. willing to produce via A and to
accept via B when our mosquito feels like it&mdash; the non-determinism of the
sequential program displays the complete freedom we envisage (with the possibly
meaningless exception that as long as we regard the above executed by a
strictly sequential machine, production and consumption will never take
place simultaneously.) (End of remark 2.)
<br><b>Remark 3</b>. Very little prohibits &ldquo;concurrent execution&rdquo; of both alternatives.
We must make the assumption that &ldquo;buf:(f)= A&rdquo; and &ldquo;B:= buf(e)&rdquo; will not
interfere with each other when tried concurrently, but with e &ne; f . We must
further make the assumption that programs dealing with different variables
can be executed concurrently. The only possible form of interference is via
the n&rsquo;s, but with respect to these, our programs have a very special property.
If &mdash;sequentially interpreted&mdash; the one alternative is selected while the
other guard is true, the other guard remains true. And that, of course, 
implies that we can implement the whole game as two cyclic processes which may
be detained during their stream-operations when the environment is not ready
and must be detained when the guard is found to be false. (End of remark 3.)
<br><b>Remark 4</b>. These programs have an even stronger property, but it seems too
special perhaps, to make much use of it here: the execution of one alternative
is <b>guaranteed</b> to make the other guard true. This means that the one process
evaluating (n1- n2)<b>mod</b> K need not even read either the old or the new value
of an n with which the other process fools: the evaluation of the guard may
be supplied with a rubbish value, a mixture: the only result can be that
erroneously the value &ldquo;false&rdquo; is evaluated, but then we can say &ldquo;better luck
next time&rdquo;. In this special case we don&rsquo;t even need the mutual exclusion
usually provided by a switch. The remark is of significance if we wish to
abolish daemons that cater for mutual exclusion in unsynchronized 
self-stabilizing systems, I think we can drop it here.(End of remark 4.)
<p><b>Experiments with a sorting elephant</b>.
<p>We consider a long string of mosquitos with between each pair of neighbours
a connection L for traffic to the left and a connection R for traffic to
the right. The terminology is at first sight perhaps confusing, because now
each mosquito has two legs, both called L, but it will turn out to be 
convenient: in mosquito nr. i
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
      L:=....  means sending to nr. i-1       </td> </tr> <tr> <td></td> <td>
      ....:= L means accepting from nr. i+1   </td> </tr> <tr> <td></td> <td>
      R:=....  means sending to nr. i+1       </td> </tr> <tr> <td></td> <td>
      ....:= R means accepting from nr. i-1 . </td> </tr>
</table>
<p>Our simplest elephant consists of as many (plus 1 or 2) mosquitos as
numbers have to be sorted. We distinguish even and odd mosquitos alternating
in the string and do not bother about the fact that the terminal mosquitos have
to be slightly different, nor do we bother for the time being about termination.
<p>Initially the even mosquitos contain two numbers, while the odd mosquitos
start empty. The even mosquito sorts its contents, sends the smalles value
to the left, the largest to the right and then waits (empty) until it has
received from both its neighbours a number back and repetatur. The odd mosquito
waits until it has received a number from both sides, sorts them and send the
smallest to the left and the largest to the right and repetatur.
<p>Let each even mosquito have two variables x and y (for the communication
with its lefthand and righthand neighbour respectively). Its repertoire of
actions consists of
<table width=100%><tr><td valign=top width=10%>
A:</td><td><b>do</b> x &gt; y &rarr; x, y:= y, x <b>od</b> (sorting)
</td></tr>
<tr><td valign=top>
B:</td><td>L:= x                     (sending to the left)
</td></tr>
<tr><td valign=top>
C:</td><td>x:= R                     (receiving from the left)
</td></tr>
<tr><td valign=top>
D:</td><td>R:y                       (sending to the right)
</td></tr>
<tr><td valign=top>
E:</td><td>y:= L                     (receiving from the right)
</td>  </tr>  </table>
<p>The logically necessary precedence relations can be pictured in the
following graph
<pre>
                  <sub>/</sub>&rarr; B -&rarr; C<sub>\</sub>
        entry -&rarr; A          &rarr;A   etc.
                  <sup>\</sup>&rarr; D -&rarr; E<sup>/ </sup>
</pre>
and the question is, how to represent them. One way of doing this is with
a boolean for each arrow:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      ca:= true; ea:= true; ab:= false; bc:= false; ad:= false; de:= false;             </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>do</b> ca <b>and</b> ea &rarr; A; ca:= false; ea:= false; ab:= true; ad:= true </td> </tr> <tr> <td></td> <td>&nbsp; </td> <td>
       &#x25af; ab &rarr; B; ab:= false; bc:= true                                      </td> </tr> <tr> <td></td> <td></td> <td>
       &#x25af; be &rarr; C; bc:= false; ca:= true                                      </td> </tr> <tr> <td></td> <td></td> <td>
       &#x25af; ad &rarr; D; ad:= false; de:= true                                      </td> </tr> <tr> <td></td> <td></td> <td>
       &#x25af; de &rarr; E; de:= false; ea:= true                                      </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>od</b> .                                                                       </td> </tr>
</table>
But, although perfectly general, this notation does not attract me very
much: it is worse than jumps. Another experiment has been (with &ldquo;<b>dop</b>&rdquo; for
&ldquo;do permanently&rdquo;) 
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td>
                           <b>dop</b> A; <b>par</b> [B]; [E]       </td> </tr> <tr> <td></td> <td>
                           &#x25af; [D]: [E] <b>rap</b> <b>pod</b> </td> </tr>
</table>
where the squate brackets denote the unit of interleaving, and the <b>par</b> - <b>rap</b>
are a sort of <b>parbegin</b> and <b>parend</b>. But this turned out to be a dead alley.
(As we shall see shortly, it is awkward for the description of the odd 
mosquitos.)
<p>I am now mostly attracted &mdash;perhaps because it is so new, that I have
not seen its shortcomings yet&mdash; by the following notation
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      <b>dop</b> ![A]; [B]; [C] </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; </td> <td>
        &#x25af; ![A]; [D]; [E] </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>pod</b>                </td> </tr>
</table>
where we have two cyclic processes, and the exclamation mark indicates
&ldquo;mutual coincidence&rdquo;, i.e. the two loops must &ldquo;share&rdquo; the single point event
A each time, The odd mosquitos can be described similarly: each odd mosquito
has two variables u and v , its repertoir consists of
<table width=100%><tr><td valign=top width=10%>
F:</td><td><b>do</b> u &gt; v &rarr; u, v := v, u <b>od</b>
</td></tr>
<tr><td valign=top>
G:</td><td>L:= u
</td></tr>
<tr><td valign=top>
H:</td><td>u:= R
</td></tr>
<tr><td valign=top>
J:</td><td>R:= v
</td></tr>
<tr><td valign=top>
K:</td><td>v:= L
</td>  </tr>  </table>
and its program is 
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
                   <b>dop</b> [H]; ![F]; [G] </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; </td> <td>
                     &#x25af; [K]; ![F]; [J] </td> </tr> <tr> <td></td> <td colspan = 2>
                   <b>pod</b> .              </td> </tr>
</table>
<p>The charm of the above notation is that we can now combine an even
mosquito with its righthand neighbour into a single one, by eliminating the
internal traffic, by identifying H(u:= R) and D(R:= y) with
<table width=100%><tr><td valign=top width=10%>
IR:</td><td>u:= y    (&ldquo;IR&rdquo; for Internal to the Right)
</td>  </tr>  </table>
and by identifying E(y:= L) and G(L:= u) with
<table width=100%><tr><td valign=top width=10%>
IL:</td><td>y:= u
</td>  </tr>  </table>
and the formal combination becomes the following program
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      <b>dop</b> ![A]; [B]; [C]    </td> </tr> <tr> <td></td> <td>&nbsp; </td> <td>
       &#x25af; ![A]; ![IR]; ![IL] </td> </tr> <tr> <td></td> <td></td> <td>
       &#x25af; ![IR]; ![F]; ![IL] </td> </tr> <tr> <td></td> <td></td> <td>
       &#x25af; [K]; ![F]; [J]     </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>pod</b>                   </td> </tr>
</table>
<p>The next observation is that without any change in its semantics, the
middle two lines can be combined:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      <b>dop</b> ![A]; [B]; [C]        </td> </tr> <tr> <td></td> <td>&nbsp; </td> <td>
       &#x25af; ![A]; [IR]; ![F]; [IL] </td> </tr> <tr> <td></td> <td></td> <td>
       &#x25af; [K]; ![F]; [J]         </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>pod</b>                       </td> </tr>
</table>
<p class="noindent">The last observation is that, now the alternation of A and F has been
nicely expressed by the middle line, that u and y can be the same
variable, and that IR and IL disappear, i.e. with
<table width=100%><tr><td valign=top width=10%>
A:</td><td><b>do</b> x &gt; y &rarr; x, y := y, x <b>od</b>
</td></tr>
<tr><td valign=top>
F:</td><td><b>do</b> y &gt; v &rarr; y, v := v, y <b>od</b>
</td>  </tr>  </table>
the combined mosquito becomes, when all is filled in
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      <b>dop</b> ![A]; [L:= x]; [x:= R] </td> </tr> <tr> <td></td> <td>&nbsp; </td> <td>
       &#x25af; ![A]; ![F];             </td> </tr> <tr> <td></td> <td></td> <td>
       &#x25af; [v:= L]; ![F]; [R:= v]  </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>pod</b>                        </td> </tr>
</table>
The above nicely describes the endless graph with the precedence relations
<pre>
      A<sub>\</sub>-> B -> C -><sub>/</sub>A<sub>\</sub>-> B -> C -><sub>/</sub>  
        -&rarr;   -----&rarr;   -&rarr;   ------&rarr;            etc.
      K -><sup>\</sup>F<sup>/</sup>-> J -> K -><sup>\</sup>F<sup>/</sup>-> J ->    
</pre>
<p class="noindent">Merging two successive mosquitos of the above type leads to
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      <b>dop</b> ![A]; [L:= x]; [x:= R]                      </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; </td> <td>
        &#x25af; ![A]; ![F]                                  </td> </tr> <tr> <td></td> <td></td> <td>
        &#x25af; ![A&rsquo;]: ![F]                           </td> </tr> <tr> <td></td> <td></td> <td>
        &#x25af; ![A&rsquo;]; ![F&rsquo;]                    </td> </tr> <tr> <td></td> <td></td> <td>
        &#x25af; [v&rsquo;:= L]; ![F&rsquo;]; [R:= v&rsquo;] </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>pod</b>                                             </td> </tr>
</table>
Here the primed items refer to the righthand side component. Drawing the
beginning of the endless graph with the precedence relations, as I did for
the previous mosquito, is an exercise that I leave to my readers. It is quite
instructive and gives some idea of the power of this notation. (That very power
may also be its greatest weakness, but that is another story.)
<p><b>Again a buffering mosquito</b>.
<p>The following mosquito describes a buffer with a maximum capacity of
<table> <tr> <td colspan = 3>
three values in our new notation:             </td> </tr> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      <b>dop</b> ![a:= L]; ![b:= L]; ![C:= L] </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; </td> <td>
        &#x25af; ![a:= L]: ![L:= a]           </td> </tr> <tr> <td></td> <td></td> <td>
        &#x25af; ![b:= L]; ![L:= b]           </td> </tr> <tr> <td></td> <td></td> <td>
        &#x25af; ![c:= L]; ![L:= c]           </td> </tr> <tr> <td></td> <td></td> <td>
        &#x25af; ![L:= a]; ![L:= b]; ![L:= c] </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>pod</b>                              </td> </tr>
</table>
<p>Here I am, playing with a new toy! The top line expresses that the local
variables are filled cyclically in the order (a, b, c), the bottom line 
expresses that they are emptied in the same cyclic order. The second line 
expresses that with regard to the local variable a filling and emptying 
alternate (so that everything going in goes out again), the next lines 
express the same relation for b and c .
<p class="noindent"><b>Remark</b>. In the above description I have allowed myself a sloppy thing: after
the exclamation marks I have written down the statements themselves, instead
of their names. We could require in several lines the coincidence of ![S1]
and the coincidence of ![S2] , while elsewhere it is defined that both S1
and S2 are, For instance, &ldquo;skip&rdquo;. (End of remark.)
<p>Although I think the above mosquito intriguing, I should not close my
eyes to the fact that I currently don&rsquo;t see, how to derive from the above
a buffering mosquito in the style of EWD476-4 (above). If this inability is not
overcome in an acceptable manner, that fact may point to an, as yet unfathomed,
weakness of the notation. I hope that time will show, either in one way, or
in the other.
<p><b>Multiple coincidence</b>.
<p>It seems unnatural to restrict coincidence to two occurrences, more 
precisely, to the occurences in just two cyclic processes. In the elephant for
the hyper-fast Fourier transform, with the so-called &ldquo;perfect shuffle&rdquo;,
each mosquito starts broadcasting its contents z via the legs 01 and 02
to two different mosquitos, simultaneously waiting to receive via I1 and I2
to values from two different mosquitos, accepting these values in the local
variables x and y. After all this information exchange, it performs basically
F:   z:=f(x, y). This would lead to the structure
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      <b>dop</b> [O1:= z]; ![F] </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; </td> <td>
        &#x25af; [O2:= z]; ![F] </td> </tr> <tr> <td></td> <td></td> <td>
        &#x25af; [x:= I1]; ![F] </td> </tr> <tr> <td></td> <td></td> <td>
        &#x25af; [y:= 12]; ![F] </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>pod</b>   .            </td> </tr>
</table>
<p>It seems unattractive to reduce the number of four cyclic processes to
two by imposing more stringent sequencing constraints upon the contacts with
the mosquito&rsquo;s outer world. First of all we must be careful not to introduce
global deadlocks, such as would be caused by
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      <b>dop</b> [O1:= z]; [x:= I1]; ![F] </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; </td> <td>
        &#x25af; [U2:= z]; [y:= I2]; ![F] </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>pod</b>                          </td> </tr>
</table>
as this would start all mosquitos sending and none in the mood to receive.
Secondly, we would like all mosquitos to be of identical structure, and
for two of the mosquitos one of their own output legs is connected to one
of their own input legs. Obviously I do not care too much about the analysis
which sequencing constraints to be imposed upon the external contacts are
still admissible. Thirdly, it would reduce the traffic density between the
mosquitos, so time-wise it is not attractive either. Perhaps it would be
wise to indicate at the exclamation marks the multiplicity of coincidence.
The synchronization structure of the mosquitos of the hyper-fast Fourier
transformer is mentioned here as a recording of the issues involved in 
elephant construction.
<p><b>Things to be done sooner or later</b>.
<br>1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instead of falling in love with my new notation, I should continue the
investigation of alternatives.
<br>2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The current notation has to be extended so as to include a termination
criterion as well.
<br>3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It should be investigated whether the current notation should be 
extended so as to include other reasons for delay besides (internal or external)
coincidences. I would feel safer about it, if I could find an argument that
this extension is not necessary, for that would do away with the analysis of
obligations for waking up.(Is it, therefore, too much to hope for?)
<br>4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I have not given yet a formal definition of the semantics of a single
mosquito. Only thereafter can I hope to derive theorems about merging several
mosquitos into a single one.
<br>5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It should be tried on some standard exercises, such as The Dining
Philosophers, and perhaps also on the Readers and the Writers.
<br>6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;It should be discovered, whether proving something about an elephant
is more conveniently done by merging its mosquitos into a single giant
mosquito &mdash;which is equivalent to the elephant&mdash; or, whether we prove
our assertions about the elephant in two steps: first proving everything
about the individual mosquito&rsquo;s, regarded in isolation, and then, knowing
the relevant properties of the nodes, our assertions about the whole network.
Intuitively I prefer the second approach, but I must admit that it is rather
unclear to me, how such prrofs should look like. The article by W.H.Burge
&ldquo;Stream Processing Functions&rdquo; (IBM J.Res.Develop., Vol.19, No. 1, pp 12 - 25)
as yet does not strike me as very helpful.
<br>7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;How to design elephants.
<br>8)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;etc.
<p>It is nearly three weeks ago, since I started on this preliminary 
investigation and it seems that the time has come to sollicit comments.
<p class="noindent">
<table width=100%><tr><td valign=top width=30%>
5th March 1975</td><td>prof.dr.Edsger W.Dijkstra
</td></tr>
<tr><td valign=top>
Plataanstraat 5</td><td>Burroughs Research Fellow
</td></tr>
<tr><td valign=top>
NUENEN - 4565</td><td>
</td></tr>
<tr><td valign=top>
The Netherlands</td><td>
</td>  </tr>  </table>

<hr />
   <p class="noindent"><font size="-1">Transcribed by Martin P.M. van der Burgt<br />
    Last revision
    <csobj format="MedDate" h="13" region="15" t="DateTime" w="90">
      <!-- #BeginDate format:IS1 -->2014-12-08<!-- #EndDate -->
    </csobj>
  .</font></p>
  <p>&nbsp;</p>
</body></html></div>
  </body>
  </html>
