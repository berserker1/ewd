<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"><html>	<head>		<meta http-equiv="content-type" content="text/html;charset=ISO-8859-1">		<meta name="generator" content="Adobe GoLive 6">		<title>E.W.Dijkstra Archive: An Experiment with the &quot;record class&quot; as suggested by C.A.R.Hoare (EWD 132)</title>		<link href="../transcriptions.css" rel="stylesheet" media="screen">	</head>	<body bgcolor="#ffffff">	   <div id="frame">			<div id="header">        <a href="../../ewd01xx/EWD132.PDF"            title="Link to the PDF version of EWD 132">EWD 132</a>      </div>			<div id="content">				<div align="left">					<p class="noindent"><u>An Experiment with the &quot;record class&quot; as suggested by C.A.R.Hoare</u></p>					<p>The primary purpose of this experiment has been to try out the usefulness of the concept of the &quot;record class&quot; as suggested by C.A.R.Hoare. I have selected the algorithm to find the shortest route from one town to another via a map if only the direct town to town connections of this map are given.</p>					<p>Seven years ago I coded this in machine code and at that time it was one of the toughest programming jobs I had ever done. To say that, compared with this early effort, Hoare's record class allows a tremendous simplification in the formulation of the algorithm is of course a next to empty statement. But I invite anybody who is interested in the adequateness of the &quot;record class&quot; as a tool and has grasped the algorithm, to rewrite this program in ALGOL 60 as it stands. Let <u>him</u> embellish his program as much as he likes in the name of <u>his</u> standard of clarity and elegance (for so did I with mine!) and let him then compare them. I am so much convinced that the comparison will turn out in favour of the program making use of the record classes, that I am beginning to ask myself whether I have selected the one problem to the needs of which to the record classes are really tailored.....</p>					<p>The secondary purpose of this experiment has been to show what beauty can be achieved (and at what price) if one refuses to make use of goto statements. In this example I have used the simple while clause without controlled variables (to make legal ALGOL 60 of it, one could insert &quot;<code><u>for</u> dummy:= 0</code>&quot; in front of every occurrence of the character &quot;<u><code>while</code></u>&quot;.) The preceding version of this program contains nine labels and nine goto statements and was accordingly messy.</p>					<p>Now some explication. The linking by the field &quot;<code>fol</code>&quot; serves a dual purpose. It connects all towns in a single chain; from &quot;<code>start</code>&quot; to &quot;<code>last placed</code>&quot; it contains the towns for which the path of minimum length from &quot;<code>start</code>&quot; has been established and it does so in the order of increasing path length (which is also the order in which the towns are attached to this part of the chain in time), from &quot;<code>last placed</code>&quot; to &quot;<code>end</code>&quot; it contains, in irrelevant order, all towns with at least one direct connection to a town in the range from and including &quot;<code>start</code>&quot; up till and including &quot;<code>last placed</code>&quot;. For all towns in this chain we keep track of the minimum distance from &quot;<code>start</code>&quot; found thus far and the field &quot;<code>previous</code>&quot; indicates the town, via which this minimal path finally leads to it. For each town, added to the first part of the chain, we make the second part of the chain up to date by inspecting all the roads leading out from it; after that we select from the second part of the chain the town with minimum distance found thus far and this is the next town to be transferred to the first part. As soon as &quot;<code>finish</code>&quot; has been transferred to the first part of the chain, the problem of the minimum path from &quot;<code>start</code>&quot; to &quot;<code>finish</code>&quot; has been solved.</p>					<p>The topology of the map is given as follows. The roads leading from a town are arbitrarily ordered, the source town contains a reference to the first road leading out of it, each road contains a reference to the next road, leading out of the same source town, if such a road is present, otherwise the field of such a road reference will contain &quot;<u><code>null</code></u>&quot;. (Roads are on this map directed connections, {....} have towns without roads leading out of it, the dead alley.)</p>					<p>The algorithm may end in two ways: either it finds the connection (<code>last placed =</code> <code>finish</code>) or it decides that the map does not provide for a connection from &quot;<code>start</code>&quot; to &quot;<code>finish</code>&quot;. This is decided to be the case when the second part of the chain (from and excluding &quot;<code>last placed</code>&quot; up to and including &quot;<code>end</code>&quot;) is empty at the moment, that a town from the second part has to be transferred to the first part; it causes this outcome by &quot;<code>last placed&quot; = <u>null</u></code>&quot;.</p>					<p>Now some comments on the structure of the program. The outermost while clause (&quot;<code><u>while</u> last placed &#x2260; finish <u>and</u> last placed &#x2260; <u>null</u></code>&quot;) controls the repetition of the statement in which</p>					<p>1) the second part of the chain is made up to date as result of a newly placed town (i.e. just transferred to the first part of the chain);</p>					<p>2) from the updated second part a new town is selected and transferred to the first part (provided the second part is not empty, for them the algorithm ends with &quot;<code>last placed = <u>null</u></code>)</p>					<p>The while clause (&quot;<code><u>while</u> trial &#x2260; <u>null</u></code><u>&quot;</u>) controls the repetition of the statement in which the updating consequences of the road &quot;<code>trial</code>&quot;, emanating from &quot;<code>last placed</code>&quot; are performed and the next road emanating is made the next trial.</p>					<p>The while clause &quot;<code><u>while</u> scanned &#x2260; goal <u>do</u></code>&quot; investigates whether<code> goal = destination(trial)</code> (i.e. the town, to which &quot;<code>trial</code>&quot; leads) occurs already in the chain; if not, it is quickly added, so that the next time it does belong to the chain and the while clause is terminated. This (and the preliminary distance &quot;<code>+ infinity</code>&quot;) is one of of the extra prices to be paid for the absence of goto statements. At first sight it is a trick, but after some consideration it becomes such a neat one, so perfectly sound, that it may develop into a method.</p>					<p>The conditional resetting of the distance is by necessity non-active if &quot;<code>goal</code>&quot; was already in the first part of the chain, on account of &quot;<code>+ infinity</code>&quot; active if &quot;<code>goal</code>&quot; has just been added to the chain.</p>					<p>When the second part of the chain has been updated, the new town must be selected. If the second part of the chain is non-empty, &quot;<code>premin</code>&quot; is made to point to the predecessor of the selected town. This is done in the while clause &quot;<code><u>while</u> prescanned &#x2260; end <u>do</u></code>&quot;. Then the selected town is placed at the beginning of the second part (unless it is already there) and finally last placed is moved over one town.</p>					<p>Note. I am aware that the algorithm could be speeded up at the price of more fields in the town records.</p>					<pre><code><u>record class</u> town;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>reference</u> first out(road), fol, previous(town); <u>integer</u> distance <u>end</u>;<u>record class</u> road;  <u>begin</u> <u>reference</u> destination(town), next out(road); <u>integer</u> length <u>end</u>;</code></pre>					<pre><code><u>reference</u> start, finish, scanned, prescanned, last placed, goal, premin, end(town),           trial(road)</code></pre>					<p class="noindent">&quot;Now the data must be given. Of the records &quot;<code>town</code>&quot; the field &quot;<code>first out</code>&quot; must be defined (may be = <u><code>null</code></u>), the fields of the records &quot;<code>road</code>&quot; must all be defined. &quot;<code>start</code>&quot; and &quot;<code>finish</code>&quot; (both &#x2260; <u><code>null</code></u>) must be given.&quot;</p>					<pre><code>end:= last placed:= start; fol(start):= previous(start):= <u>null</u>;distance(start):= 0;<u>while</u> last placed &#x2260; finish <u>and</u> last placed &#x2260; <u>null</u> <u>do</u><u>begin</u> trial:= first out(last placed);      <u>while</u> trial &#x2260; <u>null</u> <u>do</u>      <u>begin</u> goal := destination(trial); scanned:= start;            <u>while</u> scanned &#x2260; goal <u>do</u>            <u>begin</u> <u>if</u> scanned = end <u>then</u>                  <u>begin</u> fol(end):= goal; end:= goal; fol(goal):= <u>null</u>;                        distance(goal):= + infinity                  <u>end</u>;                  scanned:= fol(scanned)            <u>end</u>;            <u>if</u> distance(last placed) + length(trial) &lt; distance(goal) <u>then</u>            <u>begin</u> distance(goal):= distance(last placed) + length(trial);                  previous(goal):= last placed            <u>end</u>;            trial:= next out(trial)      <u>end</u>;      <u>if</u> last placed = end <u>then</u>               last placed := <u>null</u>                           <u>else</u>      <u>begin</u> premin:= last placed; prescanned:= fol(last placed);            <u>while</u> prescanned &#x2260; end <u>do</u>            <u>begin</u> <u>if</u> distance(fol(prescanned)) &lt; distance(fol(premin)) <u>then</u>                                          premin:= prescanned;                  prescanned:= fol(prescanned)            end;            <u>if</u> premin &#x2260; last placed <u>then</u>            <u>begin</u> scanned:= fol(premin);                  fol(premin):= fol(scanned);                  fol(scanned):= fol(last placed);                  fol(last placed):= scanned            <u>end</u>;            last placed:= fol(last placed)      <u>end</u><u>end</u></code></pre>					<p></p>				</div>				<hr>				<font size="-1">transcribed by Tristram Brelstaff<br>					revised <csobj format="MedDate" h="16" region="15" t="DateTime" w="95">Sun, 5 Jul 2009</csobj></font>																					</body></html>