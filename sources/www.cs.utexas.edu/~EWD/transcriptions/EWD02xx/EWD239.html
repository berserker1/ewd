<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
	<head>
		<title>E.W.Dijkstra Archive: On trading storage against computation time (EWD 239)</title>
    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1" />
		<link href="../transcriptions.css" rel="stylesheet" media="screen" />
		<style type="text/css"> .nowrap { white-space: nowrap; } </style>
	</head>
	<body>
		<div id="frame">
			<table width="100%" cellpadding="0" cellspacing="0" border="0">
				<tr>
					<td align="right"><a href="../../ewd02xx/EWD239.PDF"
					 title="Link to the PDF version of EWD239">EWD 239</a></td>
				</tr>
			</table>
			<div id="content">
				<p class="noindent"><u>On trading storage against computation time.</u></p>
				<p>In present day sequential computers we can distinguish two main components, an active one (the processor) and a passive one (the store). The active component has the specific function to be fast, the passive one has the specific function to be large. The following is written under the assumption that this functional division is here to stay. (Personally I feel that it is this functional division thanks to which the reliable construction of both large and fast computers has become possible.)</p>
				<p>From the point of view of the programmer storage space and computation time are two distinct resources and I regard it as one of the responsibilities of the programmer &mdash;rather than of the system&mdash; to allocate them, i.e. to divide the load between them. It is to the consequences of this responsibility that the present report is devoted. The report is not devoted to techniques needed to estimate the various loads, i.e. to give quantitative criteria to influence the programmer's choice. It is devoted to the logical relation between the alternatives among which the programmer has the choice.</p>
				<p>I claim that the basic relation between two alternatives is given by the following pattern.</p>
				<p>Given a program asking regularly for the value <var>FUN</var>(<var>arg</var>) where <var>FUN</var> is a given function defined on the current value of one or more variables of the state space called (together) <var>arg</var>.</p>
				<p>In version <var>A</var>, only the current value of <var>arg</var> is stored and the value <var>FUN</var>(<var>arg</var>) is computed whenever needed.</p>
				<p>In version <var>B</var>, an additional variable <var>fun</var> say, is introduced, whose sole purpose is to record the value <var>FUN</var>(<var>arg</var>) for the current value of arg.</p>
				<p>Where version <var>A</var> has<br />
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <var>arg</var>:=....... (i.e. assignment to <var>arg</var>)<br />
					version <var>B</var> will have<br />
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <var>arg</var>:=.......; <var>fun</var>:= <var>FUN</var>(<var>arg</var>)<br />
					thereby maintaining the relation<br />
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <var>fun</var> = <var>FUN</var>(<var>arg</var><br />
					Where version <var>A</var> calls for <var>FUN</var>(<var>arg</var>), version <var>B</var> will call for the current value of <var>fun</var>.</p>
				<p>There are two possible reasons to prefer version <var>B</var> above version <var>A</var>.<br />
					1) &nbsp; When the value of <var>FUN</var>(<var>arg</var>) is more frequently requested than assignments to <var>arg</var> take place, version <var>B</var> requires less frequent computation time. (If necessary, the technique can be refined by the introduction of a boolean <var>fun up to date</var> indicating whether <var>fun</var>&nbsp;=&nbsp;<var>FUN</var>(<var>arg</var>) holds. Assignment to <var>arg</var> is then<br />
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <var>arg</var>:=.......; <var>fun up to date</var>:= <b>false</b> ;<br />
					in this way one can suppress superfluous computation of <var>FUN</var>(<var>arg</var>) as might be generated by version <var>B</var>.)<br />
					2) &nbsp; Often it is difficult to compute <var>FUN</var>(<var>arg</var>) from scratch for arbitrary values of <var>arg</var>, but is it much easier to compute the <em>change</em> of <var>FUN</var>(<var>arg</var>) on account of the <em>change</em> of <var>arg</var>. (Often this consideration will be the very body of the algorithm, e.g. when <var>FUN</var> is defined in terms of a recurrence relation; see the last example of <a href="EWD238.html">EWD238</a>, where <var>j</var> has to be taken as one of the arguments.)</p>
				<p>We shall now turn to an example with which we have played extensively. Consider 32 positions arranged in a circle. Please make a program generating all ways in which they can be filled with 0's and 1's (one digit per position) such that the 32 quintuples of adjoining positions present the 32 possible configurations of five binary digits. Solutions that can be mapped on each other by rotation will be regarded as equivalent, the solutions are to be given as strings of 32 digits with five zeros leading and they have to be generated in alphabetical order.</p>
				<p>C.Ligtmans has shown that this cyclic problem is equivalent to the following linear one. Fill a linear array of 36 positions with 0's and 1's (one digit per position) such that the 32 quintuples of adjoining positions present the 32 configurations of five binary digits. (When the linear array contains a solution the sequence formed by the first four digits will be equal to the sequence formed by the last four digits and as a result "the ring will close".) We shall tackle the linear problem.</p>
				<p>We introduce a structured variable called <var>sequence</var> consisting of four zeros followed by <var>k</var> binary digits. When <var>k</var>=0 we call the sequence empty, when <var>k</var>=32 we call the sequence full; <var>k</var> equals the number of ways in which a quintuple of five adjoining positions can be chosen in the sequence.</p>
				<p>Furthermore we introduce a binary variable, called <var>candidate</var>, representing the value by which the algorithm seeks to extend the sequence. The operation inverse to "extend sequence with candidate" is "take candidate from sequence", by which the last digit is taken away from the sequence and is assigned to the candidate.</p>
				<p>The algorithm maintains the sequence in such a way that the sequence will never contain two different quintuples presenting the same pattern of five digits. The question "sequence extendable with candidate" asks whether extension would not give rise to a sequence violating the condition of different digit patterns. We can make the following two remarks<br />
					1) &nbsp; As <var>k</var> equals the number of quintuples, as all quintuples on the sequence must present different digit patterns and the number of different digit patterns equals 32, <var>k</var> will satisfy <span class="nowrap"><var>k</var> &#x2264; 32.</span><br />
					2) &nbsp; Whenever <var>k</var>=32 the sequence presents a solution on the linear problem and on account of the equivalence established by Ligtmans the 32 leading digits of the sequence present a solution of the circular problem.</p>
				<p>We now give the structure of the backtracking algorithm that prints the solutions in alphabetical order</p>
				<a name="first_version"></a>
				<table cellpadding="0" cellspacing="0" border="0" style="margin-left: 1em;">
					<tr>
					  <td colspan="2">set <var>sequence</var> empty; set <var>candidate</var> to zero;</td></tr>
					<tr><td colspan="2"><b>repeat</b></td></tr>
					<tr><td            ><span class="nowrap">&nbsp; &nbsp; &nbsp; &nbsp; <b>if</b> <var>sequence</var> extendable with <var>candidate</var>&nbsp;</span></td><td width="55%"><b>then</b></td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>begin</b> extend <var>sequence</var> with <var>candidate</var>; set <var>candidate</var> to zero;</td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>if</b> <var>sequence</var> full <b>do</b> print solution</td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>end</b></td></tr>
					<tr><td></td>   <td><b>else</b></td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>begin</b> <b>while</b> <var>candidate</var> set to one <b>do</b> take <var>candidate</var> from <var>sequence</var></td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set <var>candidate</var> to one</td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>end</b></td></tr>
					<tr>
				  <td colspan="2"><b>until</b> sequence empty</td></tr>
				</table>
				<p>The above has been described as "the structure" of an algorithm. Can we regard it as "an algorithm"? I think we can.</p>
				<p>The nine statements ("set sequence empty"; "set candidate to zero" etc.) have to be regarded as names of instructions of the well-understood repertoire (the primitive repertoire), <var>candidate</var> and <var>sequence</var> have to be understood as coordinates of the state space.</p>
				<p>What do we have to assume (or: to define?) about the operations and the objects in order that this program makes sense? (I apologize for this probably impure question, for what is "making sense"? Nevertheless, I go on.)</p>
				<p>Candidate is a two state object (the states being called <var>zero</var> and <var>one</var> respectively), these states can be set and inspected.</p>
				<p>Sequence is a finite state object. A unique state of this object is called "empty". (Otherwise "set <var>sequence</var> empty" would be indeterminate.)</p>
				<p>On a value pair <var>sequence</var>-<var>candidate</var> a boolean function "<var>sequence</var> extendable with <var>candidate</var>" is defined; if this function is true, the operand "extend <var>sequence</var> with <var>candidate</var>" is defined, giving a new sequence, and "take <var>candidate</var> from <var>sequence</var>" is then the inverse operator.</p>
				<p>There is a boolean function <var>full</var> defined on the object sequence; its value on the empty sequence is irrelevant.</p>
				<p>The object values that can be made by further extension of the empty sequence extended with a zero are scanned, whenever a value satisfying the criterion <var>full</var> is met (a function of) it is printed.</p>
				<p>We can regard a set of properties as the above &mdash;when more carefully defined&mdash; as a set of axioms on objects and operations and on this level they must be sufficient to understand this program, to prove that it ends, that it produces all values satisfying <var>full</var> and all only once etc. On this same level we can make more algorithms, in this sense we have "a real machine"! E.g.</p>
				<table cellpadding="0" cellspacing="0" border="0" style="margin-top: 0.5em; margin-left: 1em;">
					<tr><td colspan="2">Set <var>sequence</var> empty; set <var>candidate</var> to zero;</td></tr>
					<tr>
				  <td colspan="2"><b>if</b> <var>sequence</var> <span class="nowrap"></span>extendable with <var>candidate</var> <b>do</b></td></tr>
					<tr><td colspan="2"><b>begin</b> extend <var>sequence</var> with <var>candidate</var>;</td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; <b>repeat</b></td></tr>
					<tr><td            ><span class="nowrap">&nbsp; &nbsp; &nbsp; &nbsp; <b>if</b> <var>sequence</var> extendable with <var>candidate</var>&nbsp;</span></td><td width="55%"><b>then</b></td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>begin</b> extend <var>sequence</var> with <var>candidate</var>; set <var>candidate</var> to zero;</td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>if</b> <var>sequence</var> full <b>do</b> print solution</td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>end</b></td></tr>
					<tr><td            ></td><td><b>else</b></td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>begin</b> <b>while</b> <var>candidate</var> set to one <b>do</b> take <var>candidate</var> from <var>sequence</var>;</td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; take <var>candidate</var> from <var>sequence</var>;</td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>if</b> <b>non</b> <var>sequence</var> empty <b>do</b> extend <var>sequence</var> with <var>candidate</var>;</td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; set <var>candidate</var> to one</td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <b>end</b></td></tr>
					<tr><td colspan="2">&nbsp; &nbsp; &nbsp; &nbsp; <b>until</b> <var>sequence</var> empty</td></tr>
					<tr><td colspan="2"><b>end</b></td></tr>
				</table>

				<p>This program scans the object values that can be made by further extension of the sequence value created by extending the empty sequence twice with a zero. My question is: to what extent can we regard the particular example of the 36 positions as a specific model, a representation? Or: can we regard the above "abstract algorithm" as the abstracted ancestor of a wide class of backtracking algorithms? And, if so, to what use?</p>
				<p>A discussion with J.M.Rutledge, IBM Research (16th July 1968) has convinced me that the version at the bottom of <a href="#first_version">EWD239&ndash;1</a> serves a purpose. Without mentioning the quintuple problem one can prove its correctness, provided<br />
					1) &nbsp; one gives the properties of the operations and functions defined on the objects <var>candidate</var> and <var>sequence</var><br />
					2) &nbsp; one gives a sharp definition of the required behaviour, i.e. the specification. This is very encouraging and this is what I wanted.</p>
				<p>To my regret I have to part from this version, because it will lead me into difficulties that I should like to avoid. Let me sketch them.</p>
				<p>The next step in my process would be the introduction of a canonical state space in terms of which all operations can be specified, particularly the functions <var>full</var> and<var> sequence extendable with candidate</var>. This I can do. To make a more realistic program, I intend to define functions on this canonical state space in order that I can use it to store "current values" as sketched in <a href="#current_values">EWD239&ndash;0</a>.</p>
				<p>Now one or two problems arise. I have to define a function on <var>sequence</var> and <var>candidate</var> and the result is that I should like to introduce "extend <var>sequence</var> with <var>candidate</var> and set <var>candidate</var> to zero", instead of "extend <var>sequence</var> with <var>candidate</var>; set <var>candidate</var> to zero" for, at the separating semicolon the new function is fairly meaningless. Also: in the statements<br />
					&nbsp; &nbsp; &nbsp; &nbsp; "<b>while</b> <var>candidate</var> set to one <b>do</b> take <var>candidate</var> from <var>sequence</var>;<br />
					&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; set <var>candidate</var> to one"<br />
			  we have a similar situation, not so much at the separating semicolon but in the course of the repetition. Some of the new functions are "immaterial for some time" and to impose upon the program the duty to keep these tabulated values up to date on such a microscopic level is irrealistic.</p>
				<p>The next goal therefore is to give more levels, in such a way that functional relationships that we want to introduce are guaranteed to hold at the semicolons of a given level! (This will be the case anyhow: the relations do not hold at the semicolons of the level making the adjustments.)</p>
				<p>Rutledge has made a point: the fact that <var>candidate</var> is a twovalued variable, the <var>sequence</var> has something to do with what they call the free monoid on a binary alphabet can be concluded from the properties stated. Only <var>full</var> and <var>sequence extendable with candidate</var> pin the program down on the quintuple problem. The moral of this remark is that no flexibility is lost when we introduce the free monoid on this level, if it is only to define the desired properties of the operations.</p>
				<p>So here we go again, this time with very cautiously, for the time being not bothering ourselves too much about the relation between successive versions.</p>
				<p>The crudest version is<br />
					<br />
					version 0: &nbsp; &nbsp; &nbsp; &nbsp; "do all work" &nbsp; &nbsp; .</p>
				<p>This, although correct, is hardly helpful, we cannot do much with it either. Then comes<br />
					<br />
					version 1: &nbsp; &nbsp; &nbsp; &nbsp; "generate all solutions"<br />
					<br />
					suggesting that a number (possibly zero) of "solutions" have to be generated. The number must now be finite.<br />
					<br />
					version 2: &nbsp; &nbsp; &nbsp; &nbsp; "generate all solutions in alphabetical order".</p>
				<p>This version tells us more, it tells that the solutions have an ordering that is called alphabetical and that they have to be generated in this order.<br />
					<br />
					version 3: &nbsp; &nbsp; &nbsp; &nbsp; "generate in alphabetical order all bit sequences that are solutions"</p>
				<p>Here we have told much more, we have said that we are looking for bitsequences in terms of which the alphabetical order can be defined. (We can take it for granted that this restricts ourselves implicitly to finite bitsequences.)</p>
				<p>We do not know whether there are solutions at all. We do not know a first solution, also we do not recognize a last solution when we encounter it. The structure at the bottom side of <a href="EWD238.html#version1b">EWD238&ndash;1</a> is therefore unattractive (containing "transform current sequence to next solution").</p>
				<p>We do know, however, a criterion "acceptable" (in our example: containing no quintuples presenting the same pattern) with the following properties<br />
					1) &nbsp; the set of acceptable sequences is not empty and finite<br />
					2) &nbsp; we know a first member of the set<br />
					3) &nbsp; we know a virtual last member of the set (for "virtual" see below)<br />
					4) &nbsp; solutions are all acceptable sequences (excluding the virtual one) satisfying a further criterion <var>full</var><br />
					5) &nbsp; we can transform an acceptable sequence into the next one (next in alphabetic order).</p>
				<p class="noindent">About virtual: if we are looking for the sequences with a zero leading, the virtual last one would be the first acceptable sequence with a one leading. Also, if the first acceptable sequence is the empty sequence, the virtual last one may again be the empty sequence.</p>
				<p>We can now make the following program:<br />
					<br />
					version 4:<br />
					&nbsp; &nbsp; &nbsp; &nbsp; set sequence to first acceptable one;<br />
					&nbsp; &nbsp; &nbsp; &nbsp; <b>repeat if</b> sequence full <b>do</b> print solution;<br />
					&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transform sequence into next acceptable one<br />
					&nbsp; &nbsp; &nbsp; &nbsp; <b>until</b> sequence is (first or) last member</p>
				<p class="noindent">Remark: the first member is not subjected to the final test for the last member, therefore this test needs only to distinguish between the last member and the others, the first one excluded! There is no objection to the first one satisfying the test as well, but also no obligation; therefore "first or" has been put between parentheses.</p>
				<p>We also know about the property "acceptable" that<br />
					6) &nbsp; no extension of a sequence that is not acceptable will be acceptable.</p>
				<a name="section41"></a>
				<p>This property enables us to implement "transform sequence into next acceptable one" &mdash;knowing that its initial value is indeed acceptable&mdash; as follows:<br />
					<br />
					section 4.1: transform sequence into next acceptable one:<br />
					&nbsp; &nbsp; &nbsp; &nbsp; "extend sequence with zero;<br />
					&nbsp; &nbsp; &nbsp; &nbsp; <b>while non</b> acceptable <b>do</b> concrease sequence"</p>
				<p>The effect of the operation <var>concrease</var> is defined in the following way: if the old sequence does not contain a zero the result is the empty sequence, if the old sequence does contain a zero, the result is a copy of the old one up to and excluding the last zero, extended with a one.</p>
				<p>The present state is very encouraging, the important property 6 is only exploited in a next level of detail, it is here that backtracking is described, that the alphabetical order is catered for.<br />
					<br />
					(Few days later.)</p>
				<p>I must apologize, for I am afraid that I have gone too fast. I am going to modify version 4 of the previous page. The fact is that I have not expressed a changed interpretation of the current value of sequence, I have not expressed that the acceptable sequences fall into two different classes, those that are solutions and those that are not. I try to remedy this by a new version 4:</p>
				<a name="setseqto"></a>
				<p class="noindent" style="margin-left: 2em;">
					set sequence to first acceptable one;<br />
					<b>repeat if</b> sequence full <b>do begin</b> accept sequence as solution; print solution <b>end</b>;<br />
					&nbsp; &nbsp; &nbsp; &nbsp; transform sequence into next acceptable one<br />
					<b>until</b> sequence is (first or) last member</p>
				<p>The transition from the old to the new version 4 is not striking, because "accept sequence as solution" is in all probability an empty action. (For the sake of completeness I mention that I have been hesitating between "print solution" and "print sequence"; the statement "accept sequence as solution" implies more or less &mdash;is meant to indicate&mdash; that the two formulations are equivalent.)</p>
				<p>The transition is more marked when I give the new section 4.1 on <a href="#section41">top of this page</a>. In section 4 the sequence is always "acceptable", in section 4.1, where we exploit the important property 6 of "acceptability" we consider for the first time sequences that are not guaranteed acceptable. I call them "doubtful": a sequence is called doubtful when it is a one-digit extension of an acceptable sequence, property 6 tells us that when looking for acceptable sequences, we can confine our attention (the machine&rsquo;s attention!) to doubtful sequences.</p>
				<p>With this definition of doubtful, section 4.1, new version, would be something like</p>
				<p class="noindent" style="margin-left: 2em;">
					transform acceptable sequence into next doubtful one;<br />
					<b>while</b> doubtful sequence <b>non</b> acceptable <b>do</b><br />
					&nbsp; &nbsp; &nbsp; &nbsp; transform doubtful sequence into next doubtful one;<br />
					accept sequence as acceptable</p>
				<p>The purpose of this new version is twofold. On the one hand it expresses that only doubtful sequences are subjected to the test "acceptable", on the other hand it allows us to introduce different representations for doubtful and acceptable sequences. The rules for doubtful sequences hold "at the semicolons" at this level. The first statement makes from an acceptable sequence a doubtful one, the last one makes from a doubtful sequence an acceptable one. This allows us to introduce for acceptable sequences a representation unfit for arbitrary doubtful ones. I shall return to this later.</p>
				<p>Now I think that the time has come (experience makes me expect that I shall regret it within a few pages!) to introduce what I have called "the canonical state space" i.e. the variables that I need to pin the program down on the specific problem, in this case the quintuple problem.</p>
				<p>We introduce the integer <var>k</var>, satisfying 0 &#x2264; <var>k</var> and the array <var>d</var>, to represent the value of</p>
				<p><var>sequence</var>: &nbsp; 0 0 0 0 <var>d</var>[0] ... <var>d</var>[<var>k</var>] &nbsp;&nbsp;&nbsp;.</p>
				<p class="noindent">Putting the zeros also in the array <var>d</var> and using the fact that <var>k</var> will satisfy <var>k</var>&nbsp;&#x2264;&nbsp;32 we can declare<br />
					&nbsp; &nbsp; &nbsp; &nbsp; <b>array</b> <var>d</var>[&ndash;4: 32].</p>
				<p>In terms of these variables we can now give the bodies of the instructions used in the <a href="#setseqto">middle of EWD239&ndash;5</a></p>
				<p class="noindent">set sequence to first acceptable one:<br />
					&nbsp; &nbsp; &nbsp; &nbsp;<var>d</var>[&ndash;4]:= <var>d</var>[&ndash;3]:= <var>d</var>[&ndash;2]:= <var>d</var>[&ndash;1]:= <var>d</var>[0]:= 0; <var>k</var>:= 0</p>
				<p class="noindent">sequence full:<br />
					&nbsp; &nbsp; &nbsp; &nbsp;<var>k</var> = 31</p>
				<p class="noindent">accept sequence as solution:<br />
					&nbsp; &nbsp; &nbsp; &nbsp; " " (i.e. empty statement)</p>
				<p class="noindent">print solution:<br />
					&nbsp; &nbsp; &nbsp; &nbsp; "print the 32 leading elements of the array <var>d</var>" (I refuse to go into more detail)</p>
				<p class="noindent">transform sequence into next acceptable one, see below</p>
				<p class="noindent">sequence is (first or) last member:<br />
					&nbsp; &nbsp; &nbsp; &nbsp;<var>d</var>[0] = 1 (only satisfied by the last member) or<br />
					&nbsp; &nbsp; &nbsp; &nbsp;<var>k</var> = 0 (satisfied by first and last member).</p>
				<p>For "transform sequence into next acceptable one" we have a more detailed version on the bottom of page <a href="#setseqto">EWD239&ndash;5</a>, in which the criterion "acceptable" is mentioned. In order to define it, we define upon the sequence <var>k</var>+1 function values<br />
					&nbsp; &nbsp; &nbsp; &nbsp; <var>h</var>(<var>i</var>) ="binary value of bit sequence <var>d</var>[<var>i</var>&ndash;4]...<var>d</var>[<var>i</var>]" for 0 &#x2264; <var>i</var> &#x2264; <var>k</var><br />
					and a sequence is called "acceptable" if all the <var>k</var>+1 values <var>h</var>(<var>i</var>) are different (this expresses the requirement that no two different quintuples present the same bit pattern).</p>
				<p>At the semicolon of the detailing of "transform sequence into next acceptable one" the sequence is called "doubtful", i.e. a one digit extension of an acceptable sequence. As only doubtful sequences are subjected to the test acceptable it is sufficient to compare <var>h</var>(<var>k</var>) with <var>h</var>(<var>i</var>) for <var>i</var>&lt;<var>k.</var></p>
				<p>The next step in detailing now gives:<br />
					<br />
					transform acceptable sequence into next doubtful one:<br />
					&nbsp; &nbsp; &nbsp; &nbsp;<var>k</var>:= <var>k</var> + 1; <var>d</var>[<var>k</var>]:= 0<br />
					<br />
					doubtful sequence <b>non</b> acceptable:<br />
					&nbsp; &nbsp; &nbsp; &nbsp; for all <var>i</var>, 0 &lt; <var>i</var> &lt; <var>k</var> holds: <var>h</var>(<var>i</var>) &#x2260; <var>h</var>(<var>k</var>)<br />
					<br />
					transform doubtful sequence into next doubtful one:<br />
					&nbsp; &nbsp; &nbsp; &nbsp;<b>while</b> <var>d</var>[<var>k</var>] = 1 <b>do</b> <var>k</var>:= <var>k</var> &ndash; 1; <var>d</var>[<var>k</var>]:= 1<br />
					(as a result of first and last member, the minimum value of <var>k</var> generated by this operation will be =&nbsp;0; the final assignment replaces a 0 by a 1.)<br />
					<br />
					accept sequence as acceptable:<br />
					&nbsp; &nbsp; &nbsp; &nbsp; " " (also empty statement).</p>
				<p>Now at last we get to the subject of this report, trading storage against computation time. We have two alternatives, either we compute the functions <var>h</var>(<var>i</var>) when we need them, or we tabulate them. Computing them when we need them presents itself as a further detailing of "doubtful sequence <b>non</b> acceptable", we shall investigate the consequences of tabulating them.</p>
				<p>For this purpose we introduce the <b>array</b> <var>H</var>[0:32] and we postulate that<br />
					&nbsp; &nbsp; &nbsp; &nbsp; <var>H</var>[<var>i</var>] = <var>h</var>[<var>i</var>] will hold for 0 &#x2264; <var>i</var> &#x2264; <var>k</var><br />
					but we have to state on which levels this will hold. It will certainly hold for the outer level (the one of the acceptable sequences, <a href="#setseqto">middle of page EWD239&ndash;5</a>) I decide that it will also hold for the level of the doubtful sequences.</p>
				<p>It implies an addition to a number of bodies<br />
					<br />
					set sequence to first acceptable one:<br />
					&nbsp; &nbsp; &nbsp; &nbsp; is extended with "<var>H</var>[0]:= 0"<br />
					<br />
					transform acceptable sequence into next doubtful one:<br />
					&nbsp; &nbsp; &nbsp; &nbsp; is extended with "<var>H</var>[<var>k</var>]:= (2 * <var>H</var>[<var>k</var>&ndash;1]) <b>mod</b> 32"<br />
					(at this moment "<var>k</var> &gt; 1" is guaranteed to hold)<br />
					<br />
					transform doubtful sequence into next doubtful one:<br />
					&nbsp; &nbsp; &nbsp; &nbsp; is extended with "<var>H</var>[<var>k</var>]:= <var>H</var>[<var>k</var>] + 1"</p>
				<p>In the above three extensions the particular choice for the quintuple pattern characterizing function <var>h</var>(<var>i</var>) has found its deposit.</p>
				<p>In terms of tabulated values <var>H</var>[<var>i</var>] the analysis for "doubtful sequence <b>non</b> acceptable" would still require scanning. We can repeat the trick by tabulating how often a value occurs in the sequence <span class="nowrap"><var>H</var>[0]....<var>H</var>[<var>k</var>].</span></p>
				<p>This now can be done in two ways. We can introduce the <br />
				  <b>integer array</b> <span class="nowrap"><var>times</var>[0:31]</span> such that for all <var>j</var><br />
					&nbsp; &nbsp; &nbsp; &nbsp; <var>times</var>[<var>j</var>] = the number of times that the value <var>j</var> occurs among <var>H</var>[0]...<var>H</var>[<var>k</var>]</p>
				<p>Let us make this to hold for both acceptable and doubtful sequences. The function is defined on <var>H</var> and <var>k</var>, modifications are to be expected by the three extensions just given and by modifications of <var>k</var>.</p>
				<p>The extension of "set sequences to first acceptable one" is extended with<br />
					&nbsp; &nbsp; &nbsp; &nbsp; <var>times</var>[0]:= 1; other values of <var>times</var> set to 0</p>
				<p>The extension of "transform acceptable sequences into next doubtful one" is extended with<br />
					&nbsp; &nbsp; &nbsp; &nbsp; <var>times</var>[<var>H</var>[<var>k</var>]]:= <var>times</var>[<var>H</var>[<var>k</var>]] + 1</p>
				<a name="toplines"></a>
				<p class="noindent">And the new version of "transform doubtful sequence into next doubtful one" becomes<br />
					&nbsp; &nbsp; &nbsp; &nbsp;<b>while</b> <var>d</var>[<var>k</var>] <b> do begin</b> <var>times</var>[<var>H</var>[<var>k</var>]]:= <var>times</var>[<var>H</var>[<var>k</var>]] &ndash; 1; <var>k</var>:= <var>k</var> &ndash; 1 <b>end</b>;<br />
			  &nbsp; &nbsp; &nbsp; &nbsp; <var>d</var>[<var>k</var>]:= 1; <var>times</var>[<var>H</var>[<var>k</var>]]:= <var>times</var>[<var>H</var>[<var>k</var>]] &ndash; 1; <var>H</var>[<var>k</var>]:= <var>H</var>[<var>k</var>] + 1; <var>times</var>[<var>H</var>[<var>k</var>]]:= <span class="nowrap"><var>times</var>[<var>H</var>[<var>k</var>]] + 1</span></p>
				<p class="noindent">The last "doubtful sequence <b>non</b> acceptable" is now simply<br />
					&nbsp; &nbsp; &nbsp; &nbsp; <var>times</var>[<var>H</var>[<var>k</var>]] &gt; 1 &nbsp;&nbsp;&nbsp;.</p>
				<p>The introduction of the array <var>times</var> is somewhat awkward. One of the nasty things is that its values are restricted to 0 and 1 and only <span class="nowrap">"<var>times</var>[<var>H</var>[<var>k</var>]]"</span> can ever get the value = 2. And this is to be modified immediately.<br />
					Additions and subtractions from these elements are usually just setting to 1 or 0.</p>
				<p>Here we can use an alternative solution, we do not introduce the array <var>times</var>, but the boolean array <var>IN</var>.</p>
				<p>In the outer level (acceptable sequences)<br />
					<var>IN</var>[<var>j</var>] means "the value <var>j</var> occurs (once!) in the sequence <var>H</var>[0]...<var>H</var>[<var>k</var>]"</p>
				<p>In the inner level (doubtful sequences)<br />
					<var>IN</var>[<var>j</var>] means "the value <var>j</var> occurs (once!) in the sequence <var>H</var>[0]...<var>H</var>[<var>k&ndash;1</var>]" &nbsp; .</p>
				<p>We now review all instructions.<br />
					<br />
					set sequence to first acceptable one:<br />
					&nbsp; &nbsp; &nbsp; &nbsp;<var>d</var>[&ndash;4]:= <var>d</var>[&ndash;3]:= <var>d</var>[&ndash;2]:= <var>d</var>[&ndash;1]:= <var>d</var>[0]:= 0; <var>k</var>:= 0;<br />
					&nbsp; &nbsp; &nbsp; &nbsp; <var>H</var>[0]:= 0; <var>IN</var>[0]:= <b>true</b>; remaining elements of <var>IN</var> become <b>false</b><br />
					<br />
					sequence full:<br />
					&nbsp; &nbsp; &nbsp; &nbsp;<var>k</var> = 31 (unchanged)<br />
					<br />
					accept sequence as solution:<br />
					&nbsp; &nbsp; &nbsp; &nbsp; " " (unchanged)<br />
					<br />
					print solution &nbsp; (unchanged)<br />
					<br />
					sequence is (first or) last member &nbsp; (unchanged)<br />
					<br />
					transform acceptable sequence into next doubtful one<br />
					&nbsp; &nbsp; &nbsp; &nbsp;<var>k</var>:= <var>k</var> + 1; <var>d</var>[<var>k</var>]:= 0; <var>H</var>[<var>k</var>]:= (2 * <var>H</var>[<var>k</var>&ndash;1]) <b>mod</b> 32<br />
					(as the sequence changes from acceptable to doubtful, <var>IN</var> is left unchanged)<br />
					<br />
					doubtful sequence <b>non</b> acceptable:<br />
					&nbsp; &nbsp; &nbsp; &nbsp; <var>IN</var>[<var>H</var>[<var>k</var>]]<br />
					<br />
					transform doubtful sequence into next doubtful one:<br />
					&nbsp; &nbsp; &nbsp; &nbsp;<b>while</b> <var>d</var>[<var>k</var>] = 1 <b>do begin</b> <var>k</var>:= <var>k</var> &ndash; 1; <var>IN</var>[<var>H</var>[<var>k</var>]]:= <b>false end</b>;<br />
					&nbsp; &nbsp; &nbsp; &nbsp; <var>d</var>[<var>k</var>]:= 1; <var>H</var>[<var>k</var>]:= <var>H</var>[<var>k</var>] + 1<br />
					(Compare this with the <a href="#toplines">top lines of this page</a>!)<br />
					<br />
					And finally "accept sequence as acceptable" <em>that was empty until now</em>, gets the form <span class="nowrap"><var>IN</var>[<var>H</var>[<var>k</var>]],</span> on account of the changing definition.</p>
				<p>By now I trust that my reader will have lost the various versions and his way through them; this was somewhat intentional. It shows the need for a clerical aid, a hierarchical assembler or possibly .... computer assistance!</p>
			</div>
			<div>
        <br/>
      </div>
		</div>
		<hr />
		<div id="footer">
         transcribed by Corrado Cantelmi<br />
          revised 
          <!-- #BeginDate format:En2 -->26-Nov-2011<!-- #EndDate -->
		</div>
	</body>

</html>
