<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1" />    <title>E.W.Dijkstra Archive: A Short Introduction to the Art of Programming (EWD 316), Chapter 9</title>		<link href="../transcriptions.css" rel="stylesheet" media="screen">	</head>  <body>    <div id="frame">			<div id="header">				<a title="link to PDF version of EWD316" href="../../ewd03xx/EWD316.PDF">EWD316</a></div>			<div id="content">				<div id="frame">					<div id="header">						<div align="center">							<p>EWD316: A Short Introduction to the Art of Programming</p>							<p>by</p>							<p>prof.dr.Edsger W.Dijkstra</p>							<p>August 1971</p>						</div>						<div align="left">							<p class="noindent"><a name="contents"></a><u>Contents</u></p>							<div id="frame">								<div id="header">									<blockquote>										<div align="left">											<div id="frame">												<div id="content">													<blockquote>														<div align="left">															<p class="noindent">0. Contents</p>															<p class="noindent">1. <a title="Chapter 1 of EWD 316" href="EWD316.html">Preface</a><br>																<br>																2. <a title="Chapter 2 of EWD 316" href="EWD316.2.html">Some Fundamental Notions</a><br>																<br>																3. <a title="Chapter 3 of EWD 316" href="EWD316.3.html">Programming Languages and their Implementation</a><br>																<br>																4. <a title="Chapter 4 of EWD 316" href="EWD316.4.html">Variables and relations between their values</a><br>																<br>																5. <a title="Chapter 5 of EWD 316" href="EWD316.5.html">Programs corresponding to recurrence relations</a><br>																<br>																6. <a title="Chapter 6 of EWD 316" href="EWD316.6.html">A first example of step-wise program composition</a><br>																<br>																7. <a title="Chapter 7 of EWD 316" href="EWD316.7.html">The shortest spanning subtree of a graph</a><br>																<br>																8. <a title="Chapter 8 of EWD 316" href="EWD316.8.html">The towers of Hanoi</a><br>																<br>																9. <a title="Chapter 9 of EWD 316" href="EWD316.9.html">The problem of eight queens</a><br>																<br>																10. A rearranging routine</p>														</div>													</blockquote>												</div>											</div>										</div>									</blockquote>								</div>							</div>						</div>					</div>				</div>				<p class="noindent">10. <u>A rearranging routine</u></p>				<p>The following example has been inspired by the work of C.A.R.Hoare (Algorithm 64, C.A.C.M.).</p>				<p>The original problem was to rearrange the values of the elements of a given array <var>A</var>[1:<var>N</var>] and a given value of <var>f</var> (1 &le; <var>f</var> &le; <var>N</var>) such that after the rearrangement<br>					<br>				</p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td>for 1 &le; k &lt; f	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[k] &le; A[f]</td>						<td></td>					</tr>					<tr>						<td>for f &lt; k &le; N	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A[k] &ge;  A[f]  .</td>						<td>(1)</td>					</tr>				</table>				<p>As a result of this rearrangement <var>A</var>[<var>f</var>] equals the <var>f</var>-th value in order of non-decreasing magnitude. We call the array rearranged satisfying (1) &quot;split around <var>f</var>&quot;; we call the final value of <var>A</var>[<var>f</var>] &quot;the splitting value&quot;. When the array has been split it is divided into two halves, the one half &#151;the &quot;left-hand&quot; half, say&#151; containing the &quot;small&quot; values and the other half &#151;the &quot;right-hand&quot; half, say&#151; containing the large values, with the splitting value sandwiched in between. The overall function of the algorithm is to move small values to the left and large values to the right. The difficulty is that <u>for given <var>f</var></u> the final value of <var>A</var>[<var>f</var>], i.e. our criterion &quot;small/large&quot;, is unknown to start with.</p>				<p>Hoare's invention is the following. Select some rather arbitrary criterion &quot;small/large&quot;; by moving small elements to the left and large elements to the right, a split will be established <u>somewhere</u>, around some position. If <var>s</var> happens to turn out = <var>f</var>, the original problem has been solved. The kernel of Hoare's invention is the observation that in the other cases the original problem can be reduced to the same problem, but now applied to one of the halves, viz. to the left-hand half if <var>f</var> lies to the left of the split and to the right-hand half if <var>f</var> lies to the right of the split.</p>				<p class="noindent"><u>Note</u>. An alternative approach would be to sort the array completely: after that <var>A</var>[<var>f</var>] will equal the <var>f</var>-th value in the order of non-decreasing magnitude. But this can be expected to be rather expensive, for then we have established relations (1) for <u>all</u> values of <var>f</var>. As a matter of fact we will arrive at a rearranging routine which itself can be used for complete sorting, on account <!-- EWD316 - 90 -->of the fact that, when a split around <var>s</var> has been established, <var>A</var>[<var>s</var>] has the value it is going to have in the completely sorted array, and that &#151;because all elements to the left of it are &le; <var>A</var>[<var>s</var>] and those to the right of it are &ge&nbsp;<var>A</var>[<var>s</var>]&#151; completely sorting it could now be performed by sorting thereafter the two parts independently.</p>				<p>We now focus our attention on the rearranging routine which is to cause a split in the array section</p>				<blockquote>					<p class="noindent">A[m] ... A[n]    with 1 &le; m &le; n &le; N<br>					</p>				</blockquote>				<p>When we try to make such a routine we are immediately faced with the choice of our criterion &quot;small/large&quot;. One of the ways is to select an arbitrary element from the section, to call all elements larger than it &quot;large&quot;, all elements smaller than it &quot;small&quot; and all elements equal to it either &quot;large&quot; or &quot;small&quot;, just what is most convenient (in the final arrangement they may occur everywhere, either at the split or at either of its two sides). Let us therefore postpone the choice in this discussion for a moment, as there is a chance that we can use our freedom to some advantage.</p>				<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We are going to select one of the values in the array as the &quot;splitting value&quot;; having chosen this value, its final position, i.e. the position of the split, is unknown before the algorithm starts; it is defined when the algorithm has been executed, in other words it is determined by the evolution of the computation. This suggests that we build up the collection of the small values, starting at the left-hand end, and that of the large values at the right-hand end, and continue doing so until the two collections meet somewhere in the middle. To be more precise, we introduce two pointers, &quot;<var>i</var>&quot; and &quot;<var>j</var>&quot; say, whose initial values will be &quot;<var>m</var>&quot; and &quot;<var>n</var>&quot; respectively, and rearrange values in such a fashion that, when we call the splitting value <var>V</var>, we ensure that</p>				<blockquote>					<p class="noindent">A[k] &le; V for m &le; k &lt; i   and    <br>						A[k] &ge; V for j &lt; k &le; n   .</p>				</blockquote>				<p>Having chosen the splitting value, the algorithm will have the duty of building up the collections of small and large values respectively from <!-- EWD316 - 91 -->the outside inwards. The algorithm can start scanning, at the left-hand end say, until a large element is encountered. If this occurs, this value has to be removed from the collection of small values, i.e. it has to be added to the collection of large elements. It is, as a matter of fact, the first element whose &quot;largeness&quot; the algorithm has established: as we have decided to build up the collections from the outside inwards, this large value has to be assigned to <var>A</var>[<var>n</var>] . As we would like this position in the array to be &quot;free&quot; &#151;i.e. available to receive this first large value&#151; the <u>original</u> value of <var>A</var>[<var>n</var>] can be taken out of the array at the beginning and can be chosen as the splitting value <var>V</var>.</p>				<p>That is, we initialize <var>i</var> = <var>m</var> and <var>j</var> = <var>n</var> and &quot;take out&quot; <var>A</var>[<var>n</var>] &#151;by assigning it to the variable <var>V</var>&#151; thereby initializing the situation where scanning starts at element <var>A</var>[<var>i</var>] , while &quot;<var>j</var>&quot; points to the &quot;hole&quot; just made. When the upward scan (under control of increasing &quot;<var>i</var>&quot;) finds a large element, i.e. when for the first time <var>A</var>[<var>i</var>] &gt; <var>V</var>, this value is placed in the hole, now leaving the hole in the place pointed to by &quot;<var>i</var>&quot;. From then onwards a downward scan (under control of decreasing &quot;<var>j</var>&quot;) can operate until a small element has been encountered which will be placed in the hole at position &quot;<var>i</var>&quot;, leaving the hole in the place pointed to by &quot;<var>j</var>&quot;. Such upward and downward scans have to succeed eachother alternately until <var>i</var> = <var>j</var>, i.e. until both point to the hole at the position around which the split has been effectuated, Finally the hole receives the value <var>V</var> which had been taken out at the beginning.</p>				<p>The above sketch gives an informal description of the essential features of the algorithm, it by no means settles the structure of the sequential program that will embody it.</p>				<p>I have tried a program in which the core consists of the program part for the upward scan followed by the program part for the downward scan. The first part consists of a loop with &quot;<code>i:= i + 1</code>&quot; in the repeatable statement; the second part consists of a loop with &quot;<code>j:= j - 1</code>&quot; in the repeatable statement. The two parts together then form the repeatable statement of an outer loop. This program became very ugly and messy, the reason being that termination may occur either because the upward scan or because the downward scan is on the verge of scanning the hole. The reasoning needed to establish <!-- EWD316 - 92 -->that the program did terminate properly became tortuous.</p>				<p>On account of that experience I have tried the alternative approach, one loop in which a single execution of the repeatable statement decreases the difference &quot;<var>j</var> - <var>i</var>&quot; (i. e. the length of the unscanned array section) by 1 , by doing a step of the <u>appropriate</u> scan.</p>				<p>The decision to control the steps of <u>both</u> scans by the <u>same</u> repeatable statement calls for the introduction of another variable; as we have to distinguish between only two cases, a boolean variable suffices, &quot;<var>up</var>&quot; say, with the meaning:</p>				<table width="100%">					<tr>						<td valign=top nowrap width="30%"><code>up = <u>true</u></code> &nbsp;means:</td>						<td>the algorithm is in the state of upward scan and <var>j</var> points to the hole</td>					</tr>					<tr>						<td valign=top nowrap width="30%"><code>up = <u>false</u></code> means:</td>						<td>the algorithm is in the state of downward scan and <var>i</var> points to the hole.</td>					</tr>				</table>				<p>The initialization has to be extended with the assignment &quot;<code>up:= true</code>&quot;; after the initialization the program continues with</p>				<blockquote>					<p class="noindent">&quot;<u>while</u> i &lt; j <u>do</u> perform the appropriate step&quot;<br>					</p>				</blockquote>				<p class="noindent">In the course of the action &quot;perform the appropriate step&quot;, the value of &quot;<var>up</var>&quot; has to change its value whenever the hole is filled and the scanning direction has to reverse. Without any further detours I arrived at the following procedure:</p>				<p class="noindent"><u>integer</u> <u>procedure</u> split(<u>real</u> <u>array</u> a, <u>integer</u> <u>value</u> m, n); <br>					<u>begin</u> <u>integer</u> i, j; <u>real</u> V; <u>boolean</u> up; <br>					      i:= m; j:= n; V:= a[j]; up:= <u>true</u>; <br>					      <u>while</u> i &lt; j <u>do</u> <br>					      <u>begin</u> <u>if</u> up <u>then</u><br>					                <u>if</u> a[i] &gt; V <u>do</u> <u>begin</u> a[j]:= a[i]; up:= <u>false</u> <u>end</u><br>					                  <u>else</u><br>					                <u>if</u> V &gt; a[j] <u>do</u> <u>begin</u> a[i]:= a[j]; up:= <u>true</u> <u>end</u>;<br>					            <u>if</u> up <u>then</u> i:= i + 1  <u>else</u> j:= j - 1<br>					      <u>end</u>;<br>					      a[j]:= V; split:= j<br>					<u>end</u><br>				</p>				<p>In its applications we shall only call the procedure &quot;split&quot; with <var>m</var> &lt; <var>n</var>; as it stands it also caters for the case <var>m</var> = <var>n</var>,</p>				<p class="noindent"><u>Exercise</u>. Show that in a version of <code>split</code> that only needs to cater for <var>m</var> &lt; <var>n</var>, its internal repetition could have been controlled by a <u>repeat</u> <u>until</u> clause as well.</p>				<p class="noindent"><u>Note</u>. At the price of a larger number of subscriptions to be performed, the text of the procedure can be shortened by not introducing the separate variable <var>V</var>, but by storing this value &quot;in the hole&quot;, i.e.</p>				<blockquote>					<p class="noindent">V = <u>if</u> up <u>then</u> a[j] <u>else</u> a[i]       .</p>				</blockquote>				<p class="noindent">As a result the splitting value zigzags to its final position. With the above convention the tests &quot;<code>a[i] &gt; V</code>&quot; and &quot;<code>V &gt; a[j]</code>&quot; both become &quot;<code>a[i] &gt; a[j]</code>&quot;, the assignments &quot;<code>a[j]:= a[i]</code>&quot; and &quot;<code>a[i]:= a[j]</code>&quot; both become the interchange<br>				</p>				<blockquote>					<p class="noindent">W:= a[i]; a[i]:= a[j]; a[j]:= W <br>					</p>				</blockquote>				<p class="noindent">and the assignments &quot;<code>up:= <u>false</u></code>&quot; and &quot;<code>up:= <u>true</u></code>&quot; can both be represented by</p>				<blockquote>					<p class="noindent">up:= <u>non</u> up <br>					</p>				</blockquote>				<p class="noindent">The above considerations allow us to condense the procedure text into</p>				<p class="noindent"><u>integer</u> <u>procedure</u> split(<u>real</u> <u>array</u> a, <u>integer</u> <u>value</u> m, n); <br>					<u>begin</u> <u>integer</u> i, j; <u>real</u> W; <u>boolean</u> up;<br>					      i:= m; j:= n; up:= <u>true</u>;<br>					      <u>while</u> i &lt; j <u>do</u><br>					      <u>begin</u> <u>if</u> a[i] &gt; a[j] <u>do</u><br>					            <u>begin</u> W:= a[i]; a[i]:= a[j]; a[j]:= W; up:= <u>non</u> up <u>end</u>; <br>					            <u>if</u> up <u>then</u> i:= i + 1 else j:= j - 1<br>					      <u>end</u>;<br>					      split:= j<br>					end.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(End of Note.)</p>				<p>We now return to our original problem: given an array <var>A</var>[1:<var>N</var>] and a value <var>f</var> (1 &le; <var>f</var> &le; <var>N</var>), rearrange the elements in such a way that<br>					for 1 &le; <var>i</var> &lt; <var>f</var> &nbsp; &nbsp; &nbsp; <var>A</var>[<var>i</var>] &le;<var>A</var>[<var>f</var>] &nbsp; &nbsp; &nbsp; and<br>					for f &lt; <var>i</var> &le; <var>N</var> &nbsp; &nbsp; &nbsp; <var>A</var>[<var>i</var>] &ge;<var>A</var>[<var>f</var>] &nbsp; &nbsp; &nbsp; ;<br>					as a result <var>A</var>[<var>f</var>] will equal the <var>f</var>-th element in the order of non-decreasing magnitude.</p>				<p>The idea is to apply the operator &quot;split&quot; first to the original array from 1 through <var>N</var>. The operator establishes the split somewhere, position <var>s</var> say. If the position of the split coincides with <var>f</var> (<var>f</var> = <var>s</var>), we have reached our goal, otherwise the operator &quot;split&quot; is applied to one of the halves, viz. to the left-hand half when <var>f</var> &lt; <var>s</var> and to the right-hand half when <var>f</var> &gt; <var>s</var> etc.</p>				<p>For this purpose we introduce variables <var>p</var> and <var>q</var>, satisfying</p>				<blockquote>					<p class="noindent">1 &le; p &le; f &le; q &le; N</p>				</blockquote>				<p class="noindent">such that</p>				<blockquote>					<p class="noindent">A[p] ... A[q]<br>					</p>				</blockquote>				<p class="noindent">will be the section of the array to which the split will be applied, as this section is certain to contain the (future) value of <var>A</var>[<var>f</var>].</p>				<p>If the split is found to the right of <var>f</var> (i.e. <var>f</var> &lt; <var>s</var>) the operator has to be applied to the left-hand half, i.e. <var>q</var> has to be reset to <var>s</var> - 1 and <var>p</var> can be left unchanged; in the case <var>f</var> &gt; <var>s</var>, <var>p</var> has to be reset to <var>s</var> + 1 and <var>q</var> can be left unchanged. We thus arrive at the routine</p>				<p class="noindent"><u>integer</u> p, q, s;<br>					p:= 1; q:= N;<br>					<u>repeat</u> s:= split(A, p, q);<br>					       <u>if</u> f &lt; s <u>do</u> q:= s - 1;<br>					       <u>if</u> f &gt; s <u>do</u> p:= s + 1 <br>					<u>until</u> f = s     .<br>				</p>				<p class="noindent">(<u>Note</u>. This program can call the routine &quot;split&quot; with <var>m</var> = <var>n</var>.)</p>				<p>We may wish to improve upon this program: it is rather superfluous to call the operator &quot;split&quot; with <var>p</var> = <var>q</var>: if the section consists of a single element no (significant) rearrangement can take place; the split will be around its single element and both halves will be empty. The relation <var>p</var> &lt; <var>q</var> gives as therefore another necessary criterion of continuation, and we can look to see whether we can make it the sole criterion for continuation. Because we want to stick to <var>p</var> &le; <var>f</var> &le; <var>q</var>, the termination via the luck of hitting <var>f</var> with the split, i.e. <var>f</var> = <var>s</var>, has to generate <var>p</var> = <var>f</var> = <var>q</var>. The following program would achieve that result. <!-- EWD316 - 95 --></p>				<p class="noindent"><u>integer</u> p, q, s;<br>					p:= 1; q:= N;<br>					<u>while</u> p &lt; q <u>do</u><br>					<u>begin</u> s:= split(A, p, q);<br>					      <u>if</u> f = s <u>then</u> <u>begin</u> p:= f; q:= f <u>end</u><br>					               <u>else</u> <u>if</u> f &lt; s <u>then</u> q:= s - 1 <u>else</u> p:= s + 1<br>					<u>end</u>     .<br>				</p>				<p>From the above program text it is obvious that the operator &quot;split&quot; only be applied to sections of the array containing at least twa elements.</p>				<p>A more intricate use of the operator &quot;split&quot; is in complete sorting of the array, observing that after application of the operator &quot;split&quot; at least one element (viz. <var>A</var>[<var>s</var>]) has reached its final destination, while all other elements, although not necessarily in their final position, will be in the correct half, so that complete sorting then consists of sorting both halves independently.</p>				<p>The naive approach is a recursive</p>				<p class="noindent"><u>procedure</u> sort( <u>real</u> <u>array</u> a, <u>integer</u> <u>value</u> p, q);<br>					<u>begin</u> <u>integer</u> s;<br>					      s:= split(a, p, q);<br>					      <u>if</u> p &lt; s - 1 <u>do</u> sort(a, p, s - 1);<br>					      <u>if</u> s + 1 &lt; q <u>do</u> sort(a, s + 1, q) <br>					<u>end</u><br>				</p>				<p class="noindent">such that the call</p>				<blockquote>					<p class="noindent">sort(A, 1, N)<br>					</p>				</blockquote>				<p class="noindent">will sort the entire array. Again it has been exploited that sorting an array section is only a necessary operation if the section contains at least two elements. (The routine &quot;sort&quot; may be called with a section of only one element, but it will not generate such calls itself.)</p>				<p>We have called the above procedure naive and we have done so for the following reasons. The operator &quot;split&quot; may divide the section offered to it into two very inequal parts (e.g. when the originally rightmost element had a near maximum value); as a result the maximum dynamic depth of recursive calls <!-- EWDJ16 - 96 -->may grow proportionally to <var>N</var>, the length of the array section. As recursive calls require an amount of storage space proportional to the dynamic depth, the given program may turn out to be prohibitively demanding in its storage requirements. This would lead to the conclusion that recursive sorting is impractical, but for the fact that a slight rearrangement of the procedure &quot;sort&quot; ensures that the maximum dynamic depth will not exceed log<sub>2</sub><var>N</var>. In view of the existence of such a sorting procedure we call the previous one &quot;naive&quot;.</p>				<p>We can guarantee that a sorting routine will not generate a dynamic depth exceeding log<sub>2</sub><var>N</var>, if whenever it has called &quot;split&quot;, it will only prescribe a recursive call on itself for the sorting of the smallest of the two halves. (In the case that the two halves are of equal length, the choice is immaterial.) Applying &quot;sort&quot; recursively to the smallest half only will leave the other half unsorted, but this can be remedied by repeatedly applying this only half-effective sorting effort to the still unsorted section. In the body of &quot;sort&quot;, two integers &quot;<var>pu</var>&quot; and &quot;<var>qu</var>&quot; are introduced, pointing to the left- and right-hand end of the still unsorted section.</p>				<p class="noindent"><u>procedure</u> sort(<u>real</u> <u>array</u> a, <u>integer</u> <u>value</u> p, q); <br>					<u>begin</u> <u>integer</u> s, pu, qu; <br>					      pu:= p; qu:= q; <br>					      <u>while</u> pu &lt; qu <u>do</u> <br>					      <u>begin</u> s:= split(a, pu, qu);<br>					            <u>if</u> qu - s &lt; s - pu <u>then</u><br>					               <u>begin</u> <u>if</u> s + 1 &lt; qu <u>do</u> sort(a, s + 1, qu); qu:= s - 1 <u>end</u><br>					                               <u>else</u><br>					               <u>begin</u> <u>if</u> pu &lt; s - 1 <u>do</u> sort(a, pu, s - 1); pu:= s + 1 <u>end</u><br>					      <u>end</u> <br>					<u>end</u><br>				</p>				<p>Again, sort may be called with a section of a single element, but will not generate such calls itself.</p>				<p class="noindent"><u>Exercise</u>. Prove that termination of the loop is guaranteed to take place with <var>pu</var> = <var>qu</var>. (This is less obvious than you might think!)</p>				<p class="noindent"><u>Note</u>. If, to start with, the elements of array <var>A</var> are ordered according to non-decreasing magnitude, excessive depth of recursive calls has been prevented, but the algorithm remains time-consuming (proportional to <var>N</var><sup>2</sup>). This has given rise to refinements of the procedure &quot;split&quot;: instead of blindly taking the right-most element of the array section as splitting value, some sort of small search for a probably better approximation of the median value can be inserted at the beginning of &quot;split&quot;; this element can be interchanged with the rightmost element and thereafter split can continue as described.</p>				<p class="noindent"><a href="#contents">Back to top</a></p>				<p></p>			</div>			<hr />			<!-- name and date -->      <div id="footer">transcribed by Romek Zylla<br />revised <csobj format="MedDate" h="15" region="15" t="DateTime" w="95">Sat, 2 Aug 2008</csobj></div>    </div>  </body></html></x-html>