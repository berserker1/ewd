<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">  <head>    <meta http-equiv="content-type" content="text/html; charset=ISO-8859-1" />    <title>E.W.Dijkstra Archive: A Short Introduction to the Art of Programming (EWD 316), Chapter 6</title>		<link href="../transcriptions.css" rel="stylesheet" media="screen">	</head>  <body>    <div id="frame">			<div id="header">				<a title="link to PDF version of EWD316" href="../../ewd03xx/EWD316.PDF">EWD316</a></div>			<div id="content">				<div id="frame">					<div id="header">						<div align="center">							<p>EWD316: A Short Introduction to the Art of Programming</p>							<p>by</p>							<p>prof.dr.Edsger W.Dijkstra</p>							<p>August 1971</p>						</div>						<div align="left">							<p class="noindent"><a name="contents"></a><u>Contents</u></p>						</div>						<blockquote>							<div align="left">								<div id="frame">									<div id="header">										<blockquote>											<div align="left">												<div id="frame">													<div id="content">														<div align="left">															<p class="noindent">0. Contents</p>															<p class="noindent">1. <a title="Chapter 1 of EWD 316" href="EWD316.html">Preface</a><br>																<br>																2. <a title="Chapter 2 of EWD 316" href="EWD316.2.html">Some Fundamental Notions</a><br>																<br>																3. <a title="Chapter 3 of EWD 316" href="EWD316.3.html">Programming Languages and their Implementation</a><br>																<br>																4. <a title="Chapter 4 of EWD 316" href="EWD316.4.html">Variables and relations between their values</a><br>																<br>																5. <a title="Chapter 5 of EWD 316" href="EWD316.5.html">Programs corresponding to recurrence relations</a><br>																<br>																6. A first example of step-wise program composition<br>																<br>																7. <a title="Chapter 7 of EWD 316" href="EWD316.7.html">The shortest spanning subtree of a graph</a><br>																<br>																8. <a title="Chapter 8 of EWD 316" href="EWD316.8.html">The towers of Hanoi</a><br>																<br>																9. <a title="Chapter 9 of EWD 316" href="EWD316.9.html">The problem of eight queens</a><br>																<br>																10. <a title="Chapter 10 of EWD 316" href="EWD316.10.html">A rearranging routine</a></p>														</div>													</div>												</div>											</div>										</blockquote>									</div>								</div>							</div>						</blockquote>					</div>				</div>				<p class="noindent">6. <u>A first example of stepwise program composition</u></p>				<p>The little examples dealt with so far are not representative for the programs that have to be made: they are several orders of magnitude too small. A trained programmer ''sees'' them at a glance, he can think about them without pencil and paper. They are of the size of a paragraph, while we have to deal with programs of the size of a page, a chapter or a book and eventually &#151;to quote A. Perlis&#151; with programs that no longer fit into a single programmer's skull! The composition of such very large programs falls outside the scope of this little monograph, but the very least thing we can do is to show the reader how to organize his thoughts when composing, say, page-size programs. If in the following the reader thinks that I am too careful, he should bear the chapter-size programs in mind. (If he is still unconvinced he should study a single page program made by a messy programmer; he will then discover that even a single page has room enough for a disgusting and intellectually unhealthy among of unmastered complexity!)</p>				<p>Here we go. Consider sequences composed of 1's, 2's and 3's which contain only pairs of different adjoining non-empty subsequences. Examples of such good sequences are</p>				<p class="noindent"><code>1<br>						12<br>						12312<br>						3212321</code> . </p>				<p class="noindent">Examples of bad sequences are</p>				<p class="noindent"><code>11<br>						12323131<br>						32132132132</code> .</p>				<p>In all probability the list of good sequences is infinite. The problem is now: given that there is at least one good sequence of length 100 (i.e. consisting of 100 digits), make a program generating the beginning of this list of good sequences in alphabetical order up to and including the first sequence of length 100. (Alphabetical order under the convention that the 1 precedes the 2 and the 2 precedes the 3; the criterion can be translated into a numerical one by putting the decimal point in front of the sequence and then interpreting the sequence as a decimal fraction. With that convention alphabetical order is the order of increasing magnitude.)</p>				<p class="noindent">I have used this example extensively in oral examinations. After some initial skirmishes, most students discovered for themselves</p>				<ol>					<li>that a bad sequence could never be made into a good one by extending it, i.e. all good sequences are either a one-digit sequence or a one-digit extension of a good sequence					<li>if sequence <var>B</var> is a good one-digit extension of sequence <var>A</var>, sequence <var>A</var> precedes sequence <code>B</code> in the alphabetical order, i.e. a good sequence is followed by all its possible extensions					<li>the alphabetical order requires that the good sequence <var>A</var> will first be followed by its extensions starting with a 1 (if any), then by those starting with a 2 (if any), then by those starting with a 3 (if any).				</ol>				<p class="noindent">These observations lead to the following rule:</p>				<blockquote>					<p class="noindent">a good sequence should be printed and extended with a 1 as the next trial sequence; from a bad sequence, terminal 3's (if any) should be removed and the final digit (now &#x2260;3) should be increased by 1, giving the next trial sequence.</p>				</blockquote>				<p class="noindent">The beginning of the list to be generated is:</p>				<p class="noindent"><code>1<br>						12<br>						121<br>						1213<br>						12131<br>						121312<br>						1213121<br>						1213123<br>						....... </code></p>				<p class="noindent">by searching the following list of trial sequences (omitting the ones marked by *)<br>					<br>				</p>				<table width="122" border="0" cellspacing="0" cellpadding="0">					<tr>						<td valign="top" width="40"><code><br>								*<br>								<br>								<br>								*<br>								*<br>								<br>								<br>								*<br>								<br>								<br>								*<br>								*<br>								*<br>								*<br>							</code></td>						<td><code>1<br>								11<br>								12<br>								121<br>								1211<br>								1212<br>								1213<br>								12131<br>								121311<br>								121312<br>								1213121<br>								12131211<br>								12131212<br>								12131213<br>								1213122<br>								1213123<br>								.......</code></td>					</tr>				</table>				<p>Many of them suggested a program of the following structure.</p>				<p class="noindent">program 1: </p>				<blockquote>					<p class="noindent"><code>SET SEQUENCE TO ONE AND LENGTH TO ONE;<br>							<u>repeat</u> <u>if</u> GOOD <u>then</u> <u>begin</u> PRINT; EXTEND WITH ONE <u>end<br>							</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>else</u> ADJUST<br>							<u>until</u> length &gt; 100</code></p>				</blockquote>				<p class="noindent">in which the primitive ''<code>EXTEND WITH ONE</code>'' extends the given sequence with a 1 and the primitive ''<code>ADJUST</code>'' increases the last digit by 1 after removal of terminal 3's, if any. (For the operation ''<code>ADJUST</code>'' to be defined, the sequence remaining after removal of terminal 3's must not be empty; this follows from the fact that the list to be produced is known to contain a sequence of length = 100.)</p>				<p>A number of objections can be raised against a program made along the lines sketched. One objection is that at the beginning of the execution of the repeatable statement the length will be &#x2264; 100, and furthermore we know that the operation ''<code>ADJUST</code>'' will never increase the length; nevertheless each adjustment is followed in time by a test on the length, and the first objection is therefore that these tests are superfluous. A more serious objection is to be found in the tortuous reasoning required to establish that the end condition is all right. Instead of stopping when for the first time a solution of length 100 has been printed, it will stop when the first trial sequence of length &gt; 100 has been generated. It is clear that the above program will never produce a solution larger than 100 because such a long trial sequence will never be subjected to the test ''<code>GOOD</code>''. To show, however, that it will stop after the production of the <u>first</u> solution of length = 100 is much harder.</p>				<p>A much nicer program is based upon the observation that we can regard the empty sequence as a virtual solution which does not need to be printed.</p>				<p class="noindent">program 2: </p>				<blockquote>					<p class="noindent"><code>SET SEQUENCE EMPTY AND LENGTH TO ZERO;<br>							<u>repeat</u> EXTEND WITH ONE;<br>							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> <u>non</u> GOOD <u>do</u> ADJUST;<br>							<u>until</u> length = 100</code></p>				</blockquote>				<p>The objections raised are no longer valid. The true reason, however, why the above program is so much more attractive, is to be found in the observation that we can mentally combine the first two statements of the repeatable statement. The above version is a refinement of the more abstract</p>				<p class="noindent">program 3:</p>				<blockquote>					<p class="noindent"><code>SET SEQUENCE EMPTY AND LENGTH TO ZERO;<br>							<u>repeat</u> TRANSFORM SEQUENCE INTO NEXT SOLUTION;<br>							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PRINT<br>							<u>until</u> length = 100.</code></p>				</blockquote>				<p class="noindent">(Note. In programs 1, 2 and 3 the outer repetition could also have been controlled by a while clause.)</p>				<p>Observe that here, in program 3, we have a level of description from which the trial sequences have disappeared! It is a level of description which can be understood in terms of solutions only. By distinguishing, i.e. by mentally isolating the operator ''<code>TRANSFORM SEQUENCE INTO NEXT SOLUTION</code>'' and postponing its refinement, we have separated the task of formulating the correct criterion for termination from how the transition from one solution to the next will be performed via a number of trial sequences which may be rejected. Remembering the limited size of the programmer's skull, this separation is a vital achievement, as it enables us to deal with one thing at a time.</p>				<p>To show that all this is not just idle playing with words we shall proceed from program 3 as our starting point, refining from there onwards. By way of surprise we shall arrive at a refinement different from program 2, again without essentially changing the algorithm. (Although I had used the example extensively in examinations, the next version only occurred to me when writing this very text! This is just to show that such abstract programs are vital stepping stones in our process of constructive reasoning!)</p>				<p>To find this refinement we take a step backwards, asking ourselves what enabled us to make the transition from program 1 to program 2. It was the introduction of the empty sequence as ''virtual solution''. In program 1, the first solution was given, while the others were generated; in program 2 and 3, all solutions to be printed are generated by the same operator ''<code>TRANSFORM SEQUENCE INTO NEXT SOLUTION</code>''.</p>				<p>When refining this operator the trial sequences have to be generated, and in program 2 we find that the criterion ''<code>GOOD</code>'' has to be applied to trial sequences generated in two different ways, either by ''E<code>XTEND WITH ONE</code>'' or by ''<code>ADJUST</code>''. Can we clean up our refinement by insisting that all trial sequences to be tested are generated by the same operator? Yes we can, by slightly changing the extension operator and slightly generalizing the operate ''<code>ADJUST</code>'', as in the following refinement.</p>				<p class="noindent"><code>TRANSFORM SEQUENCE INTO NEXT SOLUTION:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXTEND WITH ZERO;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> ADJUST <u>until</u> GOOD.</code></p>				<p>Here ''<code>GOOD</code>'' stands for a rather complicated function; an alternative form uses the boolean variable ''<code>good</code>'' and leaves us with the task of refining the operator ''<code>SET GOOD</code>''.</p>				<p class="noindent"><code>TRANSFORM SEQUENCE INTO NEXT SOLUTION:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>boolean</u> good;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXTEND WITH ZERO;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> ADJUST; SET GOOD <u>until</u> good.</code></p>				<p class="noindent">(<u>Note</u>: In the above refinement the repetition is not to be controlled by a while-clause. Why?)</p>				<p>Now the time has come to make a decision on the representation of ''sequence''. It has a property ''length'', now satisfying the inequalities 0 &#x2264; length &#x2264; 100 and is an ordered sequence of length digits. An appropriate vehicle for representing this sequence is (part of) a linear array of integer variables. We suggest declaring an <code><u>integer</u> <u>array</u> d[1:100]</code>, such that at any moment the sequence will be represented by</p>				<blockquote>					<p class="noindent"><code>d[1], d[2], ... , d[length].</code></p>				</blockquote>				<p>We would like to point out that this is a well-motivated decision. An alternative representation would have been</p>				<blockquote>					<p class="noindent"><code>d[101 - length], d[102 - length], ... , d[100]</code></p>				</blockquote>				<p class="noindent">but with the latter convention all operations changing the length of the sequence would imply moving the values upwards or downwards, whereas with the suggested representation, the values being kept can ''stay where they are''. When the chosen convention is made to apply to all sequences manipulated (i.e. to solutions as well as to trial sequences) the following four refinements are fairly obvious. (As far as they are concerned, the chosen representation is certainly adequate.)</p>				<p class="noindent"><code>SET SEQUENCE TO EMPTY AND LENGTH TO ZERO:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length:= 0;</code></p>				<p class="noindent"><code>EXTEND WITH ZERO:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length:= length + 1; d[length]:= 0;</code></p>				<p class="noindent"><code>ADJUST:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> d[length] = 3 <u>do</u> length:= length - 1;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[length]:= d[length] + 1;</code></p>				<p class="noindent"><code>PRINT:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i:= 0; <u>repeat</u> i:= i + 1; printdigit(d[i]) <u>until</u> i = length; newline</code></p>				<p class="noindent">where we have assumed the availability of the primitives ''<code>printdigit</code>'' and ''<code>newline</code>'' for the transition to the beginning of the next line for output. The only refinement which can still cause headaches is the operator ''<code>SET GOOD</code>''.</p>				<p>To investigate an arbitrary sequence is indeed a gruesome task, but it becomes much easier if we exploit the circumstances that the only sequences to be subjected to the test are trial sequences, and each trial sequence is a one-digit extension of an (earlier) good sequence. As a result it can only violate the condition if its terminal element is included in one of the subsequences, i.e. it has to be rejected as bad if there exists an <code>m</code> (satisfying 0 &lt; 2 * <code>m</code> &#x2264 <code>length</code>) such that the pair of adjoining ''<em>msequences</em>''</p>				<blockquote>					<p class="noindent"><code>d[length - 2 * m + 1], ... , d[length - m] and<br>							d[length - m + 1], ... , d[length]</code></p>				</blockquote>				<p class="noindent">are equal. Assuming the availability of the operator needed to compare the msequences of this pair (for arbitrary, given <code>m</code>), out first refinement of ''<code>SET GOOD</code>'' is</p>				<p class="noindent"><code>SET GOOD:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;integer m;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;good:= <u>true</u>; m:= 1;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> 2 * m </code>&#x2264;<code> length <u>and</u> good <u>do</u><br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> GIVE GOOD THE MEANING THAT SEQUENCES DIFFER;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m:= m + 1;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u></code></p>				<p class="noindent">or (probably better)</p>				<p class="noindent"><code>SET GOOD:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>integer</u> m, mbound;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;good:= <u>true</u>; mbound:= length <u>div</u> 2; m:= 1;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> m </code>&#x2264;<code> mbound <u>and</u> good <u>do</u><br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> GIVE GOOD THE MEANING THAT SEQUENCES DIFFER;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m:= m + 1;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u></code></p>				<p>Here the operator <u><code>div</code></u> is the integer divide, rounding off the quotient to the nearest integer towards zero. The double condition for continuing the repetition expresses that the investigation can be stopped as soon as an equal pair has been found, as this is sufficient to establish its being bad. We have seen this construction at the end of the previous section.</p>				<p class="noindent"><u>Question</u>. An alternative form would have been</p>				<blockquote>					<p class="noindent"><code><u>integer</u> m;<br>							good:= <u>true</u>; m:= length div 2;<br>							<u>while</u> m &gt; 0 <u>and</u> good <u>do</u><br>							<u>begin</u> GIVE GOOD THE MEANING THAT SEQUENCES DIFFER;<br>							&nbsp;&nbsp;&nbsp;&nbsp; m:= m - 1;<br>							<u>end</u></code> </p>				</blockquote>				<p class="noindent">Why do we propose to do the investigation in the order of increasing <code>m</code>?</p>				<p>Finally we refine the comparison of two msequences.</p>				<p class="noindent"><code>GIVE GOOD THE MEANING THAT THE SEQUENCES DIFFER:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>integer</u> firstend, k;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstend:= length - m; k:= 0;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> good:= (d[length - k] </code>&#x2260;<code> d[firstend - k]);<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k:= k + 1;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> k = m <u>or</u> good</code></p>				<p class="noindent">again expressing that the comparison of the two msequences can be terminated as soon as it has been established that they differ somewhere.</p>				<p>Collecting the declarations and inserting the refinements &#151;keeping their names as labels for explicative purposes&#151; we arrive at the complete program as shown on the next page [i.e., immediately below]. The successive levels of detail have been indicated by systematic use of indentation.</p>			</div>			<div id="content" align="center">				<p class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>					*</p>			</div>			<div id="content">				<p class="noindent"><u><code>begin</code></u><code>&nbsp;&nbsp; <u>integer</u> array d[1:100]; <u>boolean</u> good; <u>integer</u> length, i, m, mbound, k, firstend;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SET SEQUENCE EMPTY AND LENGTH TO ZERO:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length:= 0;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> TRANSFORM SEQUENCE INTO NEXT SOLUTION:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXTEND WITH ZERO:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;length:= length + 1; d[length]:= 0;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> ADJUST:<u><br>						</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> d[length] = 3 <u>do</u> length:= length - 1;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d[length]:= d[length] + 1;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SET GOOD:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;good:= <u>true</u>; m:= 1; mbound:= length <u>div</u> 2;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>while</u> m </code>&#x2264;<code> mbound <u>and</u> good <u>do<br>						</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> GIVE GOOD THE MEANING THAT THE MSEQUENCES DIFFER:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;firstend:= length - m; k:= 0;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>repeat</u> good:= (d[length - k] </code>&#x2260;<code> d[firstend - k]);<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k:= k + 1;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> k = m <u>or</u> good;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;m:= m + 1<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end<br>						</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> good;<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PRINT:<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i:= 0; <u>repeat</u> i:= i + 1; printdigit(d[i]) <u>until</u> i = length; newline<br>						&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>until</u> length = 100<br>					</code><u><code>end</code></u> *&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>					*</p>				<p class="noindent"><u>Exercise</u>.</p>				<p>Given a linear array of 36 positions, make a program generating all ways (if any) in which these positions can be filled with zeros and ones (one digit per position), such that the 32 quintuples of five adjoining positions represent the 32 different patterns of five binary digits, restricting ourselves to sequences starting with five zeros. C. Ligtmans has shown that any such solution must end with four zeros. His argument is as follows. Each solution must start with <code>000001...</code>, because the pattern <code>00000</code> may occur only once. Somewhere in the sequence the pattern <code>10000</code> must occur once; as this pattern can only be followed by a <code>0</code> or a <code>1</code>, its ''following'' quintuple must be either <code>00000</code> or <code>00001</code>, presented already by the first two quintuples. As a result the pattern <code>10000</code> cannot occur in the interior of the linear sequence and therefore it must be the rightmost pattern. From Ligtmans' observation it follows that we can close the ring, making the last four zeros overlap with the four initial zeros. The different patterns are then arranged in a cycle of 32 positions.</p>				<p>The patterns have to be generated in alphabetical order.</p>				<p class="noindent">Discussion and some hints:</p>				<p>I take for granted that, given a sequence of 36 binary digits, the boolean function stating whether this sequence represents a solution is computable, and that we could write an algorithm computing it. In principle we could write a program generating all 36-digit sequences with five leading zeros in alphabetical order and subjecting all these sequences to the test just mentioned, thereby selecting those satisfying the test. This gives a very unrealistic program and we shall not pursue it; we only remark that generating the trial sequences in alphabetical order will ensure that the solutions, when found, will be found in alphabetical order as well.</p>				<p>The program to be made could be regarded as a derivation from the ridiculous one sketched above, viz. by the introduction of some significant short cuts. At present we shall not stress this relation any further.</p>				<p>Instead of generating all 36-digit sequences and selecting from this set, we aim at generating only a much smaller set which is guaranteed to contain all solutions. Let us define as ''length of sequence'' the number of quintuples it contains (i.e. <var>length</var> = <var>number of digits</var> <code>-</code> 4). Let us call a sequence ''acceptable'' if no two different quintuples in it present the same digit pattern. With these definitions the solutions are a subset of the set of acceptable sequences, viz. those with length = 32.</p>				<p>We do not know whether there are any solutions at all but we do know that the set of acceptable sequences is non-empty (e.g. ''<code>00000</code>''); we do not have a ready-made criterion to recognize ''the last solution'' when we encounter it; in our set of acceptable sequences, however, we can designate a virtual last one (viz. ''<code>00001</code>''<a href="#note">*</a>); when that one is encountered we know that all acceptable sequences with five leading zeroes have been scanned and that no further solutions will be found.</p>				<p>Summarizing, we know if the set of acceptable sequences:</p>				<ol>					<li>it is non-empty and finite					<li>we know a first member (''<code>00000</code>'')					<li>we know a virtual last member (''<code>00001</code>''<a href="#note">*</a>)					<li>we can transform an acceptable sequence into the next acceptable sequence					<li>solutions are all acceptable sequences satisfying the further condition length = 32					<li>no extension of a sequence that is not acceptable will be acceptable.				</ol>				&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The last property makes this problem mathematically speaking very similar to the previous one.				<p class="noindent"><u>Hint</u>. The test for acceptability can be speeded up considerably by tabulating which quintuplets are to be found in the sequence.</p>				<p class="noindent"><u>Remark</u>. This problem is difficult and it will take you many hours to produce a beautiful program. But these hours will be extremely well-spent.</p>				<p class="noindent"><a name="note"></a>[Note added to this transcription at the suggestion of Max Kohler: for the &quot;virtual last&quot; sequence read &quot;10000&quot;.]</p>				<p class="noindent"><a href="#contents">Back to top</a></p>				<p class="noindent">Next chapter: 7. <a title="Chapter 7 of EWD 316" href="EWD316.7.html">The shortest spanning subtree of a graph</a></p>				<p></p>			</div>			<hr />			<!-- name and date -->      <div id="footer">transcribed by Bert Put<br />revised <csobj format="MedDate" h="15" region="15" t="DateTime" w="106">Sun, 31 Aug 2008</csobj></div>    </div>  </body></html></x-html>