<!DOCTYPE html>
<html>
<head>
  <title>What Computing Science is about.</title>
  <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
  <link href="assets/common.css" rel="stylesheet">
  <link href="assets/transcriptions.css" rel="stylesheet">
  <meta name="generator" content="convertArticle.pl">
</head>
<body>
<div class="metabar">
  <div class="metabar-inner">
    <a href="index.html">HOME</a>
  </div>
</div>
<h1>What Computing Science is about.</h1>
<div class='body'><meta http-equiv="content-type" content="text/html;charset=ISO-8859-1"><title>E.W. Dijkstra Archive: What Computing Science is about. (EWD 1008)</title><link href="../transcriptions.css" rel="stylesheet" media="screen"><body><div id="frame">			<div id="header">        <a href="https://www.cs.utexas.edu/~EWD/ewd10xx/EWD1008.PDF"            title="Link to the PDF version of EWD 1008">EWD 1008</a>      </div><p class="noindent"><u>What Computing Science is about</u>.</p><p>When automatic computing equipment began to become available, it quickly became clear that the naive approaches of the day were grossly inadequate for the fruitful exploitation of the new technologies, and Departments of Computing Science were founded in response to that need. They were founded, however, prior to a consensus about what Computing Science as intellectual discipline should encompass. (During its first decade, Computing Science suffered, in fact, from an &quot;identity crisis&quot;.)</p><p>The discipline was in part shaped by the constraints of academic viability, in particular those of permanence and of coherence.</p><p>The requirement of permanence rules out all concerns whose loss of significance is foreseeable in the near future: hence, particular properties of equipment currently on the market could not be allowed to play any role.</p><p>Since automatic computing equipment truly deserves the characterization &quot;general purpose&quot;, whatever was specific to some application area had to be excluded: for the sake of its own coherence, Computing Science had to focus its attention on the application-independent aspects of automatic computing.</p><p>As time went by it became clear that, instead of &quot;automatic computing&quot;, the more general term &quot;automatic symbol manipulation&quot; was more appropriate. The act of automation, however, requires programming; programming evolved from a naive activity to the application of formal techniques, and program design itself became more and more a matter of symbol manipulation. Consequently, computing science found itself concerned with the interplay between automatic and human symbol manipulation.</p><p>This interplay has profound logical aspects &#x2014;such as decidability&#x2014; , but has been shaped in more detail by its quantitative aspects, which in more than one way are overwhelming.</p>		<p>Firstly, there is the question of what we leave to the automaton and what we do ourselves: it may be quite simple to state a desired result as the solution of a mechanically solvable equation, whose mechanical solution, however , would require the storage of more bits of information than there are atoms in the universe. (Also, even a computation that with current technology would take 1000 years is not very interesting.) In such cases some more human involvement is clearly indicated.</p>		<p>Secondly, if we view programming as the human formal labour done in order to keep the mechanical symbol manipulation within doable proportions, there is the urgent question of how to do our programming with enough efficiency.</p>		<p>There is no doubt that programming, viewed as a mathematical activity, has to be a very (if not totally) formal one. Mathematical theorems intended for human usage are appealed to in a modest frequency and, moreover, by mathematicians, who are wise enough not to appeal to a theorem in a situation in which it obviously does not hold. A programmer's theorem that a given repetition maintains a given invariant, however, is appealed to in high frequency ~ thanks to mechanization easily up to 1000 Hertz ~ and, moreover, these appeals take place without a wise mathematician as witness. In this sense, Programming = Mathematics + Murphy's Law. (The latter states &quot;Anything that can go wrong will go wrong&quot;.)</p>		<p>Hence, the required trustworthiness makes it mandatory that programs are derived formally. (I think it can be argued that computing scientists have been the first to make intensive, large-scale use of formal logic as an indispensable tool for their daily reasoning.) Viewed as formal objects, however, programs quickly become of an awesome size, representing big, and at the same time compact deposits of our intellectual labour. Hence the great stress on the efficiency with which the programmer does his part of the symbol manipulation.</p>		<p>Computing Science , therefore, finds itself confronted in full force with the problem of the economics of formal reasoning. This can be viewed as a long-standing problem of mathematical methodology, but the point is that in automatic computing it can no longer be ignored: there it becomes the central issue. In addition, the possibility of mechanization adds a totally new dimension to the cost/benefit analysis.</p>		<p class="noindent"><u>Historical Remark</u> The earlier computer applications were of an obviously repetitive nature: the payroll had to be done each month, and each month the size of the job was linear in the number of employees. What to mechanize was in those days a clear-cut problem. With mechanical proof verification, or a certain amount of mechanized reasoning as component of a general-purpose programming system, the decision what to mechanize is no longer obvious at all. A shift in ambition has caused a shift in perception. (End of Historical Remark.)</p>		<p>A final remark about the role to date of (formal) program derivation, since that role has been played down by the observation that relatively few new algorithms have been designed &#x2014;or &quot;discovered&quot;, if you are a Platonist&#x2014; that way. The new ones that were designed were way beyond the conceptual limits inherent in the traditional intuitive approach, but, more importantly, it has completely changed the intellectual status of many a published algorithm, viz. from an incompletely formulated or erroneous conjecture to a crisply stated and proven theorem.</p>		<div align="center">	<p>Pasadena, 25 May 1987</p></div><p class="noindent">prof. dr. Edsger W. Dijkstra<br>	Department of Computer Sciences<br>	The University of Texas at Austin<br>	Austin, TX 78712 - 1188<br>	United States of America</p><p class="noindent">[Written for Harvey Friedman]  </p>		<p class="noindent"></p>		<hr><p class="continue"><font size="-1">Transcribed by Mario B&Egrave;land .</font></p><p class="continue"><font size="-1">Last revised on <csobj format="MedDate" h="13" region="15" t="DateTime" w="96">Thu, 14 May 2009</csobj>.</font></p></body></div>
</body>
</html>
