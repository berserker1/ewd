  <!DOCTYPE html>
  <html>
  <head>
    <title>A simple consideration with far-reaching consequences</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <meta name="generator" content="convertArticle.pl">
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>A simple consideration with far-reaching consequences</h1>
  <div class='body'><!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head>
		<meta http-equiv="content-type" content="text/html;charset=ISO-8859-1">
		<meta name="generator" content="Adobe GoLive 6">
		<title>E.W.Dijkstra Archive: A simple consideration with far-reaching consequences. (EWD 571)</title>
		<style type="text/css">
         p { text-indent: 2.0em; }
        </style>
	</head>

	<body bgcolor="#ffffff">
		<div align="right">
			&nbsp;&nbsp;<a title="PDF scan of EWD 571" href="https://www.cs.utexas.edu/~EWD/ewd05xx/EWD571.PDF" target="_blank">EWD 571</a></div>
		<div align="left">
			<div>
				<u>
				DRAFT
</u>
				<p><u>A simple consideration with far-reaching consequences.</u></p>
				<blockquote>
					<blockquote>
						<blockquote>
							<table width="120%" border="0" cellspacing="2" cellpadding="0">
								<tr>
									<td>&quot;I believe that there will be no real progress until programmers learn to distinguish clearly between a language (definition) and its implementation in terms of compiler and computer. The former must be understood without knowledge of the latter. And we can only expect programmers to understand this vital distinction, if language designers take the lead [...]. Hence we conclude that the first criterion that any future programming language must satisfy, and that customers must ask for, is <em>a complete definition without reference to compiler or computer</em>.&quot;
										<blockquote>
											<blockquote>
												<p>Niklaus Wirth [1]</p>
											</blockquote>
										</blockquote>
									</td>
								</tr>
							</table>
						</blockquote>
					</blockquote>
				</blockquote>
				<p>
				</p>
				<p>In a truly decomposed system, as we have when a whole is regarded as composed of a number of parts, the composition defines how the relevant <em>properties</em> of the whole depend functionally on the explicitly postulated properties of the parts, a functional dependence which is given without <em>any</em> reference to the internal structure of the parts.</p>
				<p>For instance, when a mathematical proof of a theorem appeals to a lemma, it appeals to what a lemma <em>asserts</em>, and <em>not</em> to how the lemma has been proved; making the remainder of the proof of the theorem clearly independent of the specific way in which the lemma may have been proved is one of the main justifications for the lemma's introduction.</p>
				<p>Similarly, when a program in machine code contains a multiply instruction, its occurrence has to be justified by what the multiplier, when invoked, should achieve, regardless of how the multiplier happens to work. (No mathematician using a proven lemma will complain, when the known proof for that lemma is replaced by a more elegant one; similarly, no machine code programmer will complain when the multiplier in his machine is replaced by a new multiplier with, say, a lower heat dissipation.)</p>
				<p>The fact that the relevant properties of the whole depend in a defined way on the explicitly postulated properties of the parts has two important consequences.  Firstly &#x2014;as indicated above&#x2014; it creates the environment in which a correct part can be safely replaced by a different correct part, viz. provided that it has the same postulated properties.  Secondly, it localizes errors in the case of malfunctioning: either the desired properties of the whole do, in this composition, not follow from the postulated properties of the parts, in which case at least the upper level design needs revision, or the flaw can be pinpointed to the malfunctioning part(s), viz. each part that does not display the properties of which it has been postulated that it should have them.  Note that without true decomposition, we can at most observe that the whole does not have the desired properties, but that the question which of the parts is to be blamed, is void.  (More specifically: a program that has not been truly (de)composed is either correct or wrong: in the latter case it makes no sense to try to count &quot;the number of bugs&quot;.  For lack of &quot;bug identity&quot; the only defensible answer would be &quot;one&quot;.)</p>
				<p>There is an overwhelming experimental evidence that such a true (de)composition is indispensable for the design of a logical system above the level of simplicity such that it can be designed with a single stroke of the pen.  (If we take &#x2014;and I do&#x2014; the analogy with mathematics seriously, we can even add more than twenty centuries of experience.)  The experimental evidence is so overwhelming that I find it very hard to defend any design effort of some ambition that is tried without such an explicit, true (de)composition.</p>
			</div>
			<div align="center">
				*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>
				*</div>
			<div>
				<p>High-level programming languages certainly serve as the carriers of designs above the level of simplicity where a single stroke of the pen suffices, and in the whole system envisaged we can identify as &quot;a part&quot; the machinery that should be able to execute programs written in the high-level programming language used: that part has even a name, viz. the &quot;implementation&quot; of that language. (The significance of that part is considerably increased by the circumstance that it is common to many applications.) It is, therefore, indispensable to have an explicit statement of the relevant properties of that part, independent of its internal structure; we must have a statement of what that part should achieve, independent of how it might work. It is only then that the language user knows what he can rely upon and is in a position to prove that his design has all the relevant properties, it is only then that the language implementer knows his obligations and his freedom.</p>
			</div>
			<div align="center">
				*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>
				*</div>
			<div>
				<p>All this is so obvious that it is nearly embarrassing to write it down.  And, indeed, I would feel like flogging a dead horse were it not for the fact that the above conditions are more often violated than met, and that this status quo has even its defenders.</p>
				<p>From a historical point of view this is understandable.. Many programmers work with older programming languages, the semantics of which they can only appreciate via the language implementation they are daily working with. For lack of adequate definition they are seduced to mistake what the implementer has done for what the implementer should have accomplished, and to forget that deriving lacking specifications from a non-exhaustive set of explorations remains guesswork. They live in an environment where the strict distinction between (the definition of) a programming language and its implementation has never been carried through, and the suggestion that a crucial language requirement is that its semantics be defined without any reference to implementation details, without any reference to computers or compilers, would very well amaze (or perhaps even alarm) them.</p>
				<p>To make matters worse, a number of subsequent efforts at rigorous definition of programming language semantics have only added to the confusion, viz. all so-called &quot;operational&quot; language definitions that try to define semantics via an interpreter for that language. The definition of the semantics by means of an interpreting automaton is logically equivalent to defining a language entirely via a (standard) implementation. Without a formal technique for deriving from such an operational definition the language properties that the programmer needs to know, such a definition is useless: as it stands it gives us just enough grip on the language to perform for a given program and a chosen input a desk simulation! With a formal technique for deriving (all?) the relevant language properties, such an operational definition is at least cumbersome (because indirect), usually over specific, and certainly misleading. It is misleading because, of all the possible ways of implementing the language, a special one has been singled out as &quot;the defining implementation&quot;; it is also misleading because it fails to provide a definition independent of any computational model. Such a definition, however, is needed by the conscientious programmer who tries to separate his concern for program correctness from his concern for the costs of program execution.</p>
			</div>
			<div align="center">
				*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>
				*</div>
			<div>
				<p></p>
				<p>For nonoperational (also called &quot;postulational&quot; or &quot;axiomatic&quot;) definition methods see, for instance, Hoare [2].  To nonoperational methods two objections have been raised.  The first objection is in theory a serious one, but in practice it seems less so: the nonoperational methods allow us to define &quot;impossible&quot; programming languages, &quot;impossible&quot; in the sense that they defy implementation. The second objection I have heard is that the axiomatic method is only practicable in the case of simple and elegant programming languages. If &#x2014;what I fervently hope&#x2014; that statement is true, I cannot regard it as a shortcoming of the axiomatic method, on the contrary!</p>
			</div>
			<div align="center">
				*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>
				*</div>
			<div>
				<p>The above has been written because, once a necessary condition for progress has been identified, it seems such a pity and such a waste when it remains for so many people unfulfilled.</p>
				<table width="100%" border="0" cellspacing="2" cellpadding="0">
					<tr>
						<td align="left" valign="top">[1]&nbsp;&nbsp;&nbsp;</td>
						<td align="left" valign="top">Wirth, Niklaus &quot;Programming Languages: what to demand and how to assess them.&quot; Bericht 17 des Institute f&#x00FC;r Informatik, ETH Z&#x00FC;rich, March 1976. (Presented at the Symposium on Software Engineering, Belfast, 8&#x2013;9 April, 1976.)<br>
							&nbsp;</td>
					</tr>
					<tr>
						<td align="left" valign="top">[2]&nbsp;&nbsp;&nbsp;</td>
						<td align="left" valign="top">Hoare, C.A.R. &quot;An Axiomatic Basis for Computer Programming.&quot; <i>Comm. ACM 12</i>, 10 (Oct. 1969), 576&#x2013;583.</td>
					</tr>
				</table>
				<p></p>
			</div>
		</div>
		<div align="left">
			<table width="459" border="0" cellspacing="2" cellpadding="0">
				<tr>
					<td valign="top" width="203">
						Plataanstraat 5<br>
						5671 AL NUENEN<br>
						The Netherlands</td>
					<td valign="top" width="250">prof.dr.Edsger W.Dijkstra<br>
						Burroughs Research Fellow</td>
				</tr>
			</table>
			<p></p>
		</div>
		<hr>
		<font size="-1">transcribed by Tristram Brelstaff<br>
			revised <csobj format="MedDate" h="13" region="15" t="DateTime" w="92">Wed, 17 Jan 2007</csobj></font>
	</body>

</html></div>
  </body>
  </html>
