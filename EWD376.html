  <!DOCTYPE html>
  <html>
  <head>
    <title>Finding the maximum strong components in a directed graph</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <link href="assets/tweet-selection.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.12.0.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="assets/tweet-selection.js"></script>
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: Finding the maximum strong components in a directed graph" />
    <meta name="twitter:title" content="Finding the maximum strong components in a directed graph" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>Finding the maximum strong components in a directed graph</h1>
  <a class='original' href='https://www.cs.utexas.edu/~EWD/ewd37xx/EWD376.PDF'><img src='assets/original.png' alt='Show original manuscript'></a>
  <div class='body'>
<hr>
<p class="noindent">NOTE: This transcription was contributed by Martin P.M. van der Burgt, who has devised a process for producing transcripts automatically. Although its markup is incomplete, we believe it serves a useful purpose by virtue of its searchability and its accessibility to text-reading software. It will be replaced by a fully marked-up version when time permits. —HR</p>
<hr>
<p class="noindent" style="margin-bottom: 0.5cm">&nbsp;</p>
<p class="noindent" style="margin-bottom: 0.5cm"><font face="Arial Black, sans-serif"><b>Copyright Notice</b></font></p>
<p class="noindent" style="margin-bottom: 0.5cm"><font face="Arial, sans-serif"><font size="2">The following manuscript</font></font></p>
<p style="margin-bottom: 0.5cm"><font face="Arial, sans-serif"><font size="2">EWD 376: Finding the maximum strong components in a directed graph</font></font></p>
<p class="noindent" style="margin-bottom: 0.5cm"><font face="Arial, sans-serif"><font size="2">is held in copyright by Springer-Verlag New York.</font></font></p>
<p class="noindent" style="margin-bottom: 0.5cm"><font face="Arial, sans-serif"><font size="2">The manuscript was published as pages 22–30 of</font></font></p>
<p style="margin-bottom: 0.5cm"><font face="Arial, sans-serif"><font size="2">Edsger W. Dijkstra, Selected Writings on Computing: A Personal Perspective,</font></font></p>
<p style="margin-bottom: 0.5cm"><font face="Arial, sans-serif"><font size="2">Springer-Verlag, 1982. ISBN O–387–90652–5.</font></font></p>
<p class="noindent" style="margin-bottom: 0.5cm"><font face="Arial, sans-serif"><font size="2"><b>Reproduced with permission from Springer-Verlag New York.<br>
Any further reproduction is strictly prohibited.</b></font></font> <font size="2">.</font></p>
<b>Finding the maximum strong components in a directed graph.</b>
<p>This essay records an exercise in orderly program composition. The record is not completely truthful in the sense that prior to its writing some thinking without pencil and paper was done. As a result, the following text contains a few “surprises” in the sense that suggestions are made without an elaborate heuristic justification. When I noticed myself doing so, some heuristic justification has been added afterwards. The moral of all this is: in case of surprise, please go on reading!</p>
<p>Given a set of nodes and a set of directed arcs leading from a node to a node, it is requested to partition the set of nodes into maximal strong components. A strong component is a set of nodes such that the arcs between them provide a path from any node of the set to any node of the set; a single node is a special case of a strong component: then the path can be empty. A maximal strong component is a strong component to which no nodes can be added.</p>
<p>We shall use the acronym “sa” for a set of arcs, the acronym “sn” for a set of nodes. Our final answer is a partitioning, that is a set of sets of nodes with empty intersections: for that latter object we shall use the acronym “ssn”. Similarly, when the need arises, we shall use the acronym “ssa”for a set of sets of arcs with empty intersection. (Note added while typing out the manuscript: this need has not arisen.)</p>
<p>Let “sn” be the given set of nodes, let “sa” be the given set of arcs. Let the final value of “ssn” be the desired answer. We then write the desired final relation as</p>
<table>
<tr>
<td valign="top" width="20%"></td>
<td valign="top" width="80%">ssn = MSC(sa)</td>
<td>(1)</td>
</tr>
</table>
<p class="noindent">where MSC, the set of Maximal Strong Components, is regarded for constant sn as a function of the set of arcs sa.</p>
<p>We want to inspect the arcs one by one (in a suitable order still to be chosen), i.e. we introduce two disjoint subsets of sa, viz. sa1 and sa2, such that</p>
<table>
<tr>
<td valign="top" width="20%"></td>
<td valign="top" width="80%">sa = sa1 + sa2</td>
<td>(2)</td>
</tr>
</table>
<p class="noindent">where sa1 comprises the arcs inspected (initially empty, finally = sa) and sa2 the arcs uninspected (initially = sa, finally empty)</p>
<p>Similarly, we want to build up the final value of ssn. We shall do so by maintaining the invariant relation</p>
<table>
<tr>
<td valign="top" width="20%"></td>
<td valign="top" width="80%">ssn + ssn1 = MSC(sa1)</td>
<td>(3)</td>
</tr>
</table>
<p class="noindent">Here each node of sn will either occur in an element of ssn or in an element of ssn1, but never in both. (Besides that we can, as will be shown later, restrict ourselves to ssn1-values being sets of sets of single nodes.) The following idea was underlying the introduction of ssn1: ssn is a set of maximal strong components, for which -we write an algorithm for a sequential machine!- we may expect to establish one after the other that they will occur as element of the final value of ssn. Our aim is that at any moment in time, ssn will only contain elements of its final value: they are the maximal strong component definitely found. Then we need ssn1 for the remaining nodes.</p>
<p>The initialization corresponding to sa1 = empty is ssn = empty and ssn1 with each node of sn in a separate element of ssn1. When we succeed in establishing</p>
<table>
<tr>
<td valign="top" width="20%"></td>
<td valign="top" width="80%">ssn1 = empty and sa2 = empty</td>
<td>(4)</td>
</tr>
</table>
<p class="noindent">under invariance of (3), the desired relation (1) has been established, as the second term of (4) implies on account of (2) that sa = sa1.</p>
<p>We have not established yet the relation between the way in which the nodes are divided over ssn and ssn1 on the one hand and the arcs over sa1 and sa2 on the other. We shall maintain the following relations (5) and (6):</p>
<table>
<tr>
<td valign="top" width="20%"></td>
<td valign="top" width="80%">each arc originating in a node of ssn will be in sa1</td>
<td>(5)</td>
</tr>
<tr>
<td valign="top"></td>
<td valign="top">each arc terminating in a node of ssn1 will be in sa2 .</td>
<td>(6)</td>
</tr>
</table>
<p>Relations (5) and (6) are compatible with the initial situation: because ssn = empty, there will be no arcs originating in a node of ssn and therefore sa1 can be empty (i.e. (5) is not violated) and because ssn1 comprises all nodes, all arcs should be in sa2, in accordance with the initial condition sn2 = sa (i.e. (6) is satisfied).</p>
<p>Relations (5) and (6) are also compatible with the final situation: because then ssn will comprise all nodes, all arcs must be in sa1, in accordance with sa1 = sa (i.e. (5) is satisfied) while (6) is satisfied because then both ssn1 and sa2 will be empty (see (4)).</p>
<p>We observe that, because sa1 and sa2 have an empty intersection, there will be no arcs originating in a node of ssn and terminating in a node of ssn1. On the other hand, an arc originating in a node of ssn1 and terminating in a node of ssn may be either in sa1 or in sa2.</p>
<p>The structure of our program becomes, if we want to apply the fundamental invariance theorem for loops:</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="3">sa1:= empty; sa2:= sa;</td>
</tr>
<tr>
<td></td>
<td colspan="3">ssn:= empty; ssn1:= “the set of all single node sets”;</td>
</tr>
<tr>
<td></td>
<td colspan="3"><b>while</b> ssn1 ≠ empty <b>or</b> sa2 ≠ empty <b>do</b></td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2">“transfer arc(s) from sa2 to sa1” and/or</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2">“transfer node(s) from ssn1 to ssn”</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="2">under invariance of (3), (5) and (6)</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td><b>od</b></td>
</tr>
</table>
<p>Relation (5) allows us to simplify the last boolean expression: ssn1 = empty implies that all nodes are in ssn; this implies that all arcs are in sa1, which implies that sa2 = empty. Therefore it can be simplified to</p>
<p><b>while</b> ssn1 ≠ empty <b>do</b> .</p>
<p>Relations (5) and (6), which may have come as a surprise, have been suggested by</p>
<p class="noindent"><b>Theorem 1</b>. When the set of nodes are subdivided into two sets nsA and nsB, such that there are no arcs originating in a node of nsA and terminating in a node of nsB, then the set of strong components is unchanged when the arcs (if any) originating in a node of nsB and terminating in a node of nsA are removed and, secondly, no strong component comprises nodes from both sets.</p>
<p>Here the nodes in ssn play the role of those in snA and Theorem 1 tells us that the maximal strong components they will give rise to cannot depend on the arcs still in sa2. Therefore they can only depend on the arcs in sa1 that have already been inspected. As a result each element (i.e. a maximal strong component) of an intermediate value of ssn will be an element of its final value.</p>
<p>In order to detail the repeatable statement we introduce a chain of strong components (a chain of sets of nodes), called “csn”; empty at the beginning and at the end of the repeatable statement. The transfer of a node from ssn1 to ssn will take place in two steps: first the node will be transferred (individually) from ssn1 to csn, at a later stage the node will be transferred (together with all the nodes of the same maximal strong component) from csn to ssn.</p>
<p>The strong components in csn are so by virtue of arcs of sa1 and their chaining is performed by arcs of sa1, more precisely two successive strong components in csn are connected by <b>one</b> arc from sa1 originating in a node of the predecessor and terminating in a node of the successor</p>
<table width="100%">
<tr>
<td valign="top" width="10%"></td>
<td valign="top">&nbsp;</td>
<td align="right">(7)</td>
</tr>
</table>
<p class="noindent">no arc in sa1 will originate at a node of an element of csn and terminate at a node of a preceding element in csn .</p>
<table width="100%">
<tr>
<td valign="top" width="10%"></td>
<td valign="top">&nbsp;</td>
<td align="right">(8)</td>
</tr>
</table>
<p>The chain csn has been introduced as a tool for the searching for cycles, an activity that is suggested by</p>
<p class="noindent"><b>Theorem 2</b>. When a number of strong components can be connected via a cyclic path, they belong to the same maximal strong component.</p>
<p>This theorem suggests that we try to extend the chain at one end: whenever we encounter an arc leading from its end element to a preceding element in the chain, from and including that preceding element up to and including the terminal element can be combined to form the new terminal element. We shall call this operation “combine end elements of csn”; its purpose is to restore the validity of (8).</p>
<p>When the chain csn is non-empty, we investigate whether sa2 contains an arc f having its origin in (one of the nodes of) the terminal element of csn. If such an arc f points to one of the nodes in ssn, it can be ignored (on account of Theorem 1). If such an arc f points to a node in the terminal element of csn, it can be ignored as well we knew already that the nodes in this terminal element formed a strong component. If such an arc points to (a node in) a preceding element of csn, the end elements of csn are combined. If such an arc leads to a node in ssn1, that node is appended to the chain and will form, all by itself, the new terminal element of csn. In all four cases the arc t is transferred from sa2 to sa1.</p>
<p>If no such arc exists, the terminal element of the chain must be a maximal strong component of the final graph, will be removed from csn and added to ssn, which now grows by one element. This conclusion, again, is justified by Theorem 1. (Note. Here Theorem 1 is applied twice: the terminal node is a maximal strong component because it has no outgoing arcs in the reduced graph that we get by removing all arcs leading back to a node of ssn after it has been established that ssn already contains maximal strong components for the total graph.)</p>
<p>The structure of the repeatable statement -only starting when the chain csn = empty and ssn1 ≠ empty can be the following:</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="7">transfer an arbitrary element of ssn1 and append it to an</td>
</tr>
<tr>
<td></td>
<td colspan="7">initially empty chain csn;</td>
</tr>
<tr>
<td></td>
<td colspan="7"><b>while</b> csn ≠ empty <b>do</b></td>
</tr>
<tr>
<td></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="6"><b>if</b> sa2 contains no arc f originating in a node of csn’s terminal</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp; &nbsp;</td>
<td colspan="5">element</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td colspan="5"><b>then</b> transfer csn’s terminal element to ssn</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td colspan="5"><b>else</b> transfer such an arc f from sa2 to sa1;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="4"><b>if</b> f terminates in (a node of) an element of ssn1</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td colspan="3"><b>then</b> transfer that element from ssn1 by appending it to csn</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="3"><b>else</b> <b>if</b> f leads to (a node of) a preceding element of csn</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td><b>then</b> combine end elements of csn</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td colspan="2"><b>fi</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="4"><b>fi</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="6"><b>fi</b></td>
</tr>
<tr>
<td></td>
<td colspan="7"><b>od</b></td>
</tr>
</table>
<p>We have now to choose a way for representing the information. It is assumed that the nodes are numbered from 1 through N. Because we intend to chain nodes, it is a wise precaution to add “a virtual node” with number 0.</p>
<p>In the representation of our sets of nodes we can exploit the fact that we know that the elements of ssn1 are single node sets. In ssn and csn our elements are strong components, in csn we can number them from +1 upwards, in ssn we can number them from -1 downwards and thus we come to the following representation with an integer array sn[0:N]</p>
<table>
<tr>
<td>sn[i] &gt; 0 means: node i is a member of element sn[i] of csn</td>
</tr>
<tr>
<td>sn[i] &lt; 0 means: node i is a member of element sn[i] of ssn</td>
</tr>
<tr>
<td>sn[i] = 0 means: node i is (a node of) an element of ssn1</td>
</tr>
<tr>
<td>sn[0] = 0 .</td>
</tr>
</table>
<p>In order to scan nodes we introduce for nodes in csn or ssn an integer array pc[1:N], where for node i in one of the two sets of sets</p>
<table>
<tr>
<td valign="top" width="20%">pc[i]= j means:</td>
<td>with respect to node i, node j is the next oldest node in the same set of sets; when j = 0, node i is its oldest node.</td>
</tr>
</table>
<p>In order to be able to trace these pc-chains we introduce two handles:</p>
<table>
<tr>
<td valign="top" width="10%">yc =</td>
<td>the number of the youngest node in csn; when csn = empty, yc = 0</td>
</tr>
<tr>
<td valign="top">ys =</td>
<td>the number of the youngest node in ssn; when ssn = empty, ys = 0 .</td>
</tr>
</table>
<p>In order to speed up the search for an arbitrary node in ssn1 for the initialization of csn, we introduce the integer k, such that ssn1 contains no nodes with a number &lt; k.</p>
<p>Further we introduce, in order to be able to fix the ordinal number of a new element</p>
<table>
<tr>
<td valign="top" width="10%">ec =</td>
<td>the number of elements in csn</td>
</tr>
<tr>
<td valign="top">es =</td>
<td>the number of elements in ssn</td>
</tr>
</table>
and, in order to decide whether ssn1 is empty
<table>
<tr>
<td valign="top" width="10%">es1 =</td>
<td>the number of elements in ssn1.</td>
</tr>
</table>
<p>In our program we have to establish whether sa2 contains an arc f originating from the terminal element of csn. We do so by investigating the nodes of the terminal element and on account of the pc-chaining we do so in order of increasing age in csn. Because quite a number of nodes may be a member of the terminal element it seems a bit wasteful in time to start this search always at the youngest node and therefore we introduce</p>
<table>
<tr>
<td valign="top" width="10%">yun =</td>
<td>the number of “the youngest possibly unexhausted node” i.e. sa2 contains no arcs originating in a node of csn younger than nr. yun (if any). Again, in the extreme ease, yun may get the value 0.</td>
</tr>
</table>
<p>Our algorithm presupposes that for each node we can find “its outgoing arcs”. We therefore assume that the arcs are sorted in the order of increasing starting node and that in that order their terminal nodes are listed in the global integer array t[1:number of arcs] while the boundaries are given by the integer array b[0:N], such that b[0]= 0, b[N] = number of arcs and the nodes at which the arcs originating at node i terminate will be t[k], with k ranging</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>b[i-1] &lt; k &lt; b[i] .</td>
</tr>
</table>
<p>For the representation of the partitioning sa = sa1 + sa2 we introduce</p>
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td><b>integer</b> <b>array</b> c[0:N]</td>
</tr>
</table>
such that all arcs originating in node i and belonging to sa1 will have an ordinal number k satisfying
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>b[i1] &lt; k ≤ c[i]</td>
</tr>
</table>
and those in sa2 a k satisfying
<table>
<tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td>c[i] &lt; k ≤ &lt; b[i] .</td>
</tr>
</table>
We assume c[0] = 0 for the sake of safety (i.e. sa2 contains no arcs originating from the virtual node).
<p>In the following program the variable ft is used to identify the terminal node of arc f, while the variable h is used for a wild collection of short range purposes. I know that this is a poor style: I too have my weak moments!</p>
<table>
<tr>
<td colspan="24"><b>begin</b> <b>integer</b> <b>array</b> sn, c [0 : N], pc [1 : N];</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td colspan="19"><b>integer</b> yc, ys, ec, es, es1, yun, h, ft, k;</td>
</tr>
<tr>
<td></td>
<td>&nbsp;</td>
<td colspan="22">{initialize sa1 and sa2}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="19">c[0]:= 0; h:= 0; <b>while</b> h &lt; N <b>do</b> h:= h + 1; c[h]:= b[h-1] <b>od</b>;</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="22">{initialize ssn and ssn1}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="19">h := 0; <b>while</b> h ≤ N <b>do</b> sn[h] := 0; h := h +1 <b>od</b>;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="19">ys:= 0; es:= 0; es1:= N; k:= 1;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="19"><b>while</b> es1 &gt; 0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="19"><b>do</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td colspan="20">{search for a node k in ssn1}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td colspan="17"><b>while</b> sn[k] ≠ 0 <b>do</b> k:=k+1 <b>od</b>;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="20">{remove it from ssn1 and initialize csn with node k}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="17">es1:= es1 - 1; sn[k]:= 1;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="17">pc[k]:= 0; yc:= k; ec:= 1; yun:= k;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="20">{note that at this moment node k is oldest and youngest and youngest</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="19">possibly unexhausted node of csn}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="17"><b>while</b> ec &gt; 0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="17"><b>do</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td colspan="18">{search for the youngest unexhausted node of the terminal element</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="17">of csn}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td colspan="15"><b>while</b> sn[yun] = ec <b>and</b> c[yun] ≥ b[yun] <b>do</b> yun:= pc[yun] <b>od</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="18">{this loop will certainly terminate, possibly with yun = 0};</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="15"><b>if</b> sn[yun] ≠ ec</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td colspan="14"><b>then</b> {there is no arc f in sa2 originating in the terminal</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td colspan="12">element nr. ec of csn and therefore this terminal element</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="12">will be transported to ssn]</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td colspan="10">es:= es + 1;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="10"><b>while</b> sn[yc] = ec</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="10"><b>do</b> sn[yc]:= - es: h:= pc[yc]; pc[yc]:= ys;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td colspan="8">ys:= yc; yc:= h;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="10"><b>od</b>;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="10">ec:= ec - 1; yun:= yc</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="14"><b>else</b> { c[yun] &lt; b[yun], therefore the next arc originating at</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="12">node nr. yun will be transferred from sa2 to sa1; this is arc f}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="10">c[yun]:= c[yun] + 1; ft:= t[c[yun]]; h:= sn[ft];</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td colspan="13">{now ft is the terminal node of arc f and h = sn[ft] to save</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="12">dynamically a few subscriptions}!</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td colspan="11"><b>if</b> h = 0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td colspan="9"><b>then</b> {node ft has to be removed from ssn1 and to be</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td colspan="7">attached to csn}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td colspan="6">es1:= es1 - 1; ec:= ec + 1; sn[ft]:= ec;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="6">pc[ft]:= yc; yc:= ft; yun:= yc</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="9"><b>else</b> <b>if</b> 0 &lt; h <b>and</b> h &lt; ec</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td colspan="5"><b>then</b> {ft is a node of the non-terminal element</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td colspan="3">nr. h of csn, with which the younger elements</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="3">have to be combined}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td colspan="2">ec:= h</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td colspan="4">{this ends the use of h as h = sn[ft]};</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="2">h:= yc; <b>while</b> sn[h] &gt; ec</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</td>
<td><b>do</b> sn[h]:= ec; h:= pc[h]</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td><b>od</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="4">{ note that in combining, pc, yr: and yun can</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="3">remain unchanged]</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="5"><b>else</b> {arc f points either to csn’s terminal</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="3">element or to an element of ssn; in either</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="3">case it can be ignored}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="6"><b>fi</b></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="11"><b>fi</b> {the case that arc f existed has been dealt with}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>&nbsp;</td>
<td colspan="16"><b>fi</b> {csn’s terminal element has been inspected]</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="19"><b>od</b> {csn is again empty}</td>
</tr>
<tr>
<td></td>
<td></td>
<td>&nbsp; &nbsp;</td>
<td colspan="21"><b>od</b> {ssn1 is empty, the computation has been done};</td>
</tr>
<tr>
<td>&nbsp;</td>
<td colspan="23">{print the results; the maximal strong Components appear numbered in</td>
</tr>
<tr>
<td></td>
<td></td>
<td colspan="22">decreasing order}</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td colspan="21"><b>while</b> es &gt; 0</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td colspan="21"><b>do</b> newline; printtext(“maximal strong component nr.”);</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="18">printvalue(es); printtext(“consists of the nodes:”);</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="18"><b>while</b> sn[ys] = - es <b>do</b> printvalue(ys); ys:= pc[ys] <b>od</b>;</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td colspan="18">es:= es -1</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td colspan="21"><b>od</b></td>
</tr>
<tr>
<td colspan="24"><b>end</b></td>
</tr>
</table>
<p class="noindent"><b>Concluding remarks</b>.</p>
<p>In order to avoid the usual misunderstandings it might be a good thing to point out, once again, that the approach that has been illustrated in this exercise does not pretend to be an infallible cure against fallibility We have tried two things: we have tried to develop a program in a way that leads to a higher confidence level than the one that can he reached when the designer “rushes into coding” and we have tried to make the reader share our conviction strengthened by the above experience! that the simultaneous development of the correctness proof gives indeed a strong heuristic guidance in the process of shaping the program.</p>
<p>As the reader will have noticed we have not spent a single word of explanation on the repeatable statement of the small innermost loops. I think that this is in accordance with normal mathematical practice: the reasoning has to be broken down in steps so small that they can be made “in confidence” and that a more detailed proof, a more detailed justification could be given when they are challenged, but that that should not be done without compelling reason. We should not waste our time on trivia!</p>
<p>The situation at the innermost loops, where we deal with quite standard coding techniques, is quite different from the situation at the outermost levels where we have to manipulate with concepts and relations cooked up and discovered for the specific purpose of solving this specific problem: it is at the latter level that the greater explicitness seems most urgently needed. Also, it is in that part of the analysis and synthesis that the most heavy demands are made upon the programmer’s ability to express himself effectively.</p>
<p>Finally we draw attention to the fact that we did not need a single example to explain what we were talking about or (even worse!) to discover what the program should do. And this, of course, is as it should have been.</p>
<p class="noindent"><b>Acknowledgements</b>. We express our gratitude towards J.A.G.M. Kelbosch and J.C. Wortmann for bringing this problem to our attention and thereby presenting the challenge.</p>
<p class="noindent">30th May 1975 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Edsger W.Dijkstra</p>
<hr>
<p class="noindent"><font size="-1">Transcribed by Martin P.M. van der Burgt<br>
Last revision <!-- #BeginDate format:IS1 -->2014-11-07<!-- #EndDate -->
 .</font></p>
</div>
  <script>
$('.body').tweetSelection({
  ellipsis: '...',
  quoteLeft: '\'',
  quoteRight: '\'',
  via: 'raboofje'
});
  </script>
  </body>
  </html>
