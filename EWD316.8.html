  <!DOCTYPE html>
  <html>
  <head>
    <title>A Short Introduction to the Art of Programming (EWD 316), Chapter 8</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <meta name="generator" content="convertArticle.pl">
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>A Short Introduction to the Art of Programming (EWD 316), Chapter 8</h1>
  <div class='body'>				<div id="frame">					<div id="header">						<div align="center">							<p>EWD316: A Short Introduction to the Art of Programming</p>							<p>by</p>							<p>prof.dr.Edsger W.Dijkstra</p>							<p>August 1971</p>						</div>						<div align="left">							<p class="noindent"><a name="contents"></a><u>Contents</u></p>							<div id="frame">								<div id="header">									<blockquote>										<div align="left">											<div id="frame">												<div id="content">													<blockquote>														<div align="left">															<p class="noindent">0. Contents</p>															<p class="noindent">1. <a title="Chapter 1 of EWD 316" href="EWD316.html">Preface</a><br>																<br>																2. <a title="Chapter 2 of EWD 316" href="EWD316.2.html">Some Fundamental Notions</a><br>																<br>																3. <a title="Chapter 3 of EWD 316" href="EWD316.3.html">Programming Languages and their Implementation</a><br>																<br>																4. <a title="Chapter 4 of EWD 316" href="EWD316.4.html">Variables and relations between their values</a><br>																<br>																5. <a title="Chapter 5 of EWD 316" href="EWD316.5.html">Programs corresponding to recurrence relations</a><br>																<br>																6. <a title="Chapter 6 of EWD 316" href="EWD316.6.html">A first example of step-wise program composition</a><br>																<br>																7. <a title="Chapter 7 of EWD 316" href="EWD316.7.html">The shortest spanning subtree of a graph</a><br>																<br>																8. The towers of Hanoi<br>																<br>																9. <a title="Chapter 9 of EWD 316" href="EWD316.9.html">The problem of eight queens</a><br>																<br>																10. <a title="Chapter 10 of EWD 316" href="EWD316.10.html">A rearranging routine</a></p>														</div>													</blockquote>												</div>											</div>										</div>									</blockquote>								</div>							</div>						</div>					</div>				</div>				<p class="noindent">8. <u>The towers of Hanoi</u></p>				<p>Given three pegs, numbered 1, 2 and 3 and a set of <i>N</i> disks (<i>N</i> <u>&gt;</u> 1) of decreasing diameter and a hole in their centre. At the beginning the <i>N</i> disks are all on peg nr.1 in order of decreasing diameter, i.e. the largest disk is at the bottom, the smallest is at the top side of the first peg. The problem is to move this tower from the first peg to the third one in a number of &quot;moves&quot;, where a &quot;move&quot; is moving one disk from the top of a peg to the top of another peg with the restriction that a larger disk may never be placed on top of a smaller one. The second peg may be used as auxiliary &quot;store&quot; for pegs which are &quot;in the way&quot;.</p>				<p>Now, if we can solve this game for any two pegs for <i>N</i> = <i>N</i><sub>0</sub>, we can also solve it for <i>N&nbsp;</i>=&nbsp;<i>N</i><sub>0</sub>&nbsp;+&nbsp;1 . Call</p>				<blockquote>					<p class="noindent">movetower (<i>m</i>, <i>A</i>, <i>B</i>, <i>C</i>)<br>					</p>				</blockquote>				<p class="noindent">the set of moves that transports a tower of <i>m</i> disks from peg <i>A</i> (if necessary via peg <i>B</i>) to peg <i>C</i>. The individual moves are of the form</p>				<blockquote>					<p class="noindent">movedisk(<i>P</i>, <i>Q</i>)  . <br>					</p>				</blockquote>				<p>The set of moves</p>				<blockquote>					<p class="noindent">movetower (<i>N</i><sub>0</sub> + 1, <i>A</i>, <i>B</i>, <i>C</i>) <br>					</p>				</blockquote>				<p class="noindent">is the same as that of the successive moves of</p>				<blockquote>					<p class="noindent">movetower (<i>N</i><sub>0</sub>, <i>A</i>, <i>C</i>, <i>B</i>)<br>						movedisk (<i>A</i>, <i>C</i>)<br>						movetower (<i>N</i><sub>0</sub>, <i>B</i>, <i>A</i>, <i>C</i>)  .<br>					</p>				</blockquote>				<p>In words: first a tower of <i>N</i><sub>0</sub> disks is moved from <i>A</i> to <i>B</i>, using <i>C</i> as auxiliary peg, then the <i>N</i><sub>0</sub>&nbsp;+&nbsp;1st disk is moved directly from <i>A</i> to <i>C</i> and finally the tower of <i>N</i><sub>0</sub>, that has been placed temporarily on peg <i>B</i> is moved to its final destination <i>C</i>, using <i>A</i> as auxiliary peg. As the tower consists of the <i>N</i><sub>0</sub> smallest disks, the presence of larger disks will not cause violation of the condition of decreasing disk diameter. Moving a one-disk tower (<i>N</i><sub>0</sub> = 1) presents no difficulty and as a result the puzzle has been solved. The question posed to us, however, is to make a program generating disk moves in the order in which they have to take place.</p>				<p class="noindent"><u>Note.</u> It is not realistic to demand the execution of this program for large values of <i>N</i> because the total number of moves required = 2<i><sup>N</sup></i>&nbsp;&#150;&nbsp;1. Prove this and prove also that the puzzle cannot be solved in a smaller number of moves.</p>				<p>The fact that a move with <i>N</i> &gt; 1 is decomposed into three &quot;smaller&quot; moves, suggests that we keep a list of moves to be done. If the first one to be done is simple, we do it; otherwise we replace it by its decomposition and reconsider our obligations. In both cases, when we have a list of <i>k</i> moves, only the first to be made needs consideration, and while we process it, the remaining <i>k</i>&#150;1 moves remain as standing obligations. This suggests that we introduce</p>				<blockquote>					<p class="noindent">move<i><sub>k</sub></i>, move<i><sub>k</sub></i><sub>-1</sub>, ... , move<sub>2</sub>, move<sub>1</sub><br>					</p>				</blockquote>				<p class="noindent">to be done in the order of decreasing subscript, in the order from left to right. If move is simple, it is made, leaving</p>				<blockquote>					<p class="noindent">move<i><sub>k</sub></i><sub>'=</sub><i><sub>k</sub></i><sub>-1</sub>, ... , move<sub>2</sub>, move<sub>1</sub><br>					</p>				</blockquote>				<p class="noindent">(indicating with <i>k</i>' the new value of <i>k</i>, the length of our list of standing obligations) otherwise move<i><sub>k</sub></i>, is <u>replaced</u> by three others, leaving</p>				<blockquote>					<p class="noindent">move'<i><sub>k</sub></i><sub>'=</sub><i><sub>k</sub></i><sub>+2</sub>, move'<i><sub>k</sub></i><sub>'-1=</sub><i><sub>k</sub></i><sub>+1</sub>, move'<i><sub>k</sub></i><sub>'-2=</sub><i><sub>k</sub></i>, move<i><sub>k</sub></i><sub>'-3=</sub><i><sub>k</sub></i><sub>-1</sub>, ... , move<sub>2</sub>, move<sub>1</sub><br>					</p>				</blockquote>				<p>In both transformations the lower (i.e. later) <i>k</i>&#150;1 moves have been unaffected.</p>				<p>A move is given by four parameters, say<br>					<br>				</p>				<table width="403" border="0" cellspacing="0" cellpadding="0">					<tr>						<td><i>n</i></td>						<td align="center" width="40">=</td>						<td>number of disks in the tower to be moved</td>					</tr>					<tr>						<td><i>from</i></td>						<td align="center" width="40">=</td>						<td>number of source peg</td>					</tr>					<tr>						<td><i>via</i></td>						<td align="center" width="40">=</td>						<td>number of auxiliary peg</td>					</tr>					<tr>						<td><i>to</i></td>						<td align="center" width="40">=</td>						<td>number of destination peg.</td>					</tr>				</table>				<p>We can store these moves in four arrays &quot;<u>integer</u> <u>array</u> <i>n</i>, from, via, to [1:2*<i>N</i>&#150;1]&quot;. (Verify that the list of obligations is never longer than 2*<i>N</i>&#150;1 moves.) The non-simple move (with <i>N</i>&gt;1), given in tabular form by</p>				<p class="noindent"></p>				<table width="85%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td width="25%"></td>						<td><i>n</i> =</td>						<td><i>from</i> =</td>						<td><i>via</i> =</td>						<td><i>to</i> =</td>					</tr>					<tr>						<td width="25%"><i>k</i>:</td>						<td><i>N</i> </td>						<td><i>A</i></td>						<td><i>B</i> </td>						<td><i>C</i></td>					</tr>				</table>				<p class="noindent">is to be replaced by the triple<br>					<br>				</p>				<table width="85%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td width="25%"></td>						<td><i>n</i>' =</td>						<td><i>from</i>' =</td>						<td><i>via</i>' = </td>						<td><i>to</i>' =</td>					</tr>					<tr>						<td width="25%"><i>k</i>'-2 = <i>k</i>:</td>						<td><i>N</i>-1</td>						<td><i>B</i></td>						<td><i>A</i></td>						<td><i>C</i></td>					</tr>					<tr>						<td width="25%"><i>k</i>'-1 = <i>k</i>+1:</td>						<td>1</td>						<td><i>A</i></td>						<td>(<i>B</i>)</td>						<td><i>C</i></td>					</tr>					<tr>						<td width="25%"><i>k</i>'   = <i>k</i>-2:</td>						<td><i>N</i>-1</td>						<td><i>A</i></td>						<td><i>C</i></td>						<td><i>B</i></td>					</tr>				</table>				<p class="noindent">in which the top line replaces the original one, while the next two lines are new. (In the middle line the element &quot;via&quot; has been put between brackets, as it is immaterial; the program <!-- on the previous page -->leaves that value unaffected.)</p>				<pre><u>begin</u>  <u>integer</u> k; <u>integer</u> <u>array</u> n, from, via, to [1:2*N-1];   n[1]:= N; from[1]:=1; via[1]:=2; to[1]:=3; k:=1;   <u>repeat</u> <u>if</u> n[k]= 1 <u>then</u>    <u>begin</u>  movedisk(from[k], to[k]);           k:= k - 1     <u>end</u>                    <u>else</u>    <u>begin</u>       n[k+2]:= n[k]-1; from[k+2]:= from[k]; via[k+2]:= to[k]; to[k+2]:= via[k];      n[k+1]:=1; from[k+1]:= from[k]; to[k+1]:= to[k];       n[k]:= n[k+2]; from[k]:= to[k+2]; via[k]:= from[k+2]; to[k]:= via[k+2];      k := k + 2    <u>end</u>  <u>until</u> k = O<u>end</u></pre>				<p class="noindent"><u>Remark.</u> In the program we have not described the details of the operation &quot;movedisk(<i>A</i>, <i>B</i>)&quot;. If it prints the number pair <i>A</i>, <i>B</i>, the solution will be printed; if the machine is coupled to a mechanical hand which really moves disks, the machine will play the game!</p>				<p>The reader is strongly advised to follow the above program himself for a small value of <i>N</i> (say: 4) so as to see how the value of <i>k</i> goes up and down. The reader is also invited to check carefully the &quot;shunting&quot; of the values <i>N</i>(&#150;1), <i>A</i>, <i>B</i> and <i>C</i> when a non-simple move is decomposed into three simpler ones. This check is a painful process, so painful that everyone who has done it, will only be too willing to admit that the above program is rather ugly. The above program has been included with the aim of making him more appreciative of the elegance of the so-called &quot;recursive solution&quot; which now follows.</p>				<pre><u>begin</u> <u>procedure</u> movetower (<u>integer</u> <u>value</u> m, A, B, C);   <u>begin</u> <u>if</u> m = 1 <u>then</u> movedisk (A, C)                 <u>else</u>          <u>begin</u> movetower (m-1, A, C, B);                 movedisk (A, C);                 movetower (m-1, B, A, C)           <u>end</u>       <u>end</u>;      movetower (N,  1,  2,  3) <u>end</u></pre>				<p>It introduces an operator named &quot;movetower&quot; with four (integer valued) parameters, moving a tower of length <i>m</i> from <i>A</i> via <i>B</i> to <i>C</i>. In terms of this operator the final program collapses into a single statements as given in the last line, viz. &quot;movetower (<i>N</i>, 1, 2, 3)&quot;. All that is given in front of it (lines 2 to 8) describes this operator in terms of a little program, little because the operator is allowed to invoke itself. The definition of the operator (the so-called &quot;procedure body&quot;) follows our original analysis of the game exactly. Recursive procedures &#x2014;i.e. procedures that are allowed to invoke themselves&#x2014; are such a powerful tool in programming that we shall give some more examples of them.</p>				<p class="noindent"><u>Remark</u>. Some of the more old-fashioned programming languages do not cater for recursion. Programming cources based on such programming languages often contain many examples that are only difficult because the recursive solution is denied to the student.</p>				<p class="noindent"><a href="#contents">Back to top</a></p>				<p class="noindent">Next chapter: 9. <a title="Chapter 9 of EWD 316" href="EWD316.9.html">The problem of eight queens</a></p>				<p></p>			</div>			<hr />			<!-- name and date -->      <div id="footer">transcribed by Romek Zylla<br /> revised <csobj format="MedDate" h="15" region="15" t="DateTime" w="95">Sat, 2 Aug 2008</csobj></div>    </div>  </body></html></x-html></div>
  </body>
  </html>
