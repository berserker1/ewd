  <!DOCTYPE html>
  <html>
  <head>
    <title>Cooperating sequential processes</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <link href="assets/tweet-selection.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.12.0.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="assets/tweet-selection.js"></script>
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: Cooperating sequential processes" />
    <meta name="twitter:title" content="Cooperating sequential processes" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>Cooperating sequential processes</h1>
  <div class='body'>						<p class="noindent"><u><a name="Anchor-Table-49575"></a></u>Table of Contents.</p>						<p class="noindent"><a href="#preface">Preface</a>.</p>						<p class="noindent">0. <a href="#0. introduction">Introduction</a></p>						<p class="noindent">1. <a href="#On the Nature of Sequential Processes">On the Nature of Sequential Processes.</a></p>						<p class="noindent">2.<a href="#2. Loosely Connected Processes"> Loosely Connected Processes.</a></p>						<blockquote>							<p class="noindent">2.1 .<a href="#2.1. A Simple Example."> A Simple Example.</a></p>							<p class="noindent">2.2. <a href="#2.2. The Generalized Mutual Exclusion Problem">The Generalized Mutual Exclusion Problem</a>.</p>							<p class="noindent">2.3. <a href="#2.3. A Linguistic Interlude">A Linguistic Interlude</a>.</p>						</blockquote>						<p class="noindent">3. <a href="#3. The Mutual Exclusion Problem Revisited.">The Mutual Exclusion Problem Revisited.</a></p>						<blockquote>							<p class="noindent">3.1.<a href="#3.1. The Need for a More Realistic Solution."> The Need for a More Realistic Solution.</a></p>							<p class="noindent">3.2. <a href="#3.2. The Synchronizing Primitives.">The Synchronizing Primitives.</a></p>							<p class="noindent">3.3. <a href="#3.3. The Synchronizing Primitives Applied to the Mutual Exclusion Problem.">The Synchronizing Primitives Applied to the Mutual Exclusion Problem.</a></p>						</blockquote>						<p class="noindent">4. <a href="#4. The General Semaphore.">The General Semaphore.</a></p>						<blockquote>							<p class="noindent">4.1.<a href="#4.1. Typical Uses of the General Semaphore."> Typical Uses of the General Semaphore.</a></p>							<p class="noindent">4.2. <a href="#4.2. The Superfluity of the General Semaphore.">The Superfluity of the General Semaphore.</a></p>							<p class="noindent">4.3. <a href="#4.3. The Bounded Buffer.">The Bounded Buffer.</a></p>						</blockquote>						<p class="noindent">5. <a href="EWD123-2.html#5. Cooperation via Status Variables">Cooperation via Status Variables.</a></p>						<blockquote>							<p class="noindent">5.1. <a href="#5.1. An Example of a Priority Rule.">An Example of a Priority Rule.</a></p>							<p class="noindent">5.2. <a href="EWD123-2.html#5.2. An Example of Conversations.">An Example of Conversations</a></p>							<blockquote>								<p class="noindent">5.2.1. <a href="EWD123-2.html#5.2.1. Improvements of the Previous Program.">Improvements of the Previous Program.</a></p>								<p class="noindent">5.2.2. <a href="EWD123-2.html#5.2.2. Provinq the Correctness.">Proving the Correctness.</a></p>							</blockquote>						</blockquote>						<p class="noindent">6. <a href="EWD123-2.html#6. The Problem of the Deadly Embrace.">The Problem of the Deadly Embrace.</a></p>						<blockquote>							<p class="noindent">6.1. <a href="EWD123-2.html#6.1. The Banker's Algorithm.">The Banker's Algorithm.</a></p>							<p class="noindent">6.2. <a href="EWD123-2.html#6.2. The Banker's Alqorithm Applied.">The Banker's Algorithm Applied</a></p>						</blockquote>						<p class="noindent">7. <a href="EWD123-2.html#7. Concluding Remarks.">Concluding Remarks.</a></p>						<p class="noindent"></p>						<hr>						<p class="noindent"><a name="preface"></a><u>Preface </u></p>						<p>The main purpose of this preface is to explain the specification &quot;Preliminary Version&quot;, appearing on the title page of these lecture notes. They have been prepared under considerable tine pressure, circumstances under which I was unable to have my use of the English language corrected by a native, circumstances under which I was unable first to try out different methods of presentation. As they stand, I hope that they will serve their two primary purposes: to give my students a guide as to what I am telling and to give my Friends and Relations an idea of what I am doing.</p>						<p>The future fate of this manuscript, that may prove to be a monograph in statu nascendi, will greatly depend on their reactions to it. I am greatly indebted, in advance, to any reader who is so kind as to take the trouble to give his comments, either in the form of suggestions how the presentation or the material itself could be improved, or in the form of an appreciation. From the latter comments I will try to get an idea whether it is worth-while to pursue this effort any further and to prepare a publication fit for and agreeable to a wider public.</p>						<p>Already at this stage I should like to express my gratitude to many: to my collaborators C.Bron (in particular for his scrutinous screening of the typed version), to A.N.Habermann, F.J.A.Hendriks, C.Ligtmans and P.A. Voorhoeve for many stimulating and clarifying discussions on the subject itself, to the Department of Mathematics of the Technological University, Eindhoven, for the opportunity to spend my time on the problems dealt with and to lecture on their solutions and also &#x2014;trivial as it may seem, this is nevertheless vital:&#x2014; for putting at my private disposal a type writer with a character set in complete accordance with my personal wishes.</p>						<p></p>						E.W.Dijkstra<br>						<br>						<br>						<br>						Department of Mathematics<br>						Technological University<br>						P.O. Box 513<br>						EINDHOVEN<br>						The Netherlands						<p></p>						<hr>						<p class="noindent"><a name="0. introduction"></a><u>0. Introduction.</u></p>						<p>These lectures are intended for all those that expect that in their future activities they will become seriously involved in the problems that arise in either the design or the more advanced applications of digital information processing equipment; they are further intended for all those that are just interested.</p>						<p>The applications I have in mind are those in which the activity of a computer must include the proper reacting to a possibly great variety of messages that can be sent to it at unpredictable moments, a situation which occurs in process control, traffic control, stock control, banking applica- tions, automization of information flow in large organizations, centralized computer service and, finally, all information systems in which a number of computers are coupled to each other.</p>						<p>The desire to apply computers in the ways sketched above has often a strong economic motivation, but in these lectures the not unimportant ques- tion of efficiency will not be stressed too much. We shall occupy ourselves much more with the logical problems which arise, for example, when speed ratios are unknown, communication possibilities restricted etc. We intend to do so in order to create a clearer insight into tie origin of the difficulties we shall meet and into the nature of our solutions. To decide whether under given circumstances the application of our techniques is economically attractive or not falls outside the scope of these lectures.</p>						<p>I regret that I cannot offer a fully worked out theory, complete with Greek letter formulae, so to speak. The only thing I can do under the present circumstances is to offer a variety of problems, together with solutions. And in discussing these, we can only hope to bring as much system into it as we possibly can, to find which concepts are relevant, as we go along. May everyone that follows me along this road enjoy the fascination of these intriguing problems as much as I do!</p>						<p class="noindent"><a name="On the Nature of Sequential Processes"></a><u>1. On the Nature of Sequential Processes.</u></p>						<p>Our problem field proper is the cooperation between two or more sequential processes. Before we can enter this field, however, we have to know quite clearly what we call &quot;a sequential process&quot;. To this preliminary question the present section is devoted.</p>						<p>I should like to start my elucidation with the comparison of two machines to do the same example job, the one a non-sequential machine, the other a sequential one.</p>						<p>Let us assume that of each of four quantities, named &quot;<var>a</var>[1]&quot;, &quot;<var>a</var>[2]&quot;, &quot;<var>a</var>[3]&quot; and &quot;<var>a</var>[4]&quot; respectively, the value is given. Our machine has to process these values in such a way that, as its reaction, it &quot;tells&quot; us, which of the four quantities has the largest value. E.g. in the case:</p>						<p><var>a</var>[1] = 7, <var>a</var>[2] = 12, <var>a</var>[3] = 2, <var>a</var>[4] = 9</p>						<p class="noindent">the answer to be produced is &quot;<var>a</var>[2]&quot; (or only &quot;2&quot;. giving the index value pointing to the maximum element).</p>						<p>Note that the desired answer would become incompletely defined if the set of values were &#x2014;in order&#x2014; &quot;7, 12, 2, 12&quot;. for then there is no unique largest element and the answer &quot;<var>a</var>[2]&quot; would have been as good (or as bad) as &quot;<var>a</var>[4]&quot;. This is remedied by the further assumption, that of the four values given, no two are equal.</p>						<p>Remark 1. If the required answer would have been the maximum value occuring among the given ones, then the last restriction would have been superfluous, for then the answer corresponding to the value set &quot;7, 12, 2, 12&quot; would have been &quot;12&quot;.</p>						<p>Remark 2. Our restriction &quot;Of the four values no two are equal&quot; is still somewhat loosely formulated, far what do we mean by &quot;equal&quot;? In the processes to be constructed pairs of values will be compared with one another and what is really meant is, that every two values will be sufficiently different, so that the comparator will unambiguously decide, which of the two is the largest one. In other words, the difference between any two must be large compared with &quot;the resolving power&quot; of our comparators.</p>						<p>We shall first construct our non-sequential machine. When we assume our given values to be represented by currents, we can imagine a comparator consisting of a two-way switch, the position of which is schematically controlled by the currents in the coils of electromagnets as in Fig.1 and Fig.2.</p>					</div>					<div align="center">						<p></p>						<table width="122" border="0" cellspacing="2" cellpadding="0">							<tr>								<td>									<div align="center">										<img src="EWD123figs/EWD123_Fig01.png" alt="" width="260" height="150" border="0">Fig. 1. <var>x</var> &lt; <var>y</var></div>								</td>								<td>									<div align="center">										<img src="EWD123figs/EWD123_Fig02.png" alt="" width="241" height="150" border="0">Fig. 2. <var>y</var> &lt; <var>x</var></div>								</td>							</tr>						</table>					</div>					<div>						<p>When current <var>y</var> is larger than current <var>x</var>, the left electromagnet pulls harder than the right one and the switch switches to the left (Fig.l) and the input <var>A</var> is connected to output <var>B</var>; if current <var>x</var> is the larger one, we shall get the situation (Fig.2) where the input <var>A</var> is connected to output <var>C</var>.</p>						<p>In our diagrams we shall omit the coils and shall represent such a comparator by a small box</p>					</div>					<div align="center">						<img src="EWD123figs/EWD123_Pic01.png" alt="" width="100" height="88" border="0"></div>					<div>						only representing at the top side the input and at the bottom side the two outputs. The currents to be led through the coils are identified in the question written inside the box and the convention is, that the input will be connected to the right hand side output when the answer to the question is &quot;Yes&quot;, to the left hand side output when the answer is &quot;No&quot;.</div>					<div align="center">						<img src="EWD123figs/EWD123_Fig03.png" alt="" width="502" height="167" border="0"><br>						Fig. 3.</div>					<div>						<p>Now we can construct our machine as indicated in Fig.3. At the output side we have drawn four indicator lamps, one of which will light up to indicate the answer.</p>						<p>In Fig.4 we indicate the position of the switches when the value set &quot;7, 12, 2, 9&quot; is applied to it. In the boxes the positions of the switches are indicated, wires not connected to the input are drawn blotted.<br>						</p>					</div>					<div align="center">						<img src="EWD123figs/EWD123_Fig04.png" alt="" width="403" height="198" border="0"><br>						Fig.4.</div>					<div>						<p>We draw the reader's attention to the fact that now only the positions of the three switches that connect output 2 to the input, matter; the reader is invited to convince himself that the position of the other three switches is indeed immaterial.</p>						<p>It is also good to give a moment attention to see what happens in time when our machine of Fig.3 is fed with four &quot;value currents&quot;. Obviously it cannot be expected to give the correct answer before the four value currents are going through the coils. But one cannot even expect it to indicate the correct answer as soon as the currents are applied, for the switches must get into their correct position and this may take some time. In other words: as soon as the currents are applied (simultaneously or the one after the other) we must wait a period of time &#x2014;characteristic for the machine&#x2014; and after that the correct answer will be shown at the output side. What happens in this waiting time is immaterial, provided that it is long enough for all the switches to find their final position. They may start switching simultaneously, the exact order in which they attain their final position is immaterial and, therefore, we shall not pay any attention to it any more.</p>						<p>From the logical point of view the switching time can be regarded as a marker on the time axis: before it the input data have to be supplied, after it the answer is available.</p>						<p>In the use of our machine the progress of time is only reflected in the obvious &quot;before - after&quot; relation, which tells us, that we cannot expect an answer before the question has been properly put. This sequence relation is so obvious (and fundamental) that it cannot be regarded as a characteristic property of our machine. And our machine is therefore called a &quot;non-sequential machine&quot; to distinguish it from the kind of equipment &#x2014;or processes that can be performed by it&#x2014; to be described now.</p>						<p>Up till now we have interpreted the diagram of Fig.3 as the (schematic) picture of a machine to be built in space. But we can interpret this same diagram in a very different manner if we place ourselves in the mind of the electron entering at the top input and wondering where to go. First it finds itself faced with the question whether &quot;<var>a</var>[l] &lt; <var>a</var>[2]&quot; holds. Having found the answer to this question, it can proceed. Depending on the previous answer it will enter one of the two boxes &quot;<var>a</var>[1] &lt; <var>a</var>[3]&quot; or &quot;<var>a</var>[2] &lt; <var>a</var>[3]&quot;, i.e. it will only know what to investigate next, after the first question has been answered. Having found the answer to the question selected from the second line, it will know which question to ask from the third line and having found this last answer it will now know which bulb should start to glow. Instead of regarding the diagram of Fig.3 as that of a machine, the parts of which are spread out in space, we have regarded it as rules of behaviour, to be followed in time.</p>						<p>With respect to our earlier interpretation two differences are highly significant. In the first interpretation all six comparators started working simultaneously, although finally only three switch positions matter. In the second interpretation only three comparisons are actually evaluated &#x2014;the wondering electron asks itself three questions&#x2014; but the price of this gain is that they have to be performed the one after the other, as the outcome of the previous one decides what to ask next. In the second interpretation three questions have to be asked in <em>sequence</em>, the one after the other. The existence of such an order relation is the distinctive feature of the second interpretation which in contrast to the first one is therefore called &quot;a sequential process&quot;. We should like to make two remarks.</p>						<p>Remark 3. In actual fact, the three comparisons will each take a finite amount of time (switching time&quot;, &quot;decision time&quot; or, to use the jargon, &quot;execution time&quot;) and as a result the total time taken will at least be equal to the sum of these three execution times. We stress once more, that for many investigations these executions can be regarded as ordered markers on a scaleless time axis and that it is only the relative ordering that matters from this (logical) point of view.</p>						<p>Remark 4. As a small side line we note that the two interpretations (call them &quot;simultaneous comparisons&quot; and &quot;sequential comparisons&quot;) are only extremes. There is a way of, again, only performing three comparisons, in which two of them can be done independently from one another, i.e. simultaneously; the third one, however, can only be done, after the other two have been completed. It can be represented with the aid of a box in which two questions are put and which, as a result, has four possible exits, as in Fig.5.<br>						</p>					</div>					<div align="center">						<img src="EWD123figs/EWD123_Fig05.png" alt="" width="484" height="152" border="0"><br>						Fig.5.</div>					<div>						<p class="noindent">The total time taken will be at least the sum of the comparison execution times. The process is of the first kind in the sense that the first two comparisons can be performed simultaneously, it is of sequential nature as the third comparison can only be selected from the second line when the first two have both been completed.</p>						<p>We return to our purely sequential interpretation. Knowing that the diagram is meant for purely sequential interpretation we can take advantage of this circumstance make the description of the &quot;rules of behaviour&quot; more compact. The idea is, that the two questions on the second line &#x2014;only one of which will be actually asked&#x2014; are highly similar: the questions on the same line only differ in the subscript value of the left operand of the comparison. And we may ask ourselves: &quot;Can we map the questions on the same line of Fig.3 on a single question ?&quot;</p>						<p>This can be done, but it implies that the part that varies along a line &#x2014;i.e. the subscript value in the left operand&#x2014; must be regarded as a parameter, the task of which is to determine which of the questions mapped on each other is meant, when its turn to be executed has come. Obviously the value of this parameter must be defined by the past history of the process.</p>						<p>Such parameters, in which past history can be condensed for future use are called <i>variables</i>. To indicate that a new value has to be assigned to it we use the so-called assignment operator &quot;:=&quot; (read: &quot;becomes&quot;), a kind of directed equality sign which defines the value of the left hand side in terns of the value of the right hand side.</p>						<p>We hope that the previous paragraph is sufficient for the reader to recognize also in the diagram of Fig.6 a set of &quot;rules of behaviour&quot;. Our variable is called <i>i</i>; if the reader wonders, why the first question, which is invariably &quot;<var>a</var>[l] &lt; <var>a</var>[2] ?&quot; is not written that way, he is kindly requested to have some patience.</p>					</div>					<div align="center">						<img src="EWD123figs/EWD123_Fig06.png" alt="" width="209" height="293" border="0"><br>						Fig.6</div>					<div>						<p>When we have followed the rules of Fig.6 as intended from top till bottom, the final value of <var>i</var> will identify the maximum value, viz. <var>a</var>[<var>i</var>].</p>						<p>The transition from the scheme of Fig.3 to the one of Fig.6 is a drastic change, for the last &quot;rules of behaviour&quot; can only be interpreted sequentially. And this is due to the introduction of the variable <var>i</var>: having only <var>a</var>[1], <var>a</var>[2], <var>a</var>[3] and <var>a</var>[4] available as values to be compared, the question &quot;<var>a</var>[i] &lt; <var>a</var>[2] ?&quot; is meaningless, unless it is known for which value of <var>i</var> this comparison has to be made.</p>						<p>Remark 5. It is somewhat unhappy that the jargon of the trade calls the thing denoted by <var>i</var> a variable, because in normal mathematics, the concept of a variable is a completely timeless concept. Time has nothing to do with the <var>x</var> in the relation</p>						<p>sin(2 * <var>x</var>) = 2 * sin(<var>x</var>) * cos(<var>x</var>) ;</p>						<p class="noindent">if such a variable ever denotes a value, it denotes &quot;any value&quot;.</p>						<p>Each time, however, that a variable in a sequential process is used &#x2014;such as <var>i</var> in &quot;<var>a</var>[<var>i</var>]&quot;&#x2014; it denotes a very specific value, viz. the last value assigned to it, and nothing else! As long as no new value is assigned to a variable, it denotes a constant value!</p>						<p>I am, however, only too hesitant to coin new terms: firstly it would make this monograph unintendedly pretentious, secondly I feel that the (fashionable!) coining of new terms often adds as much to the confusion in one way as it removes in the other. I shall therefore stick to the term &quot;variable&quot;.</p>						<p>Remark 6. One may well ask, what we are actually doing, when we introduce a variable without specifying, for instance, a domain for it, i.e. a set of values which is guaranteed to comprise all its future actual values. We shall not pursue this any further here.</p>					</div>				</div>			</div>		</div>		<div id="frame" align="left">			<div id="content" align="left">				<p>Now we are going to subject our scheme to a next transformation. In Fig.3 we have &quot;wrapped up&quot; the lines, now we are going to wrap up the scheme of Fig.6 in the other direction, an operation to wich we are invited by the repetitive nature of it and which can be performed at the price of a next variable, &quot;<code>j</code>&quot; say.</p>			</div>		</div>		<div id="frame" align="center">			<div id="content" align="center">				<p><img src="EWD123figs/EWD123_Fig07.png" alt="" width="212" height="228" border="0"><br>					Fig.7</p>			</div>		</div>		<div id="frame">			<div id="content">				<div align="left">					<div>						<p>The change is a dramatic one, for the fact that the original problem was to identify the maximum value among <em>four</em> given values is no longer reflected in the &quot;topology&quot; of the rules of behaviour: in Fig.7 we only find the number &quot;4&quot; mentioned once. By introducing another variable, say <var>n</var>, and replacing the &quot;4&quot; in Fig.7 by <var>n</var> we have suddenly the rules of behaviour to identify the maximum occurring among the <var>n</var> elements <var>a</var>[1], <var>a</var>[2], .......,<var>a</var>[<var>n</var>] and this practically only for the price that before application, the variable <var>n</var> must be put to its proper value.</p>						<p>I called the change a dramatic one, for now we have not only given rules of behaviour which must be interpreted sequentially &#x2014;this was already the case with Fig.6&#x2014; but we have devised a single mechanism for identifying the maximum value among any number of given elements, whereas our original non-sequential machine could only be built for a previously well-defined number of elements. We have mapped our comparisons in time instead of in space, and if we wish to compare the two methods, it is as if the sequential machine &quot;extends itself&quot; in terms of Fig.3 as the need arises. It is our last transition which displays the sequential processes in their full glory.</p>						<p>The technical term for what we have called &quot;rules of behaviour&quot; is an algorithm or a program. (It is not customary to call it &quot;a sequential program&quot; although this name would be fully correct.) Equipment able to follow such rules, &quot;to execute such a program&quot; is called &quot;a general purpose sequential computer&quot; or &quot;computer&quot; for short; what happens during such a program execution is called &quot;a sequential process&quot;.</p>						<p>There is a commonly accepted technique of writing algorithms without the need of such pictures as we have used, viz. ALGOL 60 (&quot;ALGOL&quot; being short for Algorithmic Language). For a detailed discussion of ALGOL 60 I must refer the reader to the existing literature. We shall use it in future, whenever convenient for our purposes.</p>						<p>For the sake of illustration we shall describe the algorithm of Fig.7 (but for <var>n</var> instead of &quot;4&quot;) by a sequence of ALGOL statements:</p>						<p class="noindent"><code>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i:= 1; j:= 1;<br>								back: <u>if</u> j &#x2260; n <u>then</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> j:= j + 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> a[i] &lt; a[j] <u>then</u> i:= j;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> back<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u></code> .</p>						<p>The first two statements: &quot;<code>i:=l; j:= 1</code>&quot; are &#x2014;I hope&#x2014; self-explanatory. Then comes &quot;<code>back:</code>&quot;, a so-called label, used to identify this place in the program. Then comes &quot;<code><u>if</u> j &#x2260; n <u>then</u></code>&quot;, a so-called conditional clause. If the condition expressed by it is satisfied, the following statement will be performed, otherwise it will be skipped. (Another example of it can be found two lines lower.) When the extent of the program which may have to be skipped presents itself primarily as a sequence of more than one statement, then one puts the so-called statement brackets &quot;<code><u>begin</u></code>&quot; and &quot;<code><u>end</u></code>&quot; around this sequence, thereby making it into a single statement as far as its surroundings are concerned. (This is entirely analogous to the effect of parentheses in algebraic formulae, such as &quot;<var>a</var> * (<var>b</var> + <var>c</var>)&quot; where the parenthesis pair indicates that the whole expression contained within it is to be taken as factor.) The last statement &quot;<code><u>goto</u> back</code>&quot; means that the process should be continued at the point thus labeled; it does exactly the same thing for us as the upward leading line of Fig.7.</p>						<p class="noindent"><a name="2. Loosely Connected Processes"></a><u>2. Loosely Connected Processes.</u></p>						<p>The subject matter of this monograph is the cooperation between loosely connected sequential processes and this section will be devoted to a thorough discussion of a simple, but representative problem, in order to give the reader some feeling for the problems in this area.</p>						<p>In the previous section we have described the nature of a single sequential process, performing its sequence of actions autonomously, i.e. independent of its surroundings as soon as it has been started.</p>						<p>When two or more of such processes have to cooperate with each other, they must be connected, i.e. they must be able to communicate with each other in order to exchange information. As we shall see below, the properties of these means of intercommunication play a vital role.</p>						<p>Furthermore, we have stipulated that the processes should be connected loosely; by this we mean that apart from the (rare) moments of explicit intercommunication, the individual processes themselves are to be regarded as completely independent of each other. In particular we disallow any assumption about the relative speeds of the different processes. (Such an assumption &#x2014;say&quot;processes geared to the same clock&quot;&#x2014; could be regarded as implicit intercommunication.) This independence of speed ratios is in strict accordance with our appreciation of the single sequential process: its only essential feature is, that its elementary steps are performed in sequence. If we prefer to observe the performance with a chronometer in our hand, we may do so, but the process itself remains remarkably unaffected by this observation.</p>						<p>I warn the reader that my consistent refusal to make any assumptions about the speed ratios will at first sight appear as a mean trick to make things more difficult than they already are. I feel, however, fully justified in my refusal. Firstly, we may have to cope with situations in which, indeed, very little is known about the speeds. For instance, part of the system may be a manually operated input station, another part of the system might be such, that it can be stopped externally for any period of time, thus reducing its speed temporarily to zero. Secondly &#x2014;and this is much more important&#x2014; when we think that we can rely upon certain speed ratios, we shall discover that we have been &quot;pound foolish and penny wise&quot;. True that certain mechanisms can be made simpler under the assumption of speed ratio restrictions. The verification, however, that such an assumption is always justified, is in general extremely tricky and the task to make, in a reliable manner, a well behaved structure out of many interlinked components is seriously aggravated when such &quot;analogue interferences&quot; have to be taken into account as well. (For one thing: it will make the proper working a rather unstable equilibrium, sensitive to any change in the different speeds, as may easily arise by replacement of a component by another &#x2014;say, replacement of a line printer by a faster model&#x2014; or reprogramming of a certain portion.)</p>						<p class="noindent"><a name="2.1. A Simple Example."></a><u>2.1. A Simple Example.</u></p>						<p>After these introductory remarks I shall discuss the first problem.</p>						<p>We consider two sequential processes, &quot;process 1&quot; and &quot;process 2&quot;, which for our purposes can be regarded as cyclic. In each cycle a so-called &quot;critical section&quot; occurs, critical in the sense that the processes have to be constructed in such a way, that at any moment at most one of the two is engaged in its critical section. In order to effectuate this mutual exclusion the two processes have access to a number of common variables. We postulate, that inspecting the present value of such a common variable and assigning a new value to such a common variable are to be regarded as indivisible, non-interfering actions. I.e. when the two processes assign a new value to the same common variable &quot;simultaneously&quot;, then the assignments are to be regarded as done the one after the other, the final value of the variable will be one of the two values assigned, but never a &quot;mixture&quot; of the two. Similarly, when one process inspects the value of a common variable &quot;simultaneously&quot; with the assignment to it by the other one, then the first process will find either the old or the new value, but never a mixture.</p>						<p>For our purposes ALGOL 60 as it stands is not suited, as ALGOL 60 has been designed to describe one single sequential process. We therefore propose the following extension to enable us to describe parallellism of execution. When a sequence of statements &#x2014;separated by semicolons as usual in ALGOL 60&#x2014; is surrounded by the special statement bracket pair &quot;<code><u>parbegin</u></code>&quot; and &quot;<code><u>parend</u></code>&quot;, this is to be interpreted as parallel execution of the constituent statements. The whole construction &#x2014;let us call it &quot;a parallel compound&quot;&#x2014; can be regarded as a statement. Initiation of a parallel compound implies simultaneous initiation of all its constituent statements, its execution is completed after the completion of the execution of all its constituent statements. E.g.:</p>						<p><code><u>begin</u> S1; <u>parbegin</u> S2; S3; S4; <u>parend</u>; S5 <u>end</u></code></p>						<p class="noindent">(in which <code>S1</code>, <code>S2</code>, <code>S3</code>. <code>S4</code> and <code>S5</code> are used to indicate statements) means that after the completion of <code>S1</code>, the statements <code>S2</code>. <code>S3</code> and <code>S4</code> will be executed in parallel, and only when they are all finished, then the execution of statement <code>55</code> will be initiated.</p>						<p>With the above conventions we can describe our first solution:</p>						<p class="noindent"><code><u>begin</u> <u>integer</u> turn; turn:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parbegin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process 1: <u>begin</u> Ll: <u>if</u> turn = 2 <u>then</u> goto Ll;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;critical section 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn:= 2;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remainder of cycle 1; <u>goto</u> L1<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process 2: <u>begin</u> L2: <u>if</u> turn = 1 <u>then</u> goto L2;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;critical section 2;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remainder of cycle 2; <u>goto</u> L2<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>end</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parend</u><br>								<u>end</u></code> .</p>						<p>(Note for the inexperienced ALGOL 60 reader. After &quot;<u><code>begin</code></u>&quot; in the first line we find the so-called declaration &quot;<code><u>integer</u></code> <code>turn</code>&quot;, thereby sticking to the rule of ALGOL 60 that program text is not allowed to refer to variables without having introduced them with the aid of a declaration. As this declaration occurs after the &quot;<code><u>begin</u></code>&quot; of the outermost statement bracket pair it means that for the whole duration of the program a variable has been introduced that will only take on integer values and to which the program text can refer by means of the name &quot;<code>turn</code>&quot;.)</p>						<p>The two processes communicate with each other via the common integer &quot;<code>turn</code>&quot;, the value of which indicates which of the two processes is the first to perform (or rather: to finish) its critical section. From the program it is clear that after the first assignment, the only possible values of the variable &quot;<code>turn</code>&quot; are 1 and 2. The condition for process 2 to enter its critical section is that it finds at some moment &quot;<code>turn &#x2260; 1</code>&quot;, i.e. &quot;<code>turn = 2</code>&quot;. But the only way in which the variable &quot;<code>turn</code>&quot; can get this value is by the assignment &quot;<code>turn:= 2</code>&quot; in process 1. As process 1 performs this assignment only at the completion of its critical section, process 2 can only initiate its critical section after the completion of critical section 1. And critical section 1 could indeed be initiated, because the initial condition &quot;<code>turn = 1</code>&quot; implied &quot;<code>turn &#x2260; 2</code>&quot;, so that the potential wait cycle, labeled <code>L1</code>, was initially inactive. After the assignment &quot;<code>turn:= 2</code>&quot; the roles of the two processes are interchanged. (N.B. It is assumed that the only references to the variable &quot;<code>turn</code>&quot; are the ones explicitly shown in the program.)</p>						<p>Our solution, though correct, is, however, unnecessarily restrictive: after the completion of critical section 1, the value of the variable &quot;<code>turn</code>&quot; becomes &quot;2&quot;, and it must be =1 again, before the next entrance into critical section 1. As a result the only admissible succession of critical sections is the strictly alternating one &quot;1,2,1,2,1,2,1,.....&quot;, in other words, the two processes are synchronized. In order to stress explicitly that this is not the kind of solution we wanted, we impose the further condition &quot;If one of the processes is stopped well outside its critical section, this is not allowed to lead to potential blocking of the other process.&quot;. This makes our previous solution unacceptable and we have to look for another.</p>						<p>Our second effort works with two integers &quot;<code>c1</code>&quot; and &quot;<code>c2</code>&quot;, where c = 0 / 1 respectively will indicate that the corresponding process in inside / outside its critical section respectively. We may try the following construction:</p>						<p class="noindent"><code><u>begin</u> <u>integer</u> c1, c2;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c1:= 1; c2:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parbegin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process1: <u>begin</u> L1: <u>if</u> c2 = 0 <u>then</u> <u>goto</u> L1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c1: = 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;critical section 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c1:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remainder of cycle 1; <u>goto</u> L1<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process2: <u>begin</u> L2: <u>if</u> c1 = 0 <u>then</u> <u>goto</u> L2;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c2: = 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;critical section 2;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c2:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remainder of cycle 2; <u>goto</u> L2<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parend</u><br>								<u>end</u> .<br>							</code></p>						<p>The first assignments set both <code>c</code>'s = 1, in accordance with the fact that the processes are started outside their critical sections. During the entire execution of critical section 1 the relation &quot;<code>c1</code> = 0&quot; holds and the first line of process 2 is effectively a wait &quot;Wait as long as process 1 is in its critical section.&quot;. The trial solution gives indeed some protection against simultaneity of critical section execution, but is, alas, too simple, because it is wrong. Let first process 1 find that <code>c2</code> = 1; let process 2 inspect <code>c1</code> immediately afterwards, then it will (still) find <code>c1</code> = 1. Both processes, having found that the other is not in its critical section, will conclude that they can enter their own section safely!</p>						<p>We have been too optimistic, we must play a safer game. Let us invert, at the beginning of the parallel processes, the inspection of the &quot;<code>c</code>&quot; of the other and the setting of the own &quot;<code>c</code>&quot;. We then get the construction:</p>						<p class="noindent"><code><u>begin</u> <u>integer</u> c1, c2;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c1:= 1; c2:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parbegin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process 1: <u>begin</u> A1: c1:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L1: <u>if</u> c2 = 0 then <u>goto</u> Ll;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;critical section 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c1:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remainder of cycle 1; <u>goto</u> A1<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process 2: <u>begin</u> A2: c2:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L2: <u>if</u> c1 = 0 <u>then</u> <u>goto</u> L2;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;critical section 2;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c2:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remainder of cycle 2; <u>goto</u> A2<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parend</u><br>								<u>end</u></code> .</p>						<p>It is worth while to verify that this solution is at least completely safe. Let us focus our attention on the moment that process 1 finds <code>c2</code> = 1 and therefore decides to enter its critical section. At this moment we can conclude<br>							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1) that the relation &quot;<code>c1</code> = 0&quot; already holds and will continue to hold until process 1 has completed the execution of its critical section,<br>							&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2) that, as &quot;<code>c2</code> = 1&quot; holds, process 2 is well outside its critical section, which it cannot enter as long as &quot;<code>c1</code> = 0&quot; holds, i.e. as long as process 1 is still engaged in its critical section.<br>							Thus the mutual exclusion is indeed guaranteed.</p>						<p>But this solution, alas, must also be rejected: in its safety measures it has been too drastic, for it contains the danger of definite mutual blocking. When after the assignment &quot;<code>c1:= 0</code>&quot; but yet before the inspection of <code>c2</code> (both by process 1) process 2 performs the assignment &quot;<code>c2:= 0</code>&quot; then both processes have arrived at label <code>L1</code> or <code>L2</code> respectively and both relations &quot;<code>c1</code> = 0&quot; and &quot;<code>c2</code> = 0&quot; hold, with the result that both processes will wait upon each other until eternity. Therefore also this solution must be rejected.</p>						<p>It was OK to set one's own &quot;<code>c</code>&quot; before inspecting the &quot;<code>c</code>&quot; of the other, but it was wrong to stick to one's own <code>c</code>-setting and just to wait. This is (somewhat) remedied in the following construction:</p>						<p class="noindent"><code><u>begin</u> <u>integer</u> c1, c2;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c1:= 1; c2:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parbegin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process 1: <u>begin</u> L1: c1:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> c2 = 0 <u>then</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> c1:= 1; <u>goto</u> L1 <u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;critical section 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c1:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remainder of cycle 1; <u>goto</u> L1<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process 2: <u>begin</u> L2: c2:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> c1 = 0 <u>then</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> c2:= 1; <u>goto</u> L2 <u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;critical section 2;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c2:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remainder of cycle 2; <u>goto</u> L2<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parend</u><br>								<u>end</u></code> .</p>						<p>This construction is as safe as the previous one and, when the assignments &quot;<code>c1:= 0</code>&quot; and &quot;<code>c2:= 0</code>&quot; are performed &quot;simultaneously&quot; it will not necessarily lead to mutual blocking ad infinitum, because both processes will reset their own &quot;<code>c</code>&quot; back to 1 before restarting the entry rites, thereby enabling the other process to catch the opportunity. But our principles force us to reject also this solution, for the refusal to make any assumptions about the speed ratio implies that we have to cater for all speeds, and the last solution admits the speeds to be so carefully adjusted that the processes inspect the other's &quot;<code>c</code>&quot; only in those periods of time that its value is = 0. To make clear that we reject such solutions that only work with some luck, we state our next requirement: &quot;If the two processes are about to enter their critical sections, it must be impossible to devise for them such finite speeds, that the decision which one of the two is the first to enter its critical section is postponed until eternity.&quot;.</p>						<p>In passing we note, that the solution just rejected is quite acceptable everyday life. E.g., when two people are talking over the telephone and they are suddenly disconnected, as a rule both try to reestablish the connection. They both dial and if they get the signal &quot;Number Engaged&quot;, they put down the receiver and, if not already called, they try &quot;some&quot; seconds later. Of course, this may coincide with the next effort of the other party, but as a rule the connection is reestablished succesfully after very few trials. In our mechanical circumstances, however, we cannot accept this pattern of behaviour: our parties might very well be identical!</p>						<p>Quite a collection of trial solutions have been shown to be incorrect and at some moment people that had played with the problem started to doubt whether it could be solved at all. To the Dutch mathematician Th.J.Dekker the credit is due for the first correct solution. It is, in fact, a mixture of our previous efforts: it uses the &quot;safe sluice&quot; of our last constructions, together with the integer &quot;<code>turn</code>&quot; of the first one, but only to resolve the indeterminateness when neither of the two immediately succeeds. The initial value of &quot;<code>turn</code>&quot; could have been 2 as well.</p>						<p class="noindent"><code><u>begin</u> <u>integer</u> c1, c2 turn;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c1:= 1; c2:= 1; turn = 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parbegin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process 1: <u>begin</u> A1: c1:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L1: <u>if</u> c2 = 0 <u>then</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>if</u> turn = 1 <u>then</u> <u>goto</u> L1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c1:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B1: <u>if</u> turn = 2 <u>then</u> <u>goto</u> B1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> A1<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;critical section 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn:= 2; c1:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remainder of cycle 1; <u>goto</u> A1<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process 2: <u>begin</u> A2: c2:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L2: <u>if</u> c1 = 0 <u>then</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>if</u> turn = 2 <u>then</u> <u>goto</u> L2;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c2:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B2: <u>if</u> turn = 1 <u>then</u> <u>goto</u> B2;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> A2<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;critical section 2;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn:= 1; c2:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remainder of cycle 2; <u>goto</u> A2<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parend</u><br>								<u>end</u> .</code></p>						<p>We shall now prove the correctness of this solution. Our first observation is that each process only operates on its own &quot;<code>c</code>&quot;. As a result process 1 inspects &quot;<code>c2</code>&quot; only while &quot;<code>c1</code> = 0&quot;, it will only enter its critical section provided it finds &quot;<code>c2</code> = 1&quot;; for process 2 the analogous observation can be made.</p>						<p>In short, we recognize the safe sluice of our last constructions and the solution is safe in the sense that the two processes can never be in their critical sections simultaneously. The second part of the proof has to show that in case of doubt the decision which of the two will be the first to enter cannot be postponed until eternity. Now we should pay some attention to the integer &quot;<code>turn</code>&quot;: we note that assignment to this variable only occurs at the end &#x2014;or, if you wish: as part&#x2014; of critical sections and therefore we can regard the variable &quot;<code>turn</code>&quot; as a constant during this decision process. Suppose that &quot;<code>turn</code> = 1&quot;. Then process 1 can only cycle via <code>Ll</code>, that is with &quot;<code>c1</code> = 0&quot; and only as long as it finds &quot;<code>c2</code> = 0&quot;. But if &quot;<code>turn</code> = 1&quot; then process 2 can only cycle via <code>B2</code>, but this state implies &quot;<code>c2</code> = 1&quot;, so that process 1 cannot and is bound to enter its critical section. For &quot;<code>turn</code> = 2&quot; the mirrored reasoning applies. As third and final part of the proof we observe that stopping, say, process 1 in &quot;<code>remainder of cycle 1</code>&quot; will not restrict process 2: the relation &quot;<code>c1</code> = 1&quot; will then hold and process 2 can enter its critical section gaily, quite independent of the current value of &quot;<code>turn</code>&quot;. And this completes the proof of the correctness of Dekker's solution. Those readers that fail to appreciate its ingenuity are kindly asked to realize, that for them I have prepared the ground by means of a carefully selected set of rejected constructions.</p>						<p class="noindent"><a name="2.2. The Generalized Mutual Exclusion Problem"></a><u>2.2. The Generalized Mutual Exclusion Problem</u>.</p>						<p>The problem of section 2.1 has a natural generalization: given <var>N</var> cyclic processes, each with a critical section, can we construct them in such a way, that at any moment at most one of them is engaged in its critical section? We assume the same means of intercommunication available, i.e. a set of commonly accessible variables. Furthermore our so1ution has to satisfy the same requirements, that stopping one process well outside its critical section may in no way restrict the freedom of the others, and that if more than one process is about to enter its critical section, it must be impossible to devise for them such finite speeds, that the decision which one of them is the first one to enter its critical section, can be postponed until eternity.</p>						<p>In order to be able to describe the solution in ALGOL 6O, we need the concept of the array. In section 2.1 we had to introduce a &quot;<code>c</code>&quot; for each of the two processes and we did so by declaring</p>						<blockquote>							<blockquote>								<code><u>integer</u> <u>array</u> c1, c2&nbsp;&nbsp;.</code></blockquote>						</blockquote>						Instead of enumerating the quantities, we can declare &#x2014;under the assumption that &quot;<code>N</code>&quot; has a well defined positive value&#x2014;						<blockquote>							<blockquote>								<code>integer array c[1 : N]</code></blockquote>						</blockquote>						which means, that at one stroke we have introduced <var>N</var> integers, accessible under the names						<blockquote>							<code>c[subscript],</code></blockquote>						where &quot;<code>subscript</code>&quot; might take the values 1, 2, ....... <var>N</var>.						<p>The next new ALGOL 60 feature we shall use is the so-called &quot;for clause&quot;, which we shall use in the following form:</p>						<blockquote>							<code><u>for</u> j:= 1 <u>step</u> 1 <u>until</u> N <u>do</u> <var>statement S</var> </code>,</blockquote>						and which enables us to express repetition of &quot;<code><var>statement S</var></code>&quot; quite conveniently. In principle, the <code>for</code> clause implies that &quot;<code><var>statement S</var></code>&quot; will be executed <var>N</var> times, with &quot;<code>j</code>&quot; in succession = 1, = 2, ......, = <var>N</var>. (We have added &quot;in principle&quot;, for via a goto statement as constituent part of <var><code>statement S</code></var> and leading out of it, the repetition can be ended earlier.)						<p>Finally we need the logical operator that in this monograph is denoted by &quot;and&quot;. We have met the conditional clause in the form:</p>						<blockquote>							<code><u>if</u> <var>condition</var> <u>then</u> <var>statement</var> .</code></blockquote>						We shall now meet:						<blockquote>							<code><u>if</u> <var>condition</var> 1 <u>and</u> <var>condition</var> 2 <u>then</u> <var>statement S</var> .</code></blockquote>						meaning that <var><code>statement S</code></var> will only be executed if &quot;<var><code>condition</code></var> 1&quot; and &quot;<code><var>condition</var></code> 2&quot; are both satisfied. (Once more we should like to stress that this monograph is not an ALGOL 60 programming manual: the above &#x2014;loose!&#x2014; explanations of ALGOL 6O have only been introduced to make this monograph as self-contained is possible.)						<p>With the notational aids just sketched we can describe our solution for fixed <var>N</var> as follows.</p>						<p>The overall structure is:</p>						<p class="noindent"><code><u>begin</u> <u>integer</u> <u>array</u> b, c[O : N];<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>integer</u> turn;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>for</u> turn:= 0 <u>step</u> 1 <u>until</u> N <u>do</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> b[turn]:= 1 <u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parbegin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process 1: <u>begin</u>.....................<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process 2: <u>begin</u>.....................<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process N: <u>begin</u>.....................<u>end</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parend</u><br>								<u>end</u> .</code></p>						<p>The first declaration introduces two arrays with <var>N</var> + 1 elements each, the next declaration introduces a single integer &quot;<code>turn</code>&quot;. In the following <u><code>for</code></u> clause this variable &quot;<code>turn</code>&quot; is used to take on the successive values 1, 2, 3,......, <var>N</var>, so that the two arrays are initialized with all elements = 1. Then &quot;<code>turn</code>&quot; is set = 0 (i.e. none of the processes, numbered from 1 onwards, is privileged). After this the <var>N</var> processes are started simultaneously.</p>						<p>The <var>N</var> processes are all similar. The structure of the <var>i</var>-th process is as follows (1&nbsp;&#x2264;&nbsp;<var>i</var>&nbsp;&#x2264;&nbsp;<var>N</var>) :</p>						<p class="noindent"><code>process i: <u>begin</u> <u>integer</u> i;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Ai: b[i]:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Li: <u>if</u> turn &#x2260; i <u>then</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> c[i]:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> b[turn] = 1 <u>then</u> turn:= i;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> Li<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c[i]:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>for</u> j:= 1 <u>step</u> 1 <u>until</u> N <u>do</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> if j &#x2260; i <u>and</u> c[j] = 0 <u>then</u> <u>goto</u> Li <u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;critical section i<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;turn:= 0; c[i]:= 1; b[i]:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remainder of cycle i; <u>goto</u> Ai<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u> .</code></p>						<p class="noindent">Remark. The description of the <var>N</var> individual processes starts with declaration <code>&quot;<u>integer</u> j</code>&quot;. According to the rules of ALGOL 60 this means that each process introduces its own, private integer &quot;<code>j</code>&quot; (a so-called &quot;local quantity&quot;).</p>						<p>We leave the proof to the reader. It has to show again:<br>							1) that at any moment at most one of the processes is engaged in its critical section<br>							2) that the decision which of the processes is the first to enter its critical section cannot be postponed until eternity<br>							3) that stopping a process in its &quot;remainder of cycle&quot; has no effect upon the others.</p>						<p>Of these parts, the second one is the most difficult one. (Hint: as soon as one of the processes has performed the assignment &quot;<code>turn:= i</code>&quot;, no new processes can decide to assign their number to <code>turn</code> before a critical section has been completed. Mind that two processes can decide &quot;simultaneously&quot; to assign their<var> </var><code>i</code>-value to <code>turn</code>!)</p>						<p>(Remark, that can be skipped at first reading.) The program just described inspects the value of &quot;<code>b[turn]</code>&quot; where both the array &quot;<code>b</code>&quot; and the integer &quot;<code>turn</code>&quot; are in common store. We have stated that inspecting a single variable is an indivisible action and inspecting &quot;<code>b[turn]</code>&quot; can therefore only mean: inspect the value of &quot;<code>turn</code>&quot;, and if this happens to be = 5, well, then inspect &quot;<code>b[5]</code>&quot;. Or, in more explicit ALGOL:</p>						<p class="noindent"><code>process i:= <u>begin</u> <u>integer</u> j, k;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;k:= turn; <u>if</u> b[k] = 1 <u>then</u>........ ,</code></p>						<p class="noindent">implying that by the time that &quot;<code>b[k]</code>&quot; is inspected, &quot;<code>turn</code>&quot; may slready have a value different from the current one of &quot;<code>k</code>&quot;.<br>							Without the stated limitations in communicating with the common store, a possible interpretation of &quot;the value of <code>b[turn]</code>&quot; would have been &quot;the value of the element of the array <code>b</code> as indicated by the current value of <code>turn</code>&quot;. In so-called uniprogramming &#x2014;i.e. a single seouential process operating on quantities local to it&#x2014; the two interpretations are equivalent. In multiprogramming, where other active processes may access and change the same common information, the two interpretations make a great difference: In particular for the reader with extensive experience in uniprogramming this remark has been inserted as an indication of the subtleties of the games we are playing.</p>						<p class="noindent"><a name="2.3. A Linguistic Interlude"></a>2.3.<u> A Linguistic Interlude.</u></p>						<div>							</div>						<blockquote>							<div>								(This section may be skipped at first reading.)</div>						</blockquote>						<p>In section 2.2. we described the cooperation of <var>N</var> processes; in the overall structure we used a vertical sequence of dots between the brackets &quot;<code><u>parbegin</u></code>&quot; and &quot;<code><u>parend</u></code>&quot;. This is nothing but a loose formalism, suggesting to the human reader how to compose in our notation a set of <var>N</var> cooperating sequential processes, under the condition that the value of <var>N</var> has been fixed beforehand. It is a suggestion for the construction of 3, 4 or 5071 cooperating processes, it does not give a formal description of <var>N</var> such cooperating processes in which <var>N</var> occurs as a parameter, i.e. it is not a description, valid for amy value of <var>N</var>.</p>						<p>It is the purpose of this section to show that the concept of the so-called &quot;recursive procedure&quot; of ALGOL 60 caters for this. This concept will be sketched briefly.</p>						<p>We have seen, how after &quot;<code><u>begin</u></code>&quot; declarations could occur in order to introduce and to name either single varibles (by enumeration of their names) or whole ordered sets af variables (viz. in the array declaration}. With the so-called &quot;procedure declaration&quot; we can define and name a certain action; such an action may then be invoked by using its name as a statement, thereby supplying the parameters, to which the action should be applied.<br>						</p>						<p>As an illustration we consider the following ALGOL 6O program:</p>						<p class="noindent"><code><u>begin</u> <u>integer</u> a, b;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>procedure</u> square(u, v); <u>integer</u> u, v;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> u:= v * v <u>end</u>;<br>								&nbsp;&nbsp;&nbsp;L: square(a, 3); square(b, a); square(a, b)<br>								<u>end</u> .</code></p>						<p>In the first line the integer named &quot;<code>a</code>&quot; and &quot;<code>b</code>&quot; are declared. The next line declares the procedure named &quot;<code>square</code>&quot;, operating on two parameters, which are specified to be single integers (and not, say, complete arrays). This line is called &quot;the procedure heading&quot;. The immediately following statement &#x2014;the so-called &quot;procedure body&quot;&#x2014; describes by definition the action named: in the third line &#x2014;in which the bracket pair &quot;<code><u>begin</u>....<u>end</u></code>&quot; is superfluous&#x2014; it is told that the action of &quot;<code>square</code>&quot; is to assign to the first parameter the square of the value of the second one. Then, labeled &quot;<code>L</code>&quot;, comes the first statement. Before its execution the values of both &quot;<code>a</code>&quot; and &quot;<code>b</code>&quot; are undefined, after its execution &quot;<code>a</code> = 9&quot;. After the execution of the next statement, the value of &quot;<code>b</code>&quot; is therefore = 81, after the execution of the last statement, the value of &quot;<code>a</code>&quot; is =6561, the value of &quot;<code>b</code>&quot; is still = 81.</p>						<p>In the previous example the procedure mechanism was essentially introduced as a means for abreviation, a means for avoiding to have to write down the &quot;body&quot; three times, although we could have done so quite easily:</p>						<p class="noindent"><code><u>begin</u> <u>integer</u> a, b;<br>								&nbsp;&nbsp;&nbsp;&nbsp;L: a:= 3 * 3; b:= a * a; a:= b * b<br>								<u>end</u> </code>.</p>						<p>When the body is much more complicated than in this example, a program along the latter lines tends indeed to be much more lengthy.</p>						<p>This technique of &quot;substituting for the call the appropriate version of the body&quot; is, however, no longer possible as soon as the procedure is a so-called recursive one, i.e. may call itself. It is then, that the procedure really enlarges the expressive power of the programming language.</p>						<p>A simple example might illustrate the recursive procedure. The greatest common divisor of two given natural numbers is<br>							1) if they have the same value equal to this value<br>							2) if they have different values equal to the greatest common divisor of the smallest of the two and their difference.</p>						In other words, if the greatest common divisor is not trivial (first case) the problem is replaced by finding the greatest common divisor of two smaller numbers.<br>						<br>						(1n the following program the insertion &quot;<code><u>value</u> v, w;</code>&quot; can be skipped by the reader as being irrelevant for our present purposes; it indicates that for the parameters listed the body is only interested in the numerical value of the actual parameter, as supplied by the call.)						<p class="noindent"><code><u>begin</u> <u>integer</u> a;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>procedure</u> GCD(u, v, w); value v, w; <u>integer</u> u, v, w;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>if</u> v = w <u>then</u> u:= v<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>else</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>if</u> v &lt; w <u>then</u> GCD(u, v, w - v)<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>else</u> GCD(U, v -w, w)<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;GCD(a, 12, 53)<br>								<u>end</u> </code>.</p>						<p>(In this example the more elaborate form of the conditional statement is used, viz.:</p>						<blockquote>							<code><u>if</u> <var>condition</var> <u>then</u> <var>statement 1</var> <u>else</u> <var>statement 2</var>&nbsp;&nbsp;</code> ,</blockquote>						meaning that if &quot;<var><code>condition</code></var>&quot; is satisfied,&quot;<code><var>statement&nbsp;1</var></code>&quot; will be executed and &quot;<code><var>statement&nbsp;2</var></code>&quot; will be skipped, and that if &quot;<var><code>condition</code></var>&quot; is not satisfied, &quot;<code><var>statement&nbsp;1</var></code>&quot; will be skipped and &quot;<code><var>statement&nbsp;2</var></code>&quot; will be executed.)						<p>The reader is invited to follow the pattern of calls of GCD and to see, how the variable &quot;<code>a</code>&quot; becomes = 3; he is also invited to convince himself of the fact that the (dynamic) pattern of calls depends on the parameters supplied and that the substitution technique &#x2014;replace call by body&#x2014; as applied in the previous example would lead to difficulties here.</p>						<p>We shall now write a program to perform a matrix * vector multiplication in which<br>							1) the order of the <var>M</var> scalar * scalar products to be summed is indeed prescribed (the rows of the matrix will be scanned from left to right)<br>							2) the <var>N</var> rows of the matrix can be processed in parallel.</p>						<p>(Where we do not wish to impose the restriction of purely integer values, we have used to declarator &quot;<code><u>real</u></code>&quot; instead of the declarator &quot;<code><u>integer</u></code>&quot;; furthermore we have introduced an array with two subscripts in a, we hope, obvious manner.)</p>						<p>It is assumed that, upon entry of this block of program, the integers &quot;<code>M</code>&quot; and &quot;<code>N</code>&quot; have positive values.</p>						<p class="noindent"><code><u>begin</u> <u>real</u> <u>array</u> matrix[1 : N, 1 : M];<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>real</u> <u>array</u> vector[l : M];<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>real</u> <u>array</u> product[l : N];<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>procedure</u> <u>rowmult</u>(k); <u>value</u> k; <u>integer</u> k;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>if</u> k &gt; O <u>then</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parbegin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> <u>real</u> s; <u>integer</u> j;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>for</u> j:= 1 <u>step</u> 1 <u>until</u> M <u>do</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s:= s + matrix[k, j] * vector[j];<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;product[k]:= s<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rowmult(k -1)<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parend</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rowmult(N);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								<u>end</u></code></p>						<p class="noindent"><code><u><a name="3. The Mutual Exclusion Problem Revisited."></a></u></code><u>3. The Mutual Exclusion Problem Revisited.</u></p>						<p>We return to the problem of mutual exclusion in time of critical sections, as introduced in section 2.1 and generalized in section 2.2. This section deals with a more efficient technique for solving this problem; only after having done so, we have adequate means for the description of examples, with which I hope to convince the reader of the rather fundamental importance of the mutual exclusion problem. In other words, I must appeal to the patience of the wondering reader (suffering, as I am, from the sequential nature of human communication!)</p>						<p class="noindent"><a name="3.1. The Need for a More Realistic Solution."></a><u>3.1. The Need for a More Realistic Solution.</u></p>						<p>The solution given in section 2.2 is interesting in as far as it shows that the restricted means of communication provided are, from a theoretical point of view, sufficient to solve the problem. From other points of view, which are just as dear to my heart, it is hopelessly inadequate.</p>						<p>To start with, it gives rise to a rather cumbersome description of the individual processes, in which it is all but transparent that the overall behaviour is in accordance with the conceptually so simple requirement of the mutual exclusion. In other words, in some way or another this solution is a tremendous mystification. Let us try to isolate in our minds in which respect this solution represents indeed a mystification, for this investigation could give the clue to improvement.</p>						<p>Let us take the period of time during which one of the processes is in its critical section. We all know, that during that period, no other processes can enter their critical section and that, if they want to do so, they have to wait until the current critical section execution has been completed. For the remainder of that period hardly any activity is required from them: they have to wait anyhow, and as far as we are concerned &quot;they could go to sleep&quot;.</p>						<p>Our solution does not reflect this at all: we keep the processes busy setting and inspecting common variables all the time, as if no price has to be paid for this activity. But if our implementation &#x2014;i.e. the ways in which or the means by which these processes are carried out&#x2014; is such, that &quot;sleeping&quot; is a less expensive activity than this busy way of waiting, then we are fully justified (now also from an economic point of view) to call our solution misleading.</p>						<p>In present day computers, there are at least two ways in which this active way of waiting can be very expensive. Let me sketch them briefly. These computers have two distinct parts, usually called &quot;the processor&quot; and &quot;the store&quot;. The processor is the active part, in which the arithmetic and logical operations are performed, it is &quot;active and small&quot;; in the store, which is &quot;passive and large&quot; resides at any moment the information, which is not processed at that very moment but only kept there for future reference. In the total computational process information is transported from store to processor as soon as it has to play an active role, the information in store can be changed by transportation in the inverse direction.</p>						<p>Such a computer is a very flexible tool for the implementation of sequential processes. Even a computer with only one single processor can be used to implement a number of concurrent sequential processes. From a macroscopic point of view it will seem, as though all these processes are carried out simultaneously, a more closer inspection will reveal, however, that at any &quot;microscopic&quot; moment the processor helps along only one single program, and the overall picture only results, because at well chosen moments the processor will switch over from one process to another. In such an implementation the different processes share the same processor and activity of one of the processes (i.e. a non-zero speed) will imply a zero speed for the others and it is then undesirable, that precious processor time is consumed by processes, which cannot go on anyhow.</p>						<p>Apart from processor sharing, the store sharing could make the unnecessary activity of a waiting process undesirable. Let us assume that inspection of or assignment to a &quot;common variable&quot; implies the access to an information unit &#x2014;a so-called &quot;word&quot;&#x2014; in a ferrite core store. Access to a word in a core store takes a finite time and for technical reasons only one word can be accessed at a time. When more than one active process may wish access to words of the same core store, the usual arrangement is that in the case of immanent coincidence, the storage access requests from the different active processes are granted according to a built in priority rule: the lower priority process is automatically held up. (The literature refers to this situation when it describes &quot;a communication channel stealing a memory cycle from the processor.) The result is that frequent inspection of common variables may slow down the process, the local quantities of which are stored in the same core store.<br>						</p>						<p class="noindent"><a name="3.2. The Synchronizing Primitives."></a><u>3.2. The Synchronizing Primitives.</u></p>						<p>The origin of the complications, which lead to such intricate solutions as the one described in section 2.2 is the fact that the indivisible accesses to common variables are always &quot;one-way information traffic&quot;: an individual process can either assign a new value or inspect a current value. Such an inspection itself, however, leaves no trace for the other processes and the consequence is that, when a process want to react to the current value of a common variable, its value may be changed by the other processes between the moment of its inspection and the following effectuation of the reaction to it. In other words: the previous set of communication facilities must be regarded as inadequate for the problem at hand and we should lock for better adapted alternatives.</p>						<p>Such an alternative is given by introducing<br>							a) among the common variables special purpose integers, which we shall call &quot;semaphores&quot;.<br>							b) among the repertoire of actions, from which the individual processes have to be constructed, two new primitives, which we call the &quot;P-operation&quot; and the &quot;V-operation&quot; respectively. The latter operations always operate upon a semaphore and represent the only way in which the concurrent processes may access the semaphores.</p>						<p>The semaphores are essentially non-negative integers; when only used to solve the mutual exclusion problem, the range of their values will even be restricted to &quot;0&quot; and &quot;1&quot;. It is the merit of the Dutch physicist and computer designer Drs.C.S.Scholten to have demonstrated a considerable field of applicability for semaphores that can also take on larger values. When there is a need for distinction, we shall talk about &quot;binary semaphores&quot; and &quot;general semaphores&quot; respectively. The definition of the P- and V-operation that I shall give now, is insensitive to this distinction.</p>						<p class="noindent"><u>Definition</u>. The V-operation is an operation with one argument, which must be the identification of a semaphore. (If &quot;<var>S</var>1&quot; and &quot;<var>S</var>2&quot; denote semaphores, we can write &quot;V(<var>S</var>1)&quot; and &quot;V(<var>S</var>2)&quot;.) Its function is to increase the value of its argument semaphore by 1; this increase is to be regarded as an indivisible operation.</p>						<p>Note, that this last sentence makes &quot;V(<var>S</var>1)&quot; inequivalent to &quot;<var>S</var>1 := <var>S</var>1 + 1&quot;.<br>							For suppose, that two processes <var>A</var> and <var>B</var> both contain the statement &quot;V(<var>S</var>1)&quot; and that both should like to perform this statement at a moment when, say, &quot;<var>S</var>1 = 6&quot;. Excluding interference with <var>S</var>1 from other processes, <var>A</var> and <var>B</var> will perform their V-operations in an unspecified order &#x2014;at least: outside our control&#x2014; and after the completion of the second V-operation the final value of <var>S</var>1 will be = 8. If <var>S</var>1 had not been a semaphore but just an ordinary common integer, and if processes <var>A</var> and <var>B</var> had contained the statement &quot;<var>S</var>1:= <var>S</var>1 + 1&quot; instead of the V-operation on <var>S</var>1, then the following could happen. Process <var>A</var> evaluates &quot;<var>S</var>1 + 1&quot; and computes &quot;7&quot;; before effecting, however, the assignment of this new value, process <var>B</var> has reached the same stage and also evaluates &quot;<var>S</var>1 + 1&quot;, computing &quot;7&quot;. Thereafter both processes assign the value &quot;7&quot; to <var>S</var>1 and one of the desired increases has been lost. The requirement of the &quot;indivisible operation&quot; is meant to exclude this occurrence, when the V-operation is used.</p>						<p class="noindent"><u>Definition</u>. The P-operation is an operation with one argument, which must be the identification of a semaphore. (If &quot;<var>S</var>1&quot; and &quot;<var>S</var>2&quot; denote semaphores, we can write &quot;P(<var>S</var>1)&quot; and &quot;P(<var>S</var>2)&quot;.) Its function is to decrease the value of its argument semaphore by 1 as soon as the resulting value would be non-negative. The completion of the P-operation &#x2014;i.e. the decision that this is the appropriate moment to effectuate the decrease and the subsequent decrease itself&#x2014; is to be regarded as an indivisible operation.</p>						<p>It is the P-operation, which represents the potential delay, viz. when a process initiates a P-operation on a semaphore, that at that moment is = 0, in that case this P-operation cannot be completed until another process has performed a V-operation on the same semaphore and has given it the value &quot;1&quot;. At that moment, more than one process may have initiated a P-operation on that very same semaphore. The clause that completion of a P-operation is an indivisible action means that when the semaphore has got the value &quot;1&quot;, only one of the initiated P-operations on it is allowed to be completed. Which one, again, is left unspecified, i,e, at least outside our control.<br>						</p>						<p>At the present stage of our discussions we shall take the implementability of the P-and V-operations for granted.</p>						<p class="noindent"><a name="3.3. The Synchronizing Primitives Applied to the Mutual Exclusion Problem."></a><u>3.3. The Synchronizing Primitives Applied to the Mutual Exclusion Problem.</u></p>						<p>The solution of the <var>N</var> processes, each with a critical section, the executions of which must exclude one another in time (see section 2.2) is now trivial. It can be done with the aid of a single binary semaphore, say &quot;<code>free</code>&quot;. The value of &quot;<code>free</code>&quot; equals the number of processes allowed to enter their critical section now, or:<br>							<br>							&quot;<code>free</code> = 1&quot; means: none of the processes is engaged in its critical section<br>							&quot;<code>free</code> = 0&quot; means: one of the processes is engaged in its critical section.<br>							The overall structure of the solution becomes:<br>							<br>							<code><u>begin</u> <u>integer</u> free; free:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;<u>parbegin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;<u>process</u> 1: <u>begin</u>...............<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;<u>process</u> 2: <u>begin</u>...............<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>								&nbsp;&nbsp;&nbsp;&nbsp;<u>process</u> N: <u>begin</u>...............<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;<u>parend</u><br>								<u>end</u></code></p>						<p class="noindent"><code>with the i-th process of the form:<br>							</code></p>						<p class="noindent"><code><u>process</u> i: <u>begin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Li: P(free); critical section i; V(free);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;remainder of cycle i; <u>goto</u> Li<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u></code></p>						<p></p>						<p class="noindent"><a name="4. The General Semaphore."></a><u>4. The General Semaphore.</u></p>						<p class="noindent"><a name="4.1. Typical Uses of the General Semaphore."></a><u>4.1. Typical Uses of the General Semaphore.</u></p>						<p>We consider two processes, which are called the &quot;producer&quot; and the &quot;consumer&quot; respectively. The producer is a cyclic process and each time it goes through its cycle it produces a certain portion of information, that has to be processed by the consumer. The consumer is also a cyclic process and each time it goes through its cycle, it can process the next portion of information, as has been produced by the producer. A simple example is given by a computing process, producing as &quot;portions of information&quot; punched cards images to be punched out by a card punch, which plays the role of the consumer.</p>						<p>The producer-consumer relation implies a one-way communication channel between the two processes, along which the portions of information can be transmitted. We assume the two processes to be connected for this purpose via a buffer with unbounded capacity, i.e. the portions produced need not to be consumed immediately, but they may queue in the buffer. The fact that no upper bound has been given for the capacity of the buffer makes this example slightly unrealistic, but this should not trouble us too much now.</p>						<p>(The origin of the name &quot;buffer&quot; becomes understandable as soon as we investigate the consequences of its absence, viz. when the producer can only offer its next portion after the previous portion has been actually consumed. In the computer - card punch example, we may assume that the card punch can punch cards at a constant speed, say 4 cards per second. Let us assume, that this output speed is well matched with the production speed, i.e. that the computer can perform the card image production process with the same average speed. If the connection between computing process and card punch is unbuffered, then the couple will only work continuously at full speed when the card production process produces a card every quarter of a second. If, however, the nature of the computing process is such, that after one or two seconds vigorous computing it produces 4 to 8 card images in a single burst, then unbuffered connection will result in a period of time, in which the punch will stand idle (for lack of information), followed by a period in which the computing process has to stand idle, because it cannot get rid of the next card image before the preceding one has been actually punched. Such irregularities in production speed, however, can be smoothed out by a buffer of sufficient size and that is, why such a queuing device is called &quot;a buffer&quot;.)</p>						<p>In this section we shall not deal with the various techniques of implementing a buffer. It must be able to contain successive portions of information, it must therefore be a suitable storage medium, accessible to both processes. Furthermore, it must not only contain the portions themselves, it must also represent their linear ordering. (In the literature two well-known techniques are described by &quot;cyclic buffering&quot; and &quot;chaining&quot; respectively.) When the producer has prepared its next portion to be added to the buffer, we shall indicate this action simply by &quot;add portion to buffer&quot;, without going into further details; similarly, the consumer will &quot;take portion from buffer&quot;, where it is understood that it will be the oldest portion, still in the buffer. (Another name of a buffer is a &quot;first-In-first-Out-Memory.)</p>						<p>Omitting in the outermost block any declarations for the buffer, we can now construct the two processes with the aid of a single general semaphore, called &quot;number of queuing portions&quot;.</p>						<p class="noindent"><code><u>begin</u> <u>integer</u> number of queuing portions;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of queuing portions:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parbegin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;producer: <u>begin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;again 1: produce the next portion;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add portion to buffer;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V(number of queuing portions);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> again1<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consumer: <u>begin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;again 2: P(number of queuing portions);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;take portion from buffer;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process portion taken;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> again 2<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parend</u><br>								<u>end</u></code></p>						<p>The first line of the producer represents the coding of the process which forms the next portion of information; it can be conceived &#x2014;it has a meaning&#x2014; quite independent of the buffer for which this portion is intended; when it has been executed the next portion has been succesfully completed, the completion of its construction can no longer be dependent on other (unmentioned) conditions. The second line of coding represents the actions, which define the finished portions as the next one in the buffer; after its execution the new portion has been added completely to the buffer, apart from the fact that the consumer does not know it yet. The V-operation finally confirms its presence, i.e. signals it to the consumer. Note, that it is absolutely essential, that the V-operation is preceded by the <u>complete</u> addition of the portion. About the structure of the consumer analogous remarks can be made.</p>						Particularly in the case of buffer implementation by means of chaining it is not unusual that the operations &quot;add portion to buffer&quot; and &quot;take portion from buffer&quot; &#x2014;operating as they are on the same clerical status information of the buffer&#x2014; could interfere with each other in a most undesirable fashion, unless we see to it, that they exclude each other in time. This can be catered for by a binary semaphore, called &quot;buffer manipulation&quot;, the values of which mean:<br>						<br>						= 0 : either adding to or taking from the buffer is taking place<br>						= 1 : neither adding to nor taking from the buffer is taking place.<br>						<p>The program is as follows:<br>						</p>						<p class="noindent"><code><u>begin</u> <u>integer</u> number of queuing portions, buffer manipulation;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of queuing portions:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer manipulation:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parbegin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;producer: <u>begin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;again 1: produce next portion;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P(buffer manipulation) ;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add portion to buffer;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V(number of queuing portions);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> again 1<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consumer: <u>begin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;again 2: P(number of queuing portions);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;take portion from buffer;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process portion taken;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> again 2<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>end</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parend</u><br>								<u>end</u></code></p>						<p>The reader is requested to convince himself that<br>							a) the order of the two V-operations in the producer is immaterial<br>							b) the order of the two P-operations in the consumer is essential.</p>						<p>Remark. The presence of the binary semaphore &quot;buffer manipulation&quot; has another consequence. We have given the program for one producer and one consumer, but now the extension to more producers and/or more consumers is straightforward: the same semaphore sees to it that two or more additions of new portions will never get mixed up and the same applies to two or more takings of a portion by different consumers. The reader is requested to verify that the order of the two V-operations in the producer is still immaterial.</p>						<p class="noindent"><a name="4.2. The Superfluity of the General Semaphore."></a><u>4.2. The Superfluity of the General Semaphore.</u></p>						<p>In this section we shall show the superfluity of the general semaphore and we shall do so by rewriting the last program of the previous section, using binary semaphores only. (Intentionally I have written &quot;we shall show&quot; and not &quot;we shall prove the superfluity&quot;. We do not have at our disposal the mathematical apparatus that would be needed to give such a proof and I do not feel inclined to develop such mathematical apparatus now. Nevertheless I hope that my show will be convincing!) We shall first give a solution and postpone the discussion till afterwards.</p>						<p class="noindent"><code><u>begin</u> <u>integer</u> numqueupor, buffer manipulation, consumer delay;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numqueupor:= 0; buffer manipulation:= 1; consumer delay:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parbegin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;producer: <u>begin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;again 1: produce next portion;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add portion to buffer:<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numqueupor:= numqueupor + 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> numqueupor = 1 <u>then</u> V(consumer delay);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> again 1<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consumer: <u>begin</u> &nbsp;<u>integer</u> oldnumqueupor;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait: &nbsp;P(consumer delay);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;go on: P(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;take portion from buffer;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numqueupor:= numqueupor -1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;oldnumqueupor:= numquepor;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V(buffer manipulation) ;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process portion taken;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> oldnumqueupor = 0 <u>then</u> goto wait else <u>goto</u> go on<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parend</u><br>								<u>end</u> .</code></p>						<p>Relevant in the dynamic behaviour of this program are the periods of time during which the buffer is empty. (As long as the buffer is not empty, the consumer can go on happily at its maximum speed.) Such a period can only be initiated by the consumer (by taking the last portion present from the buffer), it can only be terminated by the producer (by adding a portion to an empty buffer). These two events can be detected unambiguously, thanks to the binary semaphore &quot;buffer manipulation&quot;, that guarantees the mutual exclusion necessary for this detection. Each such period is accompanied by a P- and a V-operation on the new binary semaphore &quot;consumer delay&quot;. Finally we draw attention to the local variable &quot;<code>oldnumqueupor</code>&quot; of the consumer: its value is set during the taking of the portion and fixes, whether it was the last portion then present. (The more expert ALGOL readers will be aware that we only need to store a single bit of information, viz. whether the decrease of <code>numqueupor</code> resulted in a value = 0; we could have used a local variable of type <u>Boolean</u> for this purpose.) When the consumer decides to go to &quot;<code>wait</code>&quot; i.e. finds &quot;<code>oldnumqueupor</code> = 0&quot;, at that moment &quot;<code>numqueupor</code>&quot; itself could already be greater than zero again!<br>						</p>						<p>In the previous program the relevant occurrence was the period with empty buffer. One can remark that emptiness is, in itself, rather irrelevant: it only matters, when the consumer should like to take a next portion, which is still absent. We shall program this version as well. In its dynamic behaviour we may expect less P- and V-operations on &quot;consumer delay&quot;, viz. not when the buffer has been empty for a short while, but is filled again in time to make delay of the consumer unnecessary. Again we shall first give the program and then its discussion.</p>						<p class="noindent"><code><u>begin</u> <u>integer</u> numqueupor, buffer manipulation, consumer delay;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numqueupor:= 0; buffer manipulation:= 1; consumer delay:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parbegin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;producer: <u>begin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;again 1: produce next portion;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add portion to buffer;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numqueupor:= numqueupor + 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> numqueupor = 0 <u>then</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> V(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V( consumer delay) end<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>else</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> again 1<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consumer: <u>begin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;again 2: P(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numqueupor:= numnqueupor -1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> numqueupor = -1 <u>then</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>begin</u> V(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P(consumer delay);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P(buffer manipulation) <u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;take portion from buffer;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process portion taken;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>goto</u> again 2<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>end</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parend</u><br>								<u>end</u></code></p>						<p>Again, the semaphore &quot;buffer manipulation&quot; caters for the mutual exclusion of critical sections. The last six lines of the producer could have been formulated as follows:<br>						</p>						<blockquote>							<code><u>if</u> numqueupor = 0 <u>then</u> V(consumer delay);<br>								V(buffer manipulation); <u>goto</u> again 1<br>							</code></blockquote>						In not doing so I have followed a personal taste, viz. to avoid P- and V-operations within critical sections; a personal taste to which the reader should not pay too much attention.						<p>The range of possible values of &quot;<code>numqueupor</code>&quot; has been extended with the value &quot;-1&quot;, meaning (outside critical section execution) &quot;the buffer is not only empty, but its emptyness has already been detected by the consumer, which has decided to wait&quot;. This fact can be detected by the producer when, after the addition of one, &quot;<code>numqueupor</code> = 0&quot; holds.</p>						<p>Note how, in the case of &quot;<code>numqueupor</code> = -1&quot; the critical section of the consumer is dynamically broken into two parts: this is most essential, for otherwise the producer would never get the opportunity to add the portion that is already so much wanted by the consumer.</p>					</div>					(The program just described is known as &quot;The Sleeping Barber&quot;. There is a barbershop with a separate waiting room. The waiting room has an entry and next to it an exit to the room with the barber's chair, entry and exit sharing the same sliding door which always closes one of them; furthermore the entry is so small that only one customer can enter it at a time, thus fixing their order of entry. The mutual exclusions are thus guaranteed.					<div align="center">						<img src="EWD123figs/EWD123_Pic02.png" alt="" width="303" height="146" border="0"></div>					<div>						<p>When the barber has finished a haircut, he opens the door to the waiting room and inspects it. If the waiting room is not empty, he invites the next customer, otherwise he goes to sleep in one of the chairs in the waiting room. The complementary behaviour of the customers is as follows: when they find zero or more customers in the waiting roam, they just wait their turn, when they find, however, the Sleeping Barber &#x2014;&quot;<code>numqueupor</code> = -1&quot;&#x2014; they wake him up.)</p>						<p>The two programs given present a strong hint to the conclusion that the general semaphore is, indeed, superfluous. Nevertheless we shaal not try to abolish the general semaphore: the one-sided synchronisation restriction expressible by it is a very common one and comparison of the solutions with and without general semaphore shows convincingly that it should be regarded as an adequate tool.</p>						<p class="noindent"><a name="4.3. The Bounded Buffer."></a><u>4.3. The Bounded Buffer.</u></p>						<p>I shall give a last simple example to illustrate the use of the general semaphore. In section 4.1 we have studied a producer and a consumer coupled via a buffer with unbounded capacity. This is a typically one-sided restriction: the producer can be arbitrarily far ahead of the consumer, on the other hand the consumer can never be ahead of the producer. The relation becomes symmetric, if the two are coupled via a buffer of finite size, say <var>N</var> portions. We give the program without any further discussion; we ask the reader to convince himself of the complete symmetry. (&quot;The consumer produces and the producer consumes empty positions in the buffer&quot;.) The value <var>N</var>, as the buffer, is supposed to be defined in the surrounding universe into which the following program should be embedded.</p>						<p class="noindent"><code><u>begin</u> <u>integer</u> number of queuing portions, number of empty positions,<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer manipulation;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of queuing portions:= 0;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number of empty positions:= N;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buffer manipulation:= 1;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parbegin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;producer: <u>begin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;again 1: produce next portion;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P(number of empty positions);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;add portion to buffer;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V(mumber of queuing portions); <u>goto</u> again 1 <u>end</u>;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;consumer: <u>begin</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;again 2: P(number of queuing portions);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P(buffer manipulation);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;take portion from buffer;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V(buffer manipulation) ;<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V(number of empty positions);<br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;process portion taken; <u>goto</u> again 2 <u>end</u><br>								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>parend</u><br>								<u>end</u></code></p>						<p class="noindent"><u>5. <a title="Chapter 5." href="EWD123-2.html#5. Cooperation via Status Variables">Cooperation via Status Variables</a></u>.</p>						<p></p>					</div>				</div>			</div>		</div>	</body></html></div>
  <script>
$('body').tweetSelection({
  height: 300,
  width: 600,
  minimumTextSelected: 3,
  shareClass: '.tweet-selection',
  ellipsis: '...',
  quoteLeft: '"',
  quoteRight: '"',
  via: 'raboofje'
});
  </script>
  </body>
  </html>
