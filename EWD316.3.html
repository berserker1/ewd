  <!DOCTYPE html>
  <html>
  <head>
    <title>A Short Introduction to the Art of Programming (EWD 316), Chapter 3</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <meta name="generator" content="convertArticle.pl">
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>A Short Introduction to the Art of Programming (EWD 316), Chapter 3</h1>
  <div class='body'>				<div id="frame">					<div id="header">						<div align="center">							<p>EWD316: A Short Introduction to the Art of Programming</p>							<p>by</p>							<p>prof.dr.Edsger W.Dijkstra</p>							<p>August 1971</p>						</div>						<div align="left">							<p class="noindent"><a name="contents"></a><u>Contents</u></p>						</div>						<blockquote>							<div align="left">								<div id="frame">									<div id="header">										<blockquote>											<div align="left">												<div id="frame">													<div id="content">														<blockquote>															<div align="left">																<p class="noindent">0. Contents</p>																<p class="noindent">1. <a title="Chapter 1 of EWD 316" href="EWD316.html">Preface</a><br>																	<br>																	2. <a title="Chapter 2 of EWD 316" href="EWD316.2.html">Some Fundamental Notions</a><br>																	<br>																	3. Programming Languages and their Implementation<br>																	<br>																	4. <a title="Chapter 4 of EWD 316" href="EWD316.4.html">Variables and relations between their values</a><br>																	<br>																	5. <a title="Chapter 5 of EWD 316" href="EWD316.5.html">Programs corresponding to recurrence relations</a><br>																	<br>																	6. <a title="Chapter 6 of EWD 316" href="EWD316.6.html">A first example of step-wise program composition</a><br>																	<br>																	7. <a title="Chapter 7 of EWD 316" href="EWD316.7.html">The shortest spanning subtree of a graph</a><br>																	<br>																	8. <a title="Chapter 8 of EWD 316" href="EWD316.8.html">The towers of Hanoi</a><br>																	<br>																	9. <a title="Chapter 9 of EWD 316" href="EWD316.9.html">The problem of eight queens</a><br>																	<br>																	10. <a title="Chapter 10 of EWD 316" href="EWD316.10.html">A rearranging routine</a></p>															</div>														</blockquote>													</div>												</div>											</div>										</blockquote>									</div>								</div>							</div>						</blockquote>					</div>				</div>				<p class="noindent"><u>3. Programming Languages and their Implementation</u></p>				<p>The activity of composing programs is called &quot;programming&quot;. In the preceding section we have introduced programs as algorithms intended to control the behaviour of machines and by virtue of the actual existence of such machines, programming is a very practical activity. It is one of the youngest branches of applied mathematics (in the broad sense of the word, i.e. not confined to mathematical physics or numerical analysis), it is as important as the applications in question, it is practical in the sense that it is the programmer's intention that a machine will actually display the behaviour as prescribed by the algorithm. For that reason a conscious programmer should respect the limitations of the (finite) machines. Alternative programs causing a machine to establish the same net result and therefore in that respect equivalent, may differ greatly in what is usually called &quot;efficiency&quot;, i.e. in the demands they make upon the machine's resources. For many years, efficiency has been used as the sole yard-stick along which to compare the relative quality of alternative programs for the same task. In the meantime, programming has turned out to be so difficult, that other quality aspects have gained relative importance, such as the ease with which we can understand a program, can convince ourselves of its correctness or can modify it, etc. Yet, efficiency concerns cannot be ignored and in order to give the reader some feeling for the nature of the limitations he should respect, we shall give in this section an overall view of computing machines and the way in which they execute programs.</p>				<p>In this little monograph we shall confine our attention to sequential algorithms, i.e. algorithms describing what actions should happen in succession, one after the other. Such algorithms have a property for which they have been blamed (and not entirely without justification), viz. that they are often &quot;overspecific&quot; as regards the order in which things have to happen. If two actions, say &quot;<tt>A</tt>&quot; and &quot;<tt>B</tt>&quot; have both to be done, a purely sequential algorithm will prescribe</p>				<blockquote>					<blockquote>						<p class="noindent">either&nbsp;&nbsp;&nbsp; &quot;<tt>A; B</tt>&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;&nbsp;&nbsp; &quot;<tt>B; A</tt>&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;,</p>					</blockquote>				</blockquote>				<p class="noindent">viz. action <tt>A</tt> followed in time by action <tt>B</tt> or the other way round. It will <u>not</u> express that the order is immaterial and, what is possibly more important, it will not express that the two actions are so &quot;non-interfering&quot; with each other that they may take place concurrently, or &#x2014;to use the jargon&#x2014; may be done in parallel.</p>				<p>For various reasons I have decided to restrict my attention to purely sequential programs. The most obvious reason is to be found in the structure of the machines that are currently available or can be expected to become available in the next years. One or two decades ago, machines used to be purely sequential. In the meantime we have got equipment allowing for a limited amount of parallelism (dual processor machines, independent communication channels etc.), but such pieces of equipment are at best an aggregate of a small number of individual sequential components. In such machines the potential parallelism of activities is exploited by standard control programs (so-called &quot;operating systems&quot;), while the individual user still works in a strictly sequential environment. And it is to the individual user that this little monograph addresses itself.</p>				<p>With the advent of what is called &quot;large scale integration&quot; (being a term from the computer field, its acronym LSI is better known!) it seems to become technically feasible to build machines more like &quot;clouds of arithmetic units&quot; with information processing activities going on simultaneously all over the place, for shorter periods of time even independently of each other. Programming for such machines will pose completely different trade-off problems: one will be willing to invest in potentially useful computing activity before its actual usefulness has been established, all for the sake of speeding up the whole computation. But although I know such machines may be coming, I shall not touch these problems for the following reasons. First, as far as general purpose applications are concerned, I have my doubts about the effectiveness with which such forms of parallelism can ever be exploited. Second &#x2014;and that is the most important consideration&#x2014; parallel programming is an order of magnitude more difficult than sequential programming. (This statement will be doubted but I have enough experience in multiprogramming to feel myself entitled to say so. The point is that with parallelism a great variety of happenings may take place under control of the same program(s). On account of undefined speed ratios a set of parallel programs is written for a partly non-deterministic machine and special care is required to ensure that, on a higher level of abstraction, its total behaviour can again be regarded as uniquely determined by the program(s).) Third, I am not over-impressed by the complaints that sequential programs specify a more stringent time-succession than logically necessary: I have often the somewhat uneasy feeling that these complaints finds their origin in the mathematical tradition of the pre-computer age. In classical mathematics the notion of an algorithm has been neglected; mind you, I am not blaming the previous mathematicians for this because before the actual existence of automatic computers, algorithms were hardly a relevant subject. But we should not close our eyes to the fact that the course of history has caused mathematics to be more tuned to timeless problems to static relations, to functional dependence. (The existence of classical mechanics does not contradict this observation: renaming the independent variable in the differential equations &quot;<i>k</i>&quot;, say, instead of the usual &quot;<i>t</i>&quot; does not influence the mathematics involved.) Some of the efforts to remove the overspecification of the time-succession &#x2014;they rely heavily on functional dependence&#x2014; strike me as tackling the programming problem with classical concepts that have been developed for other purposes. So much for my decision to restrict my considerations to sequential machines.</p>				<p>To get some feeling for the demands made upon the modern automatic computer, let us focus our attention for a moment upon an average sizable computation, for instance, the computation of (a good approximation of) the inverse of a given matrix of, say, 100 by 100 elements. Such a job has two markedly quantitative aspects:</p>				<table width="505" border="0" cellspacing="2" cellpadding="0">					<tr>						<td align="left" valign="top">a)&nbsp;&nbsp;&nbsp;&nbsp;</td>						<td>a vast amount of numbers is involved: posing the problem implies the specification of 10.000 numbers, the answer is also given by 10.000 numbers (each of which is, in general, a function of all 10.000 elements of the given matrix)</td>					</tr>					<tr>						<td valign="top">b)</td>						<td align="left" valign="top">a vast amount of computation has to be done: if it is done by elimination, the number of operations (i.e. multiplications and additions) is of the order of magnitude of 1.000.000.</td>					</tr>				</table>				<p>The construction of machines able to cope (reliably!) with these two very different aspects of &quot;multitude&quot; is one of the greater triumphs of electronics. It has been achieved by applying the old and well-known principle: &quot;Divide and Rule.&quot;. In modern computers one can distinguish two vital components, each of which has the specific task to cope with one of the forms of multitude.</p>				<table width="505" border="0" cellspacing="2" cellpadding="0">					<tr>						<td align="left" valign="top">a)&nbsp;&nbsp;&nbsp;&nbsp;</td>						<td>the store (called &quot;memory&quot; in American); this is the component able to receive, store and return vast amounts of information; its primary function is to be large, to be able to contain very much information</td>					</tr>					<tr>						<td valign="top">b)</td>						<td align="left" valign="top">the arithmetic unit or processor; this is the component in which the actual work &#x2014;adding, subtracting, multiplying, comparing etc.&#x2014; is done; its primary function is to be very fast so that it may do a great deal in a limited period of time.</td>					</tr>				</table>				<p>It is <u>not</u> the function of the arithmetic unit to be large in the sense that it should contain large amounts of information. On the contrary: while nearly all the information, relevant for te computation at large, lies &quot;sleeping&quot; in the store, at any moment of time only the tiny fraction actually involved in the information processing activity is found (copied) in the arithmetic unit, which is only capable of dealing with a few numbers at a time, say the two numbers to be added and the sum formed by the act of addition. Whenever two numbers (in store) are to be added, they are transported from the store to the arithmetic unit, where the sum will be formed; once formed the sum will either be kept in the arithmetic unit for immediate further processing or it will be sent back to store for later processing. Microscopically, the store acts as the icebox in which all information is kept which is not involved in the current activity of the arithmetic unit. If small letters indicate variables in store and <tt><i>R</i></tt> indicates a register in the arithmetic unit, the computation</p>				<blockquote>					<blockquote>						<p class="noindent"><tt>x := (a + b)*(c + d)</tt></p>					</blockquote>				</blockquote>				<p class="noindent">might be evoked by the following sequence of instructions:</p>				<blockquote>					<blockquote>						<p class="noindent"><tt>R:= a;<br>								R:= R + b;<br>								t:= R;<br>								R:= c;<br>								R:= R + d;<br>								R:= t * R;<br>								x:= R</tt></p>					</blockquote>				</blockquote>				<p>The first instruction fetches the value of <tt><i>a</i></tt> from store into the register <tt><i>R</i></tt>, the next one increases (the contents of) <tt><i>R</i></tt> by the value of <tt><i>b</i></tt> (from store). At this stage one of the two factors to be multiplied has been computed. Before the multiplication can take place, the second factor has to have been computed as well; in a machine with a single register <tt><i>R</i></tt> for arithmetic results, this second addition implies again the use of the register <tt><i>R</i></tt>. In order to make this register available for this purpose, the third instruction sends the value of the first factor &#x2014;a so-called &quot;intermediate result&quot;&#x2014; back to store, assigning it to a variable here named &quot;<tt><i>t</i></tt>&quot;: the first sum is sent back to store for later usage. The fourth and fifth instructions compute the second factor, the value of which is left in <tt><i>R</i></tt>, ready for multiplication by the stored valued called &quot;<tt><i>t</i></tt>&quot;. The last instruction stores the product, now formed in <tt><i>R</i></tt>, so that it can be retrieved under the name &quot;<tt><i>x</i></tt>&quot; for later usage.</p>				<p>The above example illustrated many things. It shows how</p>				<blockquote>					<blockquote>						<p class="noindent"><tt>x:= (a + b)*(c + d)</tt> ,</p>					</blockquote>				</blockquote>				<p class="noindent">which on one level of interest can be regarded as a single action, on closer inspection turns put to be a sequential process taking place as a time-succession of seven more primitive sub-actions (&quot;program steps&quot;). It also shows that at any moment in time only a tiny portion of the algorithm is in active control of what actually happens: while the first of the second addition is performed, the fact that the two sums will have to be multiplied is still &quot;dormant&quot;. (If the total action had been</p>				<blockquote>					<blockquote>						<p class="noindent"><tt>x:= (a + b)/(c + d)</tt> ,</p>					</blockquote>				</blockquote>				<p class="noindent">the only modification necessary would have been the replacement of the sixth instruction by</p>				<blockquote>					<blockquote>						<p class="noindent"><tt>R:= t / R</tt> ;</p>					</blockquote>				</blockquote>				<p class="noindent">the first five instructions would have been insensitive to this change. That is what I meant by &quot;dormant&quot;.)</p>				<p>It also demonstrates that, just as at any moment in time, only a tiny fraction of the numerical information is involved in actual processing, also only a tiny fraction of the program exercises control, viz. the instruction currently executed.</p>				<p>It also demonstrates that it is no good just to divide the machine into two components, store and arithmetic unit, but that one must also provide for a (dense) information traffic between the two; this is provided for by what connects the two together, the so called &quot;selection&quot;.</p>				<p>We have said that the store should be able to store information; it must, for instance, be able to store &quot;numbers&quot;, e.g. the intermediate result called &quot;<tt><i>t</i></tt>&quot;. Obviously, these numbers cannot be kept in store like balls in an urn: when the instruction</p>				<blockquote>					<blockquote>						<p class="noindent"><tt>R:= t * R</tt> ;</p>					</blockquote>				</blockquote>				<p class="noindent">has to be executed, the store must not return just any number, but quite definitely it must return the value sent to it two instructions earlier. For that reason the numbers in store are not arranged as balls in an urn, on the contrary! Store is arranged as a number of so-called &quot;storage cells&quot;, each capable of holding the value of one number at a time. Each storage cell is identified by its so-called &quot;address&quot;; each time contact with the store is required &#x2014;either to receive or to return information&#x2014; this request is accompanied by a statement of the address of the storage cell involved. If the store is to receive information &#x2014;this is called &quot;writing into store&quot;&#x2014; the value to be stored and the address of the storage location involved (plus a &quot;write request&quot;) are sent to store and selection respectively; as a result of the writing operation the original contents of the storage cell, which get lost, are replaced by the new value. If the store is to return information &#x2014;this is called &quot;reading from store&quot;&#x2014; the address of the storage cell involved (plus a &quot;read request&quot;) is sent to the selection; as a result the contents of the storage cell are returned from store (and kept in the storage cell as well for later reading if desired). As far as destruction, reception and reproduction of the information contained in a storage cell are concerned, the situation shows great analogy to a tape in a tape recorder. You can use the tape to record as many pieces of music as you want, but only one at the same time: whenever you record a new piece of music on an old tape, its previous contents are wiped out; the piece of music currently recorded, however, can be played back as many times as you wish. (To make the analogy a true one, we must restrict ourselves to pieces of music of equal duration, precisely matched to the length of the tape, matched to its (finite) information capacity.</p>				<p>Storage cells can store information by virtue of the fact that they can be in a finite number of distinct states. In practically all computers they are composed of elementary components, each of which can be in one of two possible states. (The most common form is a little ring of ferromagnetic material that will be circularly magnetized in one of the two possible directions.) One such component can be in 2 different states (say &quot;North&quot; and &quot;South&quot;), two such components can be together in 4 different total states, (&quot;North-North&quot;, &quot;North-South&quot;, &quot;South-North&quot; and &quot;South-South&quot;), <i>N</i> such components together can be in 2<i><sup>N</sup></i> mutually different states. The number of elementary components associated with each storage cell is a characteristic constant of the machine's store and is called &quot;the word length&quot;. If the word length is 32, the number of different possible total states per word is 2<sup>32</sup>, i.e. slightly over 4*10<sup>9</sup>; the arithmetic unit will associate with each state a numerical value; in terms of these numerical values a storage cell can then hold, for instance any integer value ranging from (roughly) &#x2212;2*10<sup>9</sup> to +2*10<sup>9</sup>.</p>				<p>The finite capacity of the storage cell is something the user must be aware of: it is matched to the abilities of the arithmetic unit, i.e. if the latter deals with integer values it is geared to operations up to a certain maximum absolute value, if it deals with (approximations of) real numbers, it is geared to dealing with them in a certain precision, maximum absolute value and precision respectively being chosen such that the numerical values to be distinguished between can be stored in one (or possibly two successive) storage cells. If greater integers or reals in higher precision have to be manipulated, special measures have to be taken which will be more expensive.</p>				<p>In the meantime we have explained enough about the general machine structure to mention to aspects of the &quot;costs&quot; involved in the execution of a program. One of them is computation time. We have seen that the arithmetic unit performs one operation after the other, and the more operations a program prescribes, the longer the total amount of time the arithmetic unit will have to spend to carry the computation to completion. The other one is storage usage. If a thousand values have to be computed in order to be added together, we may compare the following two algorithms. The first one first computes all thousand values and stores them, after which they are added, the second algorithm immediately adds each number to the partial sum as soon as it has been computed. With regard to storage usage the first algorithm is more demanding: at some stage of the computation it requires a sufficient amount of store to hold all thousand values, an amount of store which in the second algorithm, remains available for other (perhaps more useful) purposes.</p>				<p>So much for the finite capacity of each storage cell and the fact that a store contains only a finite number of such cells. Let us return to their addresses: a while ago we hinted that each storage cell is identified by an &quot;address&quot; and that each reference to store takes place under control of the address of the storage cell concerned, but up till now we have not been very explicit about what an address really is. Well, this is very simple: the storage cells are numbered: 0, 1, 2, 3, 4, 5, ... up to and including <i>M</i> - 1 if the store comprises <i>M</i> different storage cells (<i>M</i> between 16.000 and 1.000.000 being typical figures), and the ordinal number of each storage cell is used as &quot;its address&quot; (like houses in a street!) This implies that the storage cells have a natural order, viz. the order of increasing address. Given the address of a storage cell, the address of the next storage cell can be computed by adding 1 to the given address of the preceding one.</p>				<p>This natural ordering of the storage cells is heavily exploited. If a vector, i.e. a sequence of numbers <i>a</i><sub>0</sub>, <i>a</i><sub>1</sub>, ... , <i>a<sub>n</sub></i> has to be stored, its elements can be stored in successive storage cells. If the address of element <i>a</i><sub>0</sub> is known, the address of element <i>a<sub>i</sub></i> can then be computed, viz. by adding (the value of) <i>i</i> to the address of the element <i>a</i><sub>0</sub>.</p>				<p>The natural order of the storage cells is also exploited in the program representation. Remember, we have postulated that a machine could &quot;accept&quot; a program, and that, once the program had been accepted, the machine could execute the program (i.e. cause the happening as prescribed by the program). In other words, when the machine is executing the program, this program &#x2014;i.e. &quot;the information describing how to behave&quot;&#x2014; must be somewhere in the machine! Where? Well, in the store, the store being specifically the machine component able to hold information. In other words, the store is used for two different purposes: it holds the numerical information to be manipulated, but it also holds &#x2014;in some other part of it&#x2014; the program, i.e. the information describing what manipulations have to be performed.</p>				<p>To sketch briefly how this can be done, we return to our previous example, where</p>				<blockquote>					<p class="noindent"><tt>x := (a + b)*(c + d)</tt></p>				</blockquote>				<p class="noindent">was decomposed into the sequence of seven instructions denoted by</p>				<blockquote>					<p class="noindent"><tt>R:= a;<br>							R:= R + b;<br>							t:= R;<br>							R:= c;<br>							R:= R + d;<br>							R:= t * R;<br>							x:= R</tt></p>				</blockquote>				<p class="noindent">and the question is: by means of what conventions do we represent the above information in a store capable of holding numbers? This is achieved by a two-stage convention, one for representing single instructions and one for representing a sequence.</p>				<p>The first convention is to choose for each instruction a unique number code. In the above notation we have denoted variables (or: the addresses of the storage cells associated with the variables and containing their current value) with small letters (<tt><i>a</i></tt>, <tt><i>b</i></tt>, <tt><i>c</i></tt>, <tt><i>d</i></tt>, <tt><i>t</i></tt>, and <tt><i>x</i></tt>); but addresses are numbers and that component is therefore already numerical. Using &quot;<i>s</i>&quot; for &quot;any address&quot; we see that in the above example, we can distinguish instructions of four different types:</p>				<table width="164" border="0" cellspacing="2" cellpadding="0">					<tr>						<td>1.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>						<td><tt>R := </tt><i>s</i></td>					</tr>					<tr>						<td>2.</td>						<td><tt>R := R + </tt><i>s</i></td>					</tr>					<tr>						<td>3.</td>						<td><tt>R := </tt><i>s</i><tt> * R</tt></td>					</tr>					<tr>						<td>4.</td>						<td><tt>s := R</tt></td>					</tr>				</table>				<p class="noindent">The second part of the convention associates with each type of instruction a number (e.g. the numbers 1, 2, 3, and 4 to the types shown above; it should be mentioned that in actual machines the number of instruction types is considerably larger than 4). By concatenating the digits describing the instruction type number with those giving the address we have a number code for each possible instruction and we assume that the word length of the storage cell is sufficient to contain such a number. The first convention as just described, reduces the problem of storing a sequence of instructions to storing a sequence of numbers. Now the second convention is that the sequence as such is represented by storing these numbers in successive storage cells, i.e. storage cells with successive addresses. And this completes (roughly) the trick.</p>				<p>(<u>Note</u>. This is by no means the only way to represent programs inside the machine's store; in so-called &quot;stack machines&quot; other conventions are chosen. The above elaboration is only shown by way of example, demonstrating the possibility.)</p>				<p>The dual role of the store &#x2014;storage of instructions and storage of variables&#x2014; implies another way in which a program can be expensive to execute: if the program text is very long, by that very fact the program text will make a heavy demand on storage capacity. If we have two alternative programs for the same job, one requiring 5000 instructions to describe it and the other requiring 10000 instructions to describe it, then &#x2014;all other things being equal&#x2014; the first alternative will be cheaper.</p>				<p>The above concludes our bird's eye view of the so-called hardware machine, i.e. the physical piece of electronic equipment as it is delivered by the manufacturer: a machine that can accept and then execute programs written as long sequences of instructions from an instruction repertoire that is specific for this particular machine (and its copies). Until the late fifties programmers indeed produced their programs as long sequences of such instructions, but when machines became faster and when more came on the market, the shortcomings of this way of working became more and more apparent.</p>				<p>Because the programmer expressed his program in terms of the instruction repertoire of that particular machine, he was forced to tailor his program to that machine. He needed a thorough and ready knowledge of all the details of the instruction repertoire of that machine &#x2014;which for the more intricate machines was no mean task&#x2014; and worse: once his program was written, it could only be executed by that particular machine. Exchange of programs between institutes equipped with different machines was impossible; furthermore, whenever an institute replaced its old machine by a new and different one, all programs for the old machine became obsolete. From that point of view it was clear that tailoring one's programs so closely to the idiosyncrasies of a specific piece of hardware was not a very wise investment of the intellectual energies of one's programmers.</p>				<p>But even without the problem of transferring programs from one hardware machine to another, this way of programming, expressing programs as a monotonous stream of machine instructions, showed great drawbacks. One serious drawback was that this close contact between programmer and physical machine did not only enable the programmer to lard his program with all sorts of coding tricks, it actually invited him to do so. For many a programmer this temptation became irresistible; there even has been a time when it was generally believed that one of the most vital assets of a virtuoso programmer was that he be &quot;puzzle-minded&quot;, and it was only slowly recognized that a clear and systematic mind was more essential! When &quot;tricky programming&quot; was en vogue, programming was not only very expensive &#x2014;it took too much time&#x2014; it also turned out to be too difficult to get a program correct. Looking back, the period of tricky programming now strikes us as a generation of programmers walking on a tight-rope, in full confidence because they were unaware of the abysmal depth beneath it! The modern competent programmer is more humble and avoids clever tricks like the plague.</p>				<p>It was not only the preponderance of coding tricks that made programming &quot;in machine code&quot; as it is called nowadays, too difficult and too risky.</p>				<p>Firstly, a program in machine code contains very little redundance and as a result it is very sensitive to even small writing errors &#x2014;errors of the level of &quot;spelling mistakes&quot; or &quot;printing errors&quot;.</p>				<p>Secondly, the programmer who thinks in terms of variables has to denote these variables in his program text by the addresses of the storage cells dedicated (by him) to hold their values. As a result the programmer has the burden of storage layout and all the clerical work implied by this.</p>				<p>Thirdly &#x2014;and this is the major reason&#x2014; machine code is an improper vehicle to represent &quot;structure&quot;: it is just a single, monotonous sequence of machine instructions, incapable of expressing in a direct and useful form the structure of the algorithm. In what follows it will become abundantly clear that when we wish to compose programs in a reliable fashion, we can only do so by structuring the happenings we intend to evoke, and that we are in urgent need of a descriptive vehicle such that in the program text itself the structure of the happenings &#x2014;i.e. if the computations&#x2014; can be adequately reflected.</p>				<p>The above shortcomings led to the design of so-called &quot;(higher level) programming languages&quot;. A programming language can be regarded as the machine code for a fictitous, idealized machine. Whereas the old machine codes were tailored to the needs of the hardware &#x2014;i.e. the equipment electronic engineers could make&#x2014; programming languages are more tailored to the intellectual needs and conceptual difficulties of the programmer who has to design the computations.</p>				<p>The problem now is that on the one hand we have the hardware machine <i>A</i>, that can be built but for which we don't like to program because it is too cumbersome, and on the other hand we have &quot;dreamed up&quot; the fictitious machine <i>B</i>, for which we would love to program but which the engineers cannot build. How do we bridge that gap?</p>				<p>The gap is bridged by &quot;software&quot;: given machine <i>A</i>, we can make, once and for all, a program (in the machine code for machine <i>A</i>) which prescribes to machine <i>A</i> the pattern of behaviour it should follow if it is to simulate machine <i>B</i>. Such a program is called &quot;software for machine <i>A</i>&quot;. Given hardware machine <i>A</i>, loaded with software, we have a mechanism &#x2014;partly &quot;hard&quot;, partly &quot;soft&quot;&#x2014; that is able to execute programs written for the fictitious machine <i>B</i>.</p>				<p>Usually this combination of hard- and software processes such programs in two stages. In the first stage (the &quot;translation stage&quot;) the program written in programming language <i>B</i> is subjected to a translation process. In this process a storage layout is decided, the necessary bookkeeping is carried out and an equivalent program &#x2014;but now expressed in machine code <i>A</i>&#x2014; is produced. In the second stage (the &quot;execution stage&quot;) the output of the first one is interpreted by machine <i>A</i> as a program and the intended computation is evoked.</p>				<p>The standard software that goes with the machine shields the user from the idiosyncrasies of the specific machine; apart from that it invokes &#x2014;behind the user's back, so to say&#x2014; the standard ways of dealing with the tougher properties of the hardware, such as the possible paralellism (i.e. concurrence in time) of the computation proper and information transfers from and to peripheral devices and multilevel stores. Up till now we have described the hardware as if all storage cells were equally well accessible for the arithmetic unit. In practice this is seldom the case, two storage levels being quite common: primary store (usually ferrite cores) and secondary store (usually magnetic drums). The cells in primary store are the only ones that are directly and immediately accessible for the arithmentic unit; the information in secondary store (which in capacity is an order of magnitude larger than primary store) is not directly accessible for the arithmetic unit, but the possibility of bulk transfers from primary store and secondary store is availabe instead. In such machines, the software may move the information around between the two stores, all the time keeping track of where everything is to be found at any moment and trying to keep in primary store all &quot;currently relevant&quot; information. (This is called &quot;the implementation of a virtual store&quot;.)</p>				<p>We have mentioned the concept of the virtual store because it is related to an efficiency aspect over which the programmer has some control and in regard to which the programmer therefore has some responsibility. This is called &quot;vagrancy&quot;. A program has a small degree of vagrancy whenever for larger periods of time access are confined to a small, dense subset of the total amount of information; in that case the hope is justified that during that period of time this dense subset will be kept in primary store and that therefore the computation can go on at full speed. In computations with high vagrancy, the probability of information needed in secondary store is much larger and the transport facilities between the storage levels then tend to become the bottle-neck. Therefore, if possible, high vagrancy should be avoided.<br>				</p>				<p class="noindent"><a href="#contents">Back to top</a></p>				<p class="noindent">Next chapter:  4. <a title="Chapter 4 of EWD 316" href="EWD316.4.html">Variables and relations between their values</a></p>				<p></p>			</div>			<hr />			<div id="footer">transcribed by Bert Put<br />revised <csobj format="MedDate" h="15" region="15" t="DateTime" w="95">Sat, 2 Aug 2008</csobj></div>		</div>  </body></html></x-html></div>
  </body>
  </html>
