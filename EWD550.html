<!DOCTYPE html>
<html>
<head>
  <title>A more formal treatment of a less simple example</title>
  <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
  <link href="assets/transcriptions.css" rel="stylesheet">
  <meta name="generator" content="convertArticle.pl">
</head>
<body>
<div class="metabar">
  <a href="index.html">HOME</a>
</div>
<h1>A more formal treatment of a less simple example</h1>
<div class='body'>						<p>For obvious reasons, most programming experiments that have been carried out in the application of formal techniques, dealt with simple, algebraic examples. For equally obvious reasons, the examples shown in tutorial texts on this subject are mostly of the same nature. (There has been a time when all of Computing Science seemed to boil down to massaging Euclid's Algorithm for the greatest common divisor!) This paper is primarily directed at remedying this situation.</p>						<div align="center">							<p class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>								*</p>						</div>						<p><a name="goal"></a>Our ultimate goal is to develop a program that will transform expressions from infix notation to postfix notation. The subject matter to be maniuplated by our program are therefore not integers, but strings of characters that may, or may not belong to certain syntactic categories. For variables of type &quot;character string&quot; we have to have at our disposal the analogon of high-school algebra (such as<tt> <nobr>(a &gt; b <u>and</u> c &gt; d) &#x21D2; a + c &gt; b + d</nobr></tt>, etc.) that sufficed for the well-known numerical examples. Before embarking on our problem proper, we shall first introduce the necessary formal apparatus and the notation needed for its description.</p>						<p>We assume our syntax given in BNF. Let <tt>&lt;pqr&gt;</tt> denote a syntactical category. We shall then express the fact that a string named <tt>K</tt> belongs to the syntactical category <tt>&lt;pqr&gt;</tt> by</p>						<blockquote>							<p><tt>pqr(K)</tt> &nbsp;&nbsp;&nbsp;.</p>						</blockquote>						<p class="noindent">For strings (named <tt>K</tt>, <tt>L</tt>, ...) and characters (named <tt>y</tt>,<tt> z</tt>, ...) we shall denote concatenation by juxtaposition, e.g. <tt>KL</tt>, <tt>Ky</tt>, <tt>Ky</tt>; etc. If <tt>L</tt> may be any string and y may be any character, any non-empty string may be denoted by <tt>yL</tt> or <tt>Ly</tt>.</p>						<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;With any syntactic category <tt>&lt;pqr&gt;</tt> we may associate the syntactic category <tt>&lt;bopqr&gt;</tt> &#x2014;&quot;begin of a <tt>&lt;pqr&gt;</tt>&quot;&#x2014; consisting of all the strings that either are a <tt>&lt;pqr&gt;</tt> or can be extended at the right-hand side so as to become a <tt>&lt;pqr&gt;</tt> or both. According to that definition the statement that the syntactic category <tt>&lt;pqr&gt;</tt> is not empty &#x2014;i.e. contains, as most useful syntactic categories, at least one string&#x2014; is equivalent with the predicate:</p>						<blockquote>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td><tt>bopqr(</tt><i>empty string</i><tt>)</tt>.</td>									<td></td>								</tr>							</table>						</blockquote>						<p>The formal definition of the predicate <tt>&lt;bopqr&gt;</tt> in terms of <tt>&lt;pqr&gt;</tt> &#x2014;with <tt>K</tt> and <tt>L</tt> denoting arbitrary strings&#x2014; is</p>						<blockquote>															<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>bopqr(K)&nbsp;&#x21D4; (<u>E</u> L : pqr(KL))</tt></td>										<td>											<div align="right">												(1)</div>										</td>									</tr>								</table>									</blockquote>						<p class="noindent">Separating the case that <tt>L</tt> is empty and the case that <tt>L</tt> is not empty, we can rewrite (1) as</p>						<blockquote>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td><tt>bopqr(K)&nbsp;&#x21D4; (pqr(K) <u>or</u> (<u>E</u> yL : pqr(KyL)))</tt></td>									<td></td>								</tr>							</table>						</blockquote>						<p class="noindent">which, thanks to (1), can be reduced to</p>						<blockquote>							<table width="100%" border="0" cellspacing="0" cellpadding="0">								<tr>									<td width="510"><tt>bopqr(K)&nbsp;&#x21D4; (pqr(K) <u>or</u> (<u>E</u> y : bopqr(Ky)))</tt></td>									<td>										<div align="right">											(2)</div>									</td>								</tr>							</table>						</blockquote>						<p class="noindent">from which we immediately derive</p>						<blockquote>							<table width="100%" border="0" cellspacing="0" cellpadding="0">								<tr>									<td width="510"><tt>(bopqr(K) <u>and</u> (<u>A</u> y: <u>non</u> bopqr(Ky))) &#x21D2; pqr(K)</tt></td>									<td>										<div align="right">											(3)</div>									</td>								</tr>							</table>						</blockquote>						<p class="noindent">From (1) we derive further</p>						<blockquote>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td valign="top" width="20%"><tt>bopar(Ky)</tt></td>									<td valign="top" width="5%">&#x21D4;<br>										=<br>										&#x21D2;</td>									<td valign="top"><tt>(<u>E</u> L : pqr(KyL))<br>											(<u>E</u> yL : pqr(KyL))<br>											bopqr(K)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.</tt></td>								</tr>							</table>						</blockquote>						<p class="noindent">From this result</p>						<blockquote>							<table width="100%" border="0" cellspacing="0" cellpadding="0">								<tr>									<td width="510"><tt>bopqr(Ky) &nbsp;&#x21D2;&nbsp; bopqr(K)</tt></td>									<td>										<div align="right">											(4)</div>									</td>								</tr>							</table>						</blockquote>						<p class="noindent">follows that<tt> &lt;bopqr&gt; = &lt;bobopqr&gt;</tt>.</p>						<p>Because<tt> pqr(K) &#x21D2; (<u>E</u> L : pqr(KL))</tt> &nbsp;&nbsp;&nbsp;&#x2014;<tt>L = </tt>the emptystring does the job&#x2014;&nbsp; a further consequence of (1) is</p>						<blockquote>							<table width="100%" border="0" cellspacing="0" cellpadding="0">								<tr>									<td width="100%"><tt>pqr(K) &nbsp;&#x21D2;&nbsp; bopqr(K)</tt></td>									<td>										<div align="right">											(5)</div>									</td>								</tr>							</table>						</blockquote>						<p>From our informal description of what we intended the notion &quot;begin of&quot; to mean, the above is all intuitively obvious, and by now the reader may wonder what all the fuss is about. The point is that we need such formulas as soon as we wish to give a more rigorous treatment of a parser.</p>						<div align="center">							<p class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>								*</p>						</div>						<p>We intend to develop a mechanism called &quot;<tt>sentsearch</tt>&quot; that is intended to recognize strings from the syntatical category<tt> &lt;sent&gt;</tt>. More precisely, we assume that the input string can be scanned in the order from left to right and reserve the identitier<tt> x </tt>for the next visible character of the input string. If the input string starts with &quot;<tt>a + b ....</tt>&quot; then we have initially<tt> x = </tt>&quot;<tt>a</tt>&quot;; after the execution of &quot;<tt>move</tt>&quot; the relation<tt> x = </tt>&quot;<tt>+</tt>&quot;<tt> </tt>will hold. Besides assigning a new value to <tt>x</tt>, the primitive &quot;<tt>move</tt>&quot; can be viewed as also appending the old value of <tt>x</tt> to the right to &quot;the strings of characters moved over&quot; or &quot;the string of characters read&quot; or &quot;the string of characters that are no longer visible.&quot;</p>						<p>Let S be the string of characters &quot;moved over&quot; by activation of <tt>sentsearch</tt>.</p>						<p class="noindent"><u>Note 1.</u> When developing the body of <tt>sentsearch</tt> we may assume that a local so-called &quot;ghost variable&quot; <tt>S</tt> is intialized at the beginning as the empty string, that each call on &quot;<tt>move</tt>&quot; is implicitly preceded by &quot;<tt>S := Sx</tt>&quot;, and that upon termination <tt>S</tt> is handed back as a &quot;ghost function value&quot; to the calling environment. (End of Note 1.)</p>						<p>In the case that the input sequence does <u>not</u> start with a <tt>&lt;sent&gt;</tt>, we want <tt>S</tt> to be the sequence that is insufficient to establish this fact, while<tt> Sx</tt> is long enough to make this conclusion. That is, upon termination</p>						<blockquote>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td><tt>bosent(S) <u>and</u> <u>non</u> bosent(Sx)</tt></td>								</tr>							</table>						</blockquote>						<p class="noindent">will hold. The first term expresses that not too much has been moved over, the second term expresses that enough has been moved over. In the case that the input string does start with a <tt>&lt;sent&gt;</tt>, we wish <tt>S</tt> to be equal to that <tt>&lt;sent&gt;</tt> and assume our syntax for <tt>&lt;sent&gt;</tt> &#x2014;about which nothing has been given yet&#x2014; to satisfy</p>						<blockquote>							<table width="100%" border="0" cellspacing="0" cellpadding="0">								<tr>									<td width="510"><tt>sent(L) &nbsp;&#x21D2;&nbsp; <u>non</u> (<u>E</u> y ; bosent(Ly))</tt></td>									<td>										<div align="right">											(6)</div>									</td>								</tr>							</table>						</blockquote>						<p>Whether or not a <tt>&lt;sent&gt;</tt> has been found is to be recorded in the global boolean <tt>c</tt> &#x2014;short for &quot;correct&quot;&#x2014; and our complete specification of <tt>sentsearch</tt> is that it has to establish <tt>Rs(S, x, c)</tt>, where <tt>Rs(S, x, c)</tt> is given by</p>						<blockquote>							<table width="100%" border="0" cellspacing="0" cellpadding="0">								<tr>									<td width="510"><tt>bosent(S) <u>and</u> <u>non</u> bosent(Sx) <u>and</u>&nbsp; c = sent(S)</tt></td>									<td width="20">										<div align="right">											(7)</div>									</td>								</tr>							</table>						</blockquote>						<p class="noindent"><u>Note 2.</u> The consequence of assumption (6) is that when the input string starts with a <tt>&lt;sent&gt;</tt> and the analysis has progressed to <tt>S</tt> equal to that <tt>&lt;sent&gt;</tt>, the term<tt>&nbsp; <nobr><u>non</u> bosent(Sx)</nobr> </tt>&nbsp;is true for all possible values of <tt>x</tt>, i.e. <tt>sentsearch</tt> can then terminate wihtout inspecting the next visible character. The end of a <tt>&lt;sent&gt;</tt> is assumed to be detectable without looking beyond it. (End of Note 2.)</p>						<p>We now give the syntax for <tt>&lt;sent&gt;</tt>:</p>						<blockquote>							<table width="100%" border="0" cellspacing="0" cellpadding="0">								<tr>									<td width="510"><tt>&lt;sent&gt;&nbsp; ::=&nbsp; &lt;exp&gt; ; </tt></td>									<td>										<div align="right">											(8)</div>									</td>								</tr>							</table>						</blockquote>						<p class="noindent">From this we have to derive the syntax for the syntatical category <tt>&lt;bosent&gt;</tt> :</p>						<blockquote>							<table width="100%" border="0" cellspacing="0" cellpadding="0">								<tr>									<td width="510"><tt>&lt;bosent&gt; &nbsp;::=&nbsp; &lt;sent&gt; | &lt;boexp&gt;</tt></td>									<td>										<div align="right">											(9)</div>									</td>								</tr>							</table>						</blockquote>						<p class="noindent">Each &nbsp;<tt>&lt;bosent&gt;</tt>&nbsp; can be derived by taking a &nbsp;<tt>&lt;sent&gt;</tt>&nbsp; and removing at the right-hand side zero or more characters from it. Removal of zero characters gives the first alternative, removal of one or more characters from&nbsp; &quot;<tt>&lt;exp&gt; ;</tt>&quot;&nbsp; boils down &#x2014;because the semicolon is a single character&#x2014; to the removal of zero or more characters from &quot;<tt>&lt;exp&gt; ;</tt>&quot; but that is by definition the syntactic category called <tt>&nbsp;&lt;boexp&gt;</tt>&nbsp;. Hence (9). The two alternatives are mutually exclusive, for we have for any string <tt>L</tt>:</p>						<blockquote>							<table width="100%" border="0" cellspacing="0" cellpadding="0">								<tr>									<td width="510"><tt>boexp(L) &#x21D2;&nbsp;<u>non</u> sent(L)</tt></td>									<td width="26">										<div align="right">											(10)</div>									</td>								</tr>							</table>						</blockquote>						<p class="noindent">This can be proved by deriving a contradiction from &nbsp;<nobr><tt>boexp(L) <u>and</u> sent(L)</tt>&nbsp;.</nobr> </p>						<p class="noindent">From &nbsp;<tt>boexp(L)</tt>&nbsp; follows &#x2014;according to (2)&#x2014;</p>						<blockquote>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td><tt>exp(L) <u>or</u> (<u>E</u> y : boexp(Ly))</tt></td>								</tr>							</table>						</blockquote>						<p class="noindent">We deal with both terms separately:</p>						<blockquote>							<p class="noindent">e<tt>xp(L) &#x21D2; </tt>(on account of (8))<br>								<tt>sent(L;) &#x21D2; </tt>(on account of (5))<br>								<tt>bosent(L;) &#x21D2; (<u>E</u> y : bosent(Ly))&nbsp;&nbsp;&nbsp;&nbsp;;</tt></p>						</blockquote>						<p class="noindent">the second term gives</p>						<blockquote>							<p class="noindent"><tt>(<u>E</u> y : boexp(Ly)) &#x21D2; </tt>(on account of (9))<br>								<tt>(<u>E</u> y : bosent(Ly))</tt> &nbsp;&nbsp;&nbsp;.</p>						</blockquote>						<p class="noindent">As both terms of the disjunction imply the same, we conclude that also</p>						<blockquote>							<p class="noindent"><tt>boexp(L) &#x21D2; (<u>E</u> y : bosent(Ly))</tt> .</p>						</blockquote>						<p class="noindent">According to (6), however,</p>						<blockquote>							<p class="noindent"><tt>sent(L) &#x21D2; <u>non</u> (<u>E</u> y : bosent(Ly))</tt> .</p>						</blockquote>						<p class="noindent">The desired contradiction has been established and (10) has been proved.</p>						<p>Syntax rule (8) strongly suggests that the body of <tt>sentsearch</tt> should start with a call of <tt>expsearch</tt>. In order to design <tt>sentsearch</tt> in terms of <tt>expsearch</tt> we only need to know the net effect of <tt>expsearch</tt> and we propose in analogy to (7) that &#x2014;when <tt>E</tt> is the string of characters moved over by <tt>expsearch</tt>&#x2014; the primitive <tt>expsearch</tt> will establish <tt>Re(E, x, c)</tt>, where <tt>Re(E, x, c)</tt> is given by</p>						<blockquote>							<table width="100%" border="0" cellspacing="0" cellpadding="0">								<tr>									<td width="510"><tt>boexp(E) <u>and</u> <u>non</u> boexp(Ex) <u>and</u> c = exp(E)</tt></td>									<td valign="top" width="26">										<div align="right">											(11)</div>									</td>								</tr>							</table>						</blockquote>						<div align="left">							<p>Designing <tt>sentsearch</tt> in terms of <tt>expsearch</tt> means that we would like to have theorems, such that from the truth of a relation of the form <tt>Re</tt> the truth of the relations of the form <tt>Rs</tt> can be concluded. There are three such theorems.</p>							<table width="100%" border="0">								<tr height="24">									<td colspan="4" valign="top" height="24"><u>Theorem 1.</u> <tt>(Re(<var>L, x, c</var>) <u>and</u> <u>non</u> <var>c</var>) &#x21D2; Rs(<var>L, x, c</var>)</tt></td>								</tr>								<tr height="24">									<td valign="top" height="24"><u>Proof.</u></td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24">Assumed:</td>									<td valign="top" height="24">&nbsp;</td>								</tr>								<tr height="24">									<td align="right" valign="top" height="24">0.</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24"><tt>Re(L, x, c) <u>and</u> <u>non</u> c</tt></td>									<td valign="top" height="24">&nbsp;</td>								</tr>								<tr height="24">									<td align="right" valign="top" height="24">&nbsp;</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24">Derived:</td>									<td valign="top" height="24">&nbsp;</td>								</tr>								<tr height="24">									<td align="right" valign="top" height="24">1.</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24"><tt>boexp(L)</tt></td>									<td valign="top" height="24">with (11) from 0</td>								</tr>								<tr height="24">									<td align="right" valign="top" height="24">2.</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24"><tt>bosent(L)</tt></td>									<td valign="top" height="24">with (9) from 1</td>								</tr>								<tr height="24">									<td align="right" valign="top" height="24">3.</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24"><tt>c = exp(L)</tt></td>									<td valign="top" height="24">with (11) from 0</td>								</tr>								<tr height="24">									<td align="right" valign="top" height="24">4.</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24"><tt><u>non</u> c</tt></td>									<td valign="top" height="24">from 0</td>								</tr>								<tr height="24">									<td align="right" valign="top" height="24">5.</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24"><tt><u>non</u> exp(L)</tt></td>									<td valign="top" height="24">from 3 and 4</td>								</tr>								<tr height="24">									<td align="right" valign="top" height="24">6.</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24"><tt><u>non</u> sent(Lx)</tt></td>									<td valign="top" height="24">with (8) from 5</td>								</tr>								<tr height="24">									<td align="right" valign="top" height="24">7.</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24"><tt><u>non</u> boexp(Lx)</tt></td>									<td valign="top" height="24">with (11) from 0</td>								</tr>								<tr height="24">									<td align="right" valign="top" height="24">8.</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24"><tt><u>non</u> bosent(Lx)</tt></td>									<td valign="top" height="24">with (9) from 6 and 7</td>								</tr>								<tr height="24">									<td align="right" valign="top" height="24">9.</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24"><tt><u>non</u> sent(L)</tt></td>									<td valign="top" height="24">with (10) from 1</td>								</tr>								<tr height="24">									<td align="right" valign="top" height="24">10.</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24"><tt>c = sent(L)</tt></td>									<td valign="top" height="24">from 4 and 9</td>								</tr>								<tr height="24">									<td align="right" valign="top" height="24">11.</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24"><tt>Rs(L, x, c)</tt></td>									<td valign="top" height="24">with (7) from 2, 8 and 10</td>								</tr>								<tr height="24">									<td align="right" valign="top" height="24"></td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="184" height="24"></td>									<td valign="top" height="24">(End of Proof of Theorem 1.)</td>								</tr>							</table>							<p></p>							<table width="100%" border="0">								<tr height="24">									<td colspan="4" valign="top" height="24"><u>Theorem 2.</u>&nbsp; <tt>(Re(L, x, c) <u>and</u> c <u>and</u> <u>non</u> semi(x))&nbsp;&#x21D2;&nbsp;Rs(L, x, false)</tt></td>								</tr>								<tr height="24">									<td valign="top" height="24"><u>Proof.</u></td>									<td valign="top" width="20" height="24"></td>									<td valign="top" height="24">Assumed:</td>									<td valign="top" height="24">&nbsp;</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											0.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" height="24"><tt>Re(L, x, c) <u>and</u> c <u>and</u> <u>non</u> semi(x)</tt></td>									<td valign="top" height="24">&nbsp;</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											&nbsp;</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" height="24">Derived:</td>									<td valign="top" height="24">&nbsp;</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											1.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" height="24"><tt>boexp(L)</tt></td>									<td valign="top" height="24">with (11) from 0</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											2.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" height="24"><tt>bosent(L)</tt></td>									<td valign="top" height="24">with (9) from 1</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											3.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" height="24"><tt><u>non</u> semi(x)</tt></td>									<td valign="top" height="24">from 0</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											4.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" height="24"><tt><u>non</u> sent(Lx)</tt></td>									<td valign="top" height="24">with 8 from 3</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											5.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" height="24"><tt><u>non</u> boexp(Lx)</tt></td>									<td valign="top" height="24">with (11) from 0</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											6.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" height="24"><tt><u>non</u> bosent(Lx)</tt></td>									<td valign="top" height="24">with (9) from 4 and 5</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											7.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" height="24"><tt>false = sent(L)</tt></td>									<td valign="top" height="24">with (10) from 1</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											8.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" height="24"><tt>Rs(L, x, false)</tt></td>									<td valign="top" height="24">with (7) from 2, 6 and 7</td>								</tr>								<tr height="24">									<td valign="top" height="24"></td>									<td valign="top" width="20" height="24"></td>									<td valign="top" height="24"></td>									<td valign="top" height="24">(End of Proof of Theorem 2.)</td>								</tr>							</table>							<p></p>							<table width="100%" border="0">								<tr height="24">									<td colspan="4" valign="top" height="24"><u>Theorem 3.</u> &nbsp;<tt>(Re(L, x, c) <u>and</u> c <u>and</u> semi(x))&nbsp;&#x21D2; Rs(Lx, y, c)</tt></td>								</tr>								<tr height="24">									<td valign="top" height="24"><u>Proof.</u></td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="242" height="24">Assumed:</td>									<td valign="top" height="24">&nbsp;</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											0.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="242" height="24"><tt>Re(L, x, c) <u>and</u> c <u>and</u> semi(x)</tt></td>									<td valign="top" height="24">&nbsp;</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											&nbsp;</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="242" height="24">Derived:</td>									<td valign="top" height="24">&nbsp;</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											1.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="242" height="24"><tt>c = exp(L)</tt></td>									<td valign="top" height="24">with (11) from 0</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											2.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="242" height="24"><tt>c</tt></td>									<td valign="top" height="24">from 0</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											3.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="242" height="24"><tt>exp(L)</tt></td>									<td valign="top" height="24">from 1 and 2</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											4.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="242" height="24"><tt>semi(x)</tt></td>									<td valign="top" height="24">from 0</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											5.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="242" height="24"><tt>sent(Lx)</tt></td>									<td valign="top" height="24">with (8) from 3 and 4</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											6.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="242" height="24"><tt>c = sent(Lx)</tt></td>									<td valign="top" height="24">from 2 and 5</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											7.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="242" height="24"><tt>bosent(Lx)</tt></td>									<td valign="top" height="24">with (5) from 5</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											8.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="242" height="24"><tt><u>non</u> bosent(Lxy)</tt></td>									<td valign="top" height="24">with (6) from 5</td>								</tr>								<tr height="24">									<td valign="top" height="24">										<div align="right">											9.</div>									</td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="242" height="24"><tt>Rs(Lx, y, c)</tt></td>									<td valign="top" height="24">with (7) from 7, 8 and 6.</td>								</tr>								<tr height="24">									<td valign="top" height="24"></td>									<td valign="top" width="20" height="24"></td>									<td valign="top" width="242" height="24"></td>									<td valign="top" height="24">(End of Proof of Theorem 3.)</td>								</tr>							</table>							<p>And now a possible body of <tt>sentsearch</tt> is evident, when we realize that its call on <tt>expsearch</tt> implies for the ghost variable <tt>S</tt> the assignment <nobr>&quot;<tt>S := SE</tt>&quot;</nobr></p>							<p class="noindent"><tt><u>proc</u> sentsearch: { S = empty string }<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expsearch {Re(S, x, c)};<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> <u>non</u> c &#x2192; skip<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2337; c <u>and</u> <u>non</u> semi(x)&nbsp; &#x2192;&nbsp; c := false<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2337; c <u>and</u> semi(x) &nbsp;&#x2192;&nbsp; move<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>fi</u> {Rs(S, x, c)}<br>									<u>corp</u></tt></p>							<p class="noindent"><u>Note 3.</u> Instead of Theorems 1 and 2 we could have discovered</p>							<p class="noindent">Theorem 1'.&nbsp;<tt>&nbsp;(Re(L, x, c) <u>and</u> <u>non</u> c)&nbsp; &#x21D2; &nbsp;Rs(L, x, false)</tt></p>							<p class="noindent">Theorem 2'.&nbsp;&nbsp;<tt>(Re(L, x, c) <u>and</u> <u>non</u> semi(x))&nbsp; &#x21D2;&nbsp; Rs(L, x, false)</tt>.</p>							<p class="noindent">This would have directed us towards the design of the body</p>							<p class="noindent"><tt><u>proc</u> sentsearch: expsearch;<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> <u>non</u> c <u>or</u> <u>non</u> semi(x)&nbsp; &#x2192;&nbsp; c := false<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2337; c <u>and</u> semi(x)&nbsp; &#x2192; &nbsp;move<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>fi</u><br>									<u>corp</u></tt></p>							<p class="noindent">which, thanks to de Morgan's Theorem, has no aborting alternative construct.<br>								{End of note 3.)</p>							<p>We now consider for <tt>&lt;exp&gt;</tt> the following syntax</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>&lt;exp&gt; ::= &lt;adder&gt; &lt;term&gt;</tt></td>										<td width="26">											<div align="right">												(12)</div>										</td>									</tr>								</table>								<br>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>&lt;adder&gt; ::= { &lt;term&gt; &lt;adop&gt; }</tt></td>										<td width="26">											<div align="right">												(13)</div>										</td>									</tr>								</table>								<br>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>&lt;adop&gt; ::= + | - </tt></td>										<td width="26">											<div align="right">												(14)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">where the braces indicate a succession of zero or more instances of the enclosed. Because each instance of the syntactic category <tt>&lt;adop&gt;</tt> is a single character, we derive</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>&lt;boexp&gt; ::= &lt;adder&gt; &lt;boterm&gt;</tt></td>										<td width="26">											<div align="right">												(15)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">from which follows</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>(adder(L) <u>and</u> boterm(K)) &#x21D2; boexp(LK)</tt></td>										<td width="26">											<div align="right">												(16)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">But this gives us no way of proving that a string is not of the syntactic category <tt>&lt;boexp&gt;</tt>. In particular, the conclusion</p>							<blockquote>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td><tt>(adder(L) <u>and</u> <u>non</u> boterm(K))&nbsp; &#x21D2; &nbsp;<u>non</u> boexp(LK)</tt></td>										<td>											<div align="right">												&nbsp;is not justified.</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">We must make &#x2014;in analogy to (6)&#x2014; an assumption about <tt>&lt;term&gt;</tt> and <tt>&lt;adop&gt;</tt>, and we assume</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>(term(L) <u>and</u> adop(y)) &#x21D2; <u>non</u> boterm(Ly)</tt></td>										<td width="26">											<div align="right">												(17)</div>										</td>									</tr>								</table>							</blockquote>							<p>This means, to start with, that with<tt> term(L)</tt>,<tt> term(L')</tt>,<tt> adop(y)</tt>, and<tt> adop(y')</tt>, we can conclude from<tt> <nobr>LyS = L'y'S'</nobr></tt>, that<tt> <nobr>L = L'</nobr> </tt>and<tt> <nobr>y = y'</nobr></tt>. In other words, for every <tt>&lt;boexp&gt;</tt> that starts with an instance of<tt> &lt;term&gt; &lt;adop&gt;</tt>, that instance is uniquely defined. By removing it from the front end, we are still left with a string frmo the syntactic category<tt> &lt;boexp&gt;</tt>, and therefore we are allowed to conclude</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>((adder(L) <u>and</u> <u>non</u> boexp(K)) &nbsp;&#x21D2;&nbsp; <u>non</u> boexp(LK)</tt></td>										<td width="26">											<div align="right">												(18)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">This does not solve our problems yet, because in order to use (18) in order to prove<tt> <nobr><u>non</u> boexp(LK)</nobr></tt>, we still have to prove<tt> <nobr><u>non</u> boexp(K)</nobr></tt>, be it only for a possibly shorter string <tt>K</tt>. We can do it, however, for a string related to the syntactic category <tt>&lt;term&gt;</tt>, as we can prove</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="505"><tt>(boterm(L) <u>and</u> <u>non</u> boterm(Ly) <u>and</u> boexp(Ly)) &#x21D2; (term(L) <u>and</u> adop(y))</tt></td>										<td align="right" valign="top" width="26">(19)</td>									</tr>								</table>							</blockquote>							<p class="noindent">The nonempty string <tt>Ly</tt>, satisfying <nobr><tt>boexp(Ly)</tt>,</nobr> can have one of three different forms:</p>							<p class="noindent">1)&nbsp;&nbsp;&nbsp;&nbsp;<tt>&lt;term&gt; &lt;adop&gt; &lt;nonempty boexp&gt;</tt></p>							<p class="noindent">This would imply, that <tt>L</tt> itself is of the form</p>							<blockquote>								<p class="noindent"><tt>&lt;term&gt; &lt;adop&gt; &lt;boexp&gt;</tt></p>							</blockquote>							<p class="noindent">which, on account of its first two elements and (17), is incompatible with<tt> boterm(L)</tt>.</p>							<p class="noindent">2)&nbsp;&nbsp;&nbsp;&nbsp;<tt>&lt;term&gt; &lt;adop&gt;</tt></p>							<p class="noindent">Because all instances of<tt> &lt;adop&gt; </tt>are single characters, this case implies indeed</p>							<p><tt><nobr>term(L) <u>and</u> adop(y)</nobr></tt></p>							<p class="noindent">3)&nbsp;&nbsp;&nbsp;<tt>&lt;boterm&gt;</tt></p>							<p class="noindent">This case is incompatible with<tt> <nobr><u>non</u> boterm(Ly)</nobr></tt>. Hence, formula (19) has been proved.</p>							<p>Similarly, we should ask ourselves how to prove that some string is <em>not</em> an element of the syntactic category <tt>&lt;exp&gt;</tt>. From (12) we can derive</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>((adder(L) <u>and</u> term(K))&nbsp; &#x21D2; &nbsp;exp(LK)</tt></td>										<td width="26">											<div align="right">												(20)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">but, again, the conclusion</p>							<blockquote>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td><tt>(adder(L) <u>and</u> <u>non</u> term(K)) &#x21D2; exp(LK)</tt></td>										<td> is not justified,</td>									</tr>								</table>							</blockquote>							<p class="noindent">only &#x2014;similar to (18)&#x2014;</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>(adder(L) <u>and</u> <u>non</u> exp(K))&nbsp; &#x21D2;&nbsp; <u>non</u> exp(LK)</tt></td>										<td width="26">											<div align="right">												(21)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">Analogous to (19) we have</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>(boterm(L) and exp(L))&nbsp; &#x21D2; &nbsp;term(L)</tt></td>										<td width="26">											<div align="right">												(22)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">The term<tt> <nobr>exp(L)</nobr> </tt>tells us that the string <tt>L</tt> can have one of two different forms:</p>							<p class="noindent">1)&nbsp;&nbsp;&nbsp;<tt>&lt;term&gt;</tt></p>							<p class="noindent">This case indeed implies<tt> <nobr>term(L)</nobr></tt></p>							<p class="noindent">2)&nbsp;&nbsp;&nbsp;<tt>&lt;nonempty adder&gt; &lt;term&gt;</tt></p>							<p class="noindent">On account of (17) &#x2014;and also (4)&#x2014; this case is excluded by<tt> <nobr>boterm(L)</nobr></tt>.</p>							<p class="noindent">Hence formula (22) has been proved.</p>							<p>Finally we can conclude that</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>((exp(L) <u>and</u> adop(y))&nbsp; &#x21D2;&nbsp; adder(Ly)</tt></td>										<td width="26">											<div align="right">												(23)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">The left-hand side tells us on account of (12) that <tt>Ly</tt> is of the form</p>							<blockquote>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td><tt>&lt;adder&gt; &lt;term&gt; &lt;adop&gt;</tt></td>									</tr>								</table>							</blockquote>							<p class="noindent">and therefore (13) allows us to conclude<tt> <nobr>adder(Ly)</nobr></tt>, and (23) has been proved.</p>							<p>Syntax rules (12) and (13) strongly suggest that the body of <tt>expsearch</tt> should call &#x2014;possibly repeatedly&#x2014; a new primitive <tt>termsearch</tt>. In order to design <tt>expsearch</tt> in terms of <tt>termsearch</tt> we only need to know the net effect of <tt>termsearch</tt> and we propose &#x2014;in analogy to (7) and (11)&#x2014; that, when<tt> T </tt>is defined as the string of characters moved over by <tt>termsearch</tt>, the primitive <tt>termsearch</tt> will establish<tt> <nobr>Rt(T, x, c)</nobr></tt>, where<tt> <nobr>Rt(T, x, c)</nobr> </tt>is given by</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>boterm(T) <u>and</u> <u>non</u> boterm(Tx)&nbsp;<u>and</u> c = term(T)</tt></td>										<td width="26">											<div align="right">												(24)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">Designing <tt>expsearch</tt> in terms of <tt>termsearch</tt> means that we would like to have theorems allowing us to draw conclusios from the truth of a relation of the form<tt> Rt</tt>.</p>							<table width="100%" border="0">								<tr height="24">									<td colspan="4" height="24"><strong>Theorem 4.</strong> <tt>(adder(L) <u>and</u> Rt(T, x, c) <u>and</u> c <u>and</u> adop(x))&nbsp; &#x21D2; &nbsp;adder(LTx)</tt></td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											<strong>Proof.</strong></div>									</td>									<td width="20" height="24"></td>									<td height="24">Assumed:</td>									<td height="24">&nbsp;</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											0.</div>									</td>									<td width="20" height="24"></td>									<td colspan="2" height="24"><tt>adder(L) <u>and</u> Rt(T, x, c) <u>and</u> c <u>and</u> adop(x)</tt></td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											&nbsp;</div>									</td>									<td width="20" height="24"></td>									<td height="24">Derived:</td>									<td height="24">&nbsp;</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											1.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>c = term(T)</tt></td>									<td height="24">with (24) from 0</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											2.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>c</tt></td>									<td height="24">from 0</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											3.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>term(T)</tt></td>									<td height="24">from 1 and 2</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											4.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>adder(L)</tt></td>									<td height="24">from 0</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											5.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>exp(LT)</tt></td>									<td height="24">with (20) from 3 and 4</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											6.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>adop(x)</tt></td>									<td height="24">from 0</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											7.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>adder(LTx)</tt></td>									<td height="24">with (23) from 5 and 6<br>									</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right"></div>									</td>									<td width="20" height="24"></td>									<td height="24"></td>									<td height="24">(End of Proof of Theorem 4.)</td>								</tr>							</table>							<p></p>							<table width="100%" border="0">								<tr height="24">									<td colspan="4" height="24"><strong>Theorem 5.</strong> <tt>(adder(L) <u>and</u> Rt(T, x, c) <u>and</u> <u>non</u> c)&nbsp; &#x21D2;&nbsp; Re(LT, x, c)</tt></td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											<strong>Proof.</strong></div>									</td>									<td width="20" height="24"></td>									<td height="24">Assumed:</td>									<td height="24">&nbsp;</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											0.</div>									</td>									<td width="20" height="24"></td>									<td colspan="2" height="24"><tt>adder(L) <u>and</u> Rt(T, x, c) <u>and</u> <u>non</u> c</tt></td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											&nbsp;</div>									</td>									<td width="20" height="24"></td>									<td height="24">Derived:</td>									<td height="24">&nbsp;</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											1.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>c = term(T)</tt></td>									<td height="24">with (24) from 0</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											2.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt><u>non</u> c</tt></td>									<td height="24">from 0</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											3.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt><u>non</u> term(T)</tt></td>									<td height="24">from 1 and 2</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											4.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>boterm(T)</tt></td>									<td height="24">with (24) from 0</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											5.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt><u>non</u> boterm(Tx)</tt></td>									<td height="24">with (24) from 0</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											6.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt><u>non</u> boexp(Tx)</tt></td>									<td height="24">with (19) from 3, 4, and 5</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											7.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>adder(L)</tt></td>									<td height="24">from 0</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											8.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt><u>non</u> boexp(LTx)</tt></td>									<td height="24">with (18) from 6 and 7</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											9.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>boexp(LT)</tt></td>									<td height="24">with (16) from 4 and 7</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											10.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt><u>non</u> exp(T)</tt></td>									<td height="24">with (22) from 3 and 4</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											11.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt><u>non</u> exp(LT)</tt></td>									<td height="24">with (21) from 7 and 10</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											12.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>c = exp(LT)</tt></td>									<td height="24">from 2 and 11</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right">											13.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>Re(LT, x, c)</tt></td>									<td height="24">with (11) from 8, 9, and 12<br>									</td>								</tr>								<tr height="24">									<td width="60" height="24">										<div align="right"></div>									</td>									<td width="20" height="24"></td>									<td height="24"></td>									<td height="24">(End of Proof of Theorem 5.)</td>								</tr>							</table>							<p></p>							<table width="100%" border="0" cellspacing="0">								<tr height="24">									<td colspan="4" height="24"><strong>Theorem 6.</strong> <tt>(adder(L) <u>and</u> Rt(T, x, c) <u>and</u> <u>non</u> adop(x)) &#x21D2; Re(LT, x, c)</tt></td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											<strong>Proof.</strong></div>									</td>									<td width="20" height="24"></td>									<td height="24">Assumed:</td>									<td height="24">&nbsp;</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											0.</div>									</td>									<td width="20" height="24"></td>									<td colspan="2" height="24"><tt>(adder(L) <u>and</u> Rt(T, x, c) <u>and</u> <u>non</u> adop(x))</tt></td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											&nbsp;</div>									</td>									<td width="20" height="24"></td>									<td height="24">Derived:</td>									<td height="24">&nbsp;</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											1.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>boterm(T)</tt></td>									<td height="24">with (24) from 0</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											2.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>adder(L)</tt></td>									<td height="24">from 0</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											3.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>boexp(LT)</tt></td>									<td height="24">wirh (16) from 1 and 2</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											4.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt><u>non</u> boterm(Tx)</tt></td>									<td height="24">with (24) from 0</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											5.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt><u>non</u> adop(x)</tt></td>									<td height="24">from 0</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											6.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt><u>non</u> boexp(Tx)</tt></td>									<td height="24">with (19) from 1, 4, and 5</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											7.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt><u>non</u> boexp(LTx)</tt></td>									<td height="24">with (18) from 2 and 6</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											8.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>c = term(T)</tt></td>									<td height="24">with (24) from 0</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											9.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>c &#x21D2; term(T)</tt></td>									<td height="24">from 8</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											10.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>c &#x21D2; exp(LT)</tt></td>									<td height="24">with (20) from 2 and 9</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											11.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt><u>non</u> c &#x21D2; <u>non</u> term(T)</tt></td>									<td height="24">from 8</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											12.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt><u>non</u> c &#x21D2; <u>non</u> exp(T)</tt></td>									<td height="24">with (22) from 1 and 11</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											13.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt><u>non</u> c &#x21D2; <u>non</u> exp(LT)</tt></td>									<td height="24">with (21) from 2 and 12</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											14.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>c = exp(LT)</tt></td>									<td height="24">from 10 and 13</td>								</tr>								<tr height="24">									<td height="24">										<div align="right">											15.</div>									</td>									<td width="20" height="24"></td>									<td height="24"><tt>Re(LT, x, c)</tt></td>									<td height="24">with (11) from 3, 7, and 14<br>									</td>								</tr>								<tr height="24">									<td height="24">										<div align="right"></div>									</td>									<td width="20" height="24"></td>									<td height="24"></td>									<td height="24">(End of Proof of Theorem 6.)</td>								</tr>							</table>							<p class="noindent">A corollary of Theorems 5 and 6 is</p>							<blockquote>								<div>									<table width="100%" border="0" cellspacing="2" cellpadding="0">										<tr>											<td><tt>(adder(L) <u>and</u> Rt(T, x, c)<br>													<u>and</u> <u>non</u> (c <u>and</u> adop( x)))<br>																					 Re(LT, x, c)</tt>.</td>										</tr>									</table>								</div>							</blockquote>							<p class="noindent">A possible body for <tt>expsearch</tt> is by now pretty obvious when we realize that calls on <tt>termsearch</tt> imply for its ghost variable <tt>E</tt> the assignment<tt> E:= ET </tt>(as &quot;<tt>move</tt>&quot; implies<tt> E:= Ex</tt> ). In the post-assertions for calls on termsearch the relation<tt> E=LT </tt>has been given in order to define <tt>L</tt> in terms of<tt> E</tt> and <tt>T</tt>.</p>							<p class="noindent"><tt><u>proc</u> expsearch: {adder(E) because E = empty string}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;termsearch {E=LT <u>and<br>									</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;adder(L) <u>and</u> Rt(T, x, c )};<br>																		&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>do</u> c <u>and</u> adop( x) </tt>&#x2192;<tt> {adder(Ex)}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move {adder(E)};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;termsearch {E=LT <u>and </u>adder(L)<u><br>									</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>and</u> Rt(T, x, c )}<br>																		&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>od</u> {Re( E, x, c )}<br>									<u>corp </u></tt></p>							<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We now consider for <tt>&lt;term&gt;</tt> the following syntax</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>&lt;term&gt; ::= &lt;plier&gt; &lt;prim&gt;</tt></td>										<td width="26">											<div align="right">												(25)</div>										</td>									</tr>								</table>								<br>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>&lt;plier&gt; ::= { &lt;prim&gt; &lt;mult&gt; }</tt></td>										<td width="26">											<div align="right">												(26)</div>										</td>									</tr>								</table>								<br>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>&lt;mult&gt; ::= *</tt></td>										<td width="26">											<div align="right">												(27</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">and assume about <tt>&lt;prim&gt;</tt> and<tt> &lt;mult&gt;</tt></p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510">(<tt>prim(L) <u>and</u> mult(y)) =&gt; <u>non</u> boprim(Ly)</tt></td>										<td width="26">											<div align="right">												(28)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">formulae (25), (26), (27), and (28) are similar to (12), (13), (14), and (17) respectively, and all our conclusions since then carry over. With <tt>P</tt> as the string of characters moved over by a primitve <tt>primsearch</tt> that establishes &#151;in analogy to (24)&#151; <tt>Rp(P, x, c)</tt>, where <tt>Rp(P, x, c) </tt>is given by</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>boprim(P) <u>and</u> <u>non</u> boprim(Px) <u>and</u> c= prim(P)</tt></td>										<td width="26">											<div align="right">												(29)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">we can write immediately (!)</p>							<p class="noindent"><tt><u>proc</u> termsearch: {plier(T) </tt>because<tt> T = </tt><i>empty string</i><tt>}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;primsearch {T=LP <u>and</u> plier( L)<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>and</u> Rp(P, x, c) };<br>																		&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>do</u> c <u>and</u> mult(x) </tt>&#x2192;<tt> {plier(Tx)}<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move {plier(T)};<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;primsearch {T=LP <u>and</u> plier(L)<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>and</u> Rp(P, x, c)}<br>																		&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>od</u> {Rt(T, x, c)}<br>									<u>corp</u></tt></p>							<p>It is time to &quot;close&quot; our syntax:</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>&lt;prim&gt; ::= &lt;iden&gt; | &lt;paren&gt;</tt></td>										<td width="26">											<div align="right">												(30)</div>										</td>									</tr>								</table>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>&lt;iden&gt; ::= { &lt;letter&gt; } &lt;letter&gt;</tt></td>										<td width="26">											<div align="right">												(31)</div>										</td>									</tr>								</table>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>&lt;paren&gt; ::= &lt;open&gt; &lt;exp&gt; &lt;close&gt;</tt></td>										<td width="26">											<div align="right">												(32)</div>										</td>									</tr>								</table>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>&lt;open&gt; ::= (</tt></td>										<td width="26">											<div align="right">												(33)</div>										</td>									</tr>								</table>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>&lt;close&gt; ::= )</tt></td>										<td width="26">											<div align="right">												(34)</div>										</td>									</tr>								</table>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>&lt;letter&gt; ::= a | b | c | d | e | f</tt></td>										<td width="26">											<div align="right">												(35)</div>										</td>									</tr>								</table>							</blockquote>							<p>The important conclusions from (35) are:</p>							<p class="noindent">1)&nbsp;&nbsp;&nbsp;that the syntactic category <tt>&lt;letter&gt;</tt> is nonempty</p>							<p class="noindent">2)&nbsp;&nbsp;&nbsp;that all instances of the syntactic category <tt>&lt;letter&gt;</tt> are all single characters</p>							<p class="noindent">3)&nbsp;&nbsp;&nbsp;that these characters differ from the six previously introduced characters.</p>							<p>From the nonemptiness of the syntactic category <tt>&lt;letter&gt;</tt> we draw the same conclusion for <tt>&lt;iden&gt;</tt>, hence for <tt>&lt;prim&gt;</tt>, hence for <tt>&lt;term&gt;</tt> hence for <tt>&lt;exp&gt;</tt>, and hence for <tt>&lt;sent&gt;</tt>. In particular we shall need to refer to</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>boprim(empty string)</tt></td>										<td width="26">											<div align="right">												(36)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">From (30) we derive</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>&lt;boprim&gt; ::= &lt;boiden&gt; | &lt;boparen&gt;</tt></td>										<td width="26">											<div align="right">												(37)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">From (31) and (32) respectively, we derive</p>							<blockquote>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>(boiden(y) = letter(y)) <u>and</u> <br>												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>non</u> iden(empty string)</tt></td>										<td valign="top" width="26">											<div align="right">												(38)</div>										</td>									</tr>								</table>								<table width="100%" border="0" cellspacing="0" cellpadding="0">									<tr>										<td width="510"><tt>(boparen(y) = open(y)) <u>and<br>												</u>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>non</u> paren(empty string)</tt></td>										<td valign="top" width="26">											<div align="right">												(39)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">and hence</p>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td></td>									<td></td>								</tr>							</table>							<blockquote>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td><tt>boprim(y) = (letter(y) <u>or</u> open(y))</tt></td>										<td>											<div align="right">												(40)</div>										</td>									</tr>								</table>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td><tt><u>non</u> prim(empty string)</tt></td>										<td>											<div align="right">												(41)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">From (31) we derive<br>							</p>							<blockquote>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td><tt>&lt;boiden&gt; ::= { &lt;letter&gt; }</tt></td>										<td>											<div align="right">												(42)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">and, because instances of <tt>&lt;letter&gt;</tt> are single characters<br>							</p>							<blockquote>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td><tt><u>non</u> letter(y) &#x21d2; <u>non</u> boiden(Ly )</tt></td>										<td>											<div align="right">												(43)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">								from (32) we derive</p>							<blockquote>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td><tt>&lt;boparen&gt; ::= empty string | &lt;open&gt; &lt;boexp&gt;<br>												&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; | &lt;paren&gt;</tt></td>										<td valign="top">											<div align="right">												(44)</div>										</td>									</tr>								</table>							</blockquote>							<p>The three alternatives for <tt>&lt;boparen&gt;</tt> are mutually exclusive: for the first one versus the two others, it is obvious. For the last two I can prove the final exclusion only by using the technique of the bracket count.</p>							<p class="noindent"><u>Lemma 1</u>.<tt> exp(L)</tt> implies that the number of instances of <tt>&lt;open&gt;</tt> in <tt>L</tt> quals the number of instances of <tt>&lt;close&gt;</tt> in <tt>L</tt>.</p>							<p class="noindent"><u>Lemma 2</u>. <tt>boxp(L)</tt> implies that the number of instances of <tt>&lt;open&gt;</tt> in Lequals at least the number of instances of <tt>&lt;close&gt;</tt> in <tt>L</tt>.</p>							<p class="noindent">Lemma 1 follows from the fact that in the original syntax &#151;i.e. without the &quot;begin-of&quot;-derivations&#151; the only rule using <tt>&lt;open&gt;</tt> or <tt>&lt;close&gt;</tt>, viz. (32), introduces them pairwise. Lemma 2 follows from the observation that in this only introduction, the instance of <tt>&lt;open&gt;</tt> precedes that of <tt>&lt;close&gt;</tt></p>							<p class="noindent">(Presumably official syntatic theory has more formal proofs for these two Lemmata; I am fully convinced of their correctness by the preceding four lines of argument.)</p>							<p>The last two alternatives of (44) are mutually exclusive, because from Lemma 2 we can conclude that in a string of the form <tt>&lt;open&gt;&nbsp;&lt;boexp&gt;</tt> the number of instances of <tt>&lt;open&gt;</tt> exceeds the number of instances of <tt>&lt;close&gt;</tt>, while in a string of the form <tt>&lt;paren&gt;</tt> these numbers are equal on account of Lemma 1. In other words</p>							<blockquote>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td><tt>(open(y) <u>and</u> boexp(L)) &#x21d2; <u>non</u> paren(yL)</tt></td>										<td>											<div align="right">												(45)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">or, equivalently</p>							<blockquote>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td><tt>paren(yL) &#x21d2; (open(y) <u>and</u> <u>non</u> boexp(L))</tt></td>										<td>											<div align="right">												(45')</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">Expressed in terms of <tt>paren</tt> and <tt>boparen</tt> only, also holds</p>							<blockquote>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td><tt>paren(L) &#x21d2; <u>non</u> (<u>E</u> z: boparen(Lz))</tt></td>										<td>											<div align="right">												(46)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">This formula can be derived by deriving a contradiction from the truth of the left-hand side and the falsity of the right-hand side. From <tt>paren(L)</tt> and (39) we conclude that <tt>L</tt> is nonempty, and we may write <tt>L=yK</tt> , such that, on account of (45'), we deduce</p>							<blockquote>								<p class="noindent"><tt>open(y) <u>and</u> <u>non</u> boexp(K)</tt></p>							</blockquote>							<p class="noindent">On the other hand, <tt>(<u>E</u> z: boparen(yKz))</tt> is, according to (1), equivalent to</p>							<blockquote>								<p class="noindent"><tt>(<u>E</u> z,M : paren(yKzM))</tt></p>							</blockquote>							<p class="noindent">or</p>							<blockquote>								<p class="noindent"><tt>(<u>E</u> M,z : paren(yKMz))</tt></p>							</blockquote>							<p class="noindent">Rule (32) then allows us to conclude</p>							<blockquote>								<p class="noindent"><tt>open(y) <u>and</u> (<u>E</u> M: exp(KM) <u>and</u> (<u>E</u> z: close(z))</tt>.</p>							</blockquote>							<p class="noindent">The second term is equivalent to <tt>boexp(K)</tt>, we have the contradiction we were looking for, and hence, (46) has been proved.</p>							<table width="100%" border="0">								<tr>									<td colspan="3"><strong>Theorem 7.</strong> (<var>L</var> = empty string <u>and</u> <u>non</u> (letter(<var>x</var>) <u>or</u> open(<var>x</var>))) &#x21d2; Rp(<var>L, x,</var> false)</td>								</tr>								<tr>									<td><strong>Proof.</strong></td>									<td>Assumed:</td>									<td>&nbsp;</td>								</tr>								<tr>									<td>0.</td>									<td><var>L</var> = empty string <u>and</u> <u>non</u> (letter(<var>x</var>) <u>or</u> open(<var>x</var>))</td>									<td>&nbsp;</td>								</tr>								<tr>									<td>&nbsp;</td>									<td>Derived:</td>									<td>&nbsp;</td>								</tr>								<tr>									<td>1.</td>									<td><var>L</var> = empty string</td>									<td>from 0</td>								</tr>								<tr>									<td>2.</td>									<td>boprim(<var>L</var>)</td>									<td>with (36) from 1</td>								</tr>								<tr>									<td>3.</td>									<td><u>non</u> (letter(<var>x</var>) <u>or</u> open(<var>x</var>))</td>									<td>from 0</td>								</tr>								<tr>									<td>4.</td>									<td><u>non</u> boprim(<var>x</var>)</td>									<td>with (40) from 3</td>								</tr>								<tr>									<td>5.</td>									<td><var>x</var> = <var>Lx</var></td>									<td>from 1</td>								</tr>								<tr>									<td>6.</td>									<td><u>non</u> boprim(<var>Lx</var>)</td>									<td>from 4 and 5</td>								</tr>								<tr>									<td>7.</td>									<td>false = prim(<var>L</var>)</td>									<td>with (41) from 1</td>								</tr>								<tr>									<td valign="top">8.</td>									<td valign="top">Rp(<var>L, x,</var> false)</td>									<td>with (29) from 2, 6, and 7<br>										(End of Proof of Theorem 7.)</td>								</tr>							</table>							<p></p>							<table width="100%" border="0">								<tr>									<td colspan="3"><strong>Theorem 8.</strong> (iden(<var>yL</var>) <u>and</u> letter(<var>x</var>)) &#x21d2; iden(<var>yLx</var>)</td>								</tr>								<tr>									<td><strong>Proof. </strong>Evident from (31)</td>									<td></td>									<td>&nbsp;</td>								</tr>							</table>							<p></p>							<table width="100%" border="0">								<tr>									<td colspan="3"><strong>Theorem 9.</strong> (iden(<var>yL</var>)  <u>and</u> <u>non</u> letter(<var>x</var>)) &#x21d2; Rp(<var>yL, x,</var> true)</td>								</tr>								<tr>									<td><strong>Proof.</strong></td>									<td>Assumed:</td>									<td>&nbsp;</td>								</tr>								<tr>									<td>0.</td>									<td>iden(<var>yL</var>) <u>and</u> <u>non</u> letter(<var>x</var>)</td>									<td>&nbsp;</td>								</tr>								<tr>									<td>&nbsp;</td>									<td>Derived:</td>									<td>&nbsp;</td>								</tr>								<tr>									<td>1.</td>									<td>iden(<var>yL</var>)</td>									<td>from 0</td>								</tr>								<tr>									<td>2.</td>									<td>boiden(<var>yL</var>)</td>									<td>with (5) from 1</td>								</tr>								<tr>									<td>3.</td>									<td>boprim(<var>yL</var>)</td>									<td>with (37) from 2</td>								</tr>								<tr>									<td>4.</td>									<td>boiden(<var>yL</var>)</td>									<td>with (4) from 2</td>								</tr>								<tr>									<td>5.</td>									<td>letter(<var>y</var>)</td>									<td>with (38) from 4</td>								</tr>								<tr>									<td>6.</td>									<td><u>non</u> open(<var>y</var>)</td>									<td>from 5</td>								</tr>								<tr>									<td>7.</td>									<td><u>non</u> boparen(<var>y</var>)</td>									<td>with (39) from 6</td>								</tr>								<tr>									<td>8.</td>									<td><u>non</u> boparen(<var>yLx</var>)</td>									<td>with (4) from 7</td>								</tr>								<tr>									<td>9.</td>									<td><u>non</u> letter(<var>x</var>)</td>									<td>from 0</td>								</tr>								<tr>									<td>10.</td>									<td><u>non</u> boiden(<var>yLx</var>)</td>									<td>with (43) from 9</td>								</tr>								<tr>									<td>11.</td>									<td><u>non</u> boprim(<var>yLx</var>)</td>									<td>with (37) from 8 and 10</td>								</tr>								<tr>									<td>12.</td>									<td>true = prim(<var>yL</var>)</td>									<td>with (30) from 1</td>								</tr>								<tr>									<td valign="top">13.</td>									<td valign="top">Rp(<var>yL, x, </var>true)</td>									<td valign="top">with (29) from 3, 11, and 12<br>										(End of Proof of Theorem 9.)</td>								</tr>							</table>							<p></p>							<table width="100%" border="0">								<tr>									<td colspan="3"><strong>Theorem 10.</strong> (open(<var>y</var>) <u>and</u> Re(<var>E, x, c</var>) <u>and</u> <var>c</var> <u>and</u> close(<var>x</var>)) &#x21d2; Rp(<var>yEx, z, c</var>)</td>								</tr>								<tr>									<td><strong>Proof.</strong></td>									<td>Assumed:</td>									<td>&nbsp;</td>								</tr>								<tr>									<td>0.</td>									<td>open(<var>y</var>) <u>and</u> Re(<var>E, x, c</var>) <u>and</u> <var>c</var> <u>and</u> close(<var>x</var>)</td>									<td>&nbsp;</td>								</tr>								<tr>									<td>&nbsp;</td>									<td>Derived:</td>									<td>&nbsp;</td>								</tr>								<tr>									<td>1.</td>									<td><var>c</var> = exp(<var>E</var>)</td>									<td>with (11) from 0</td>								</tr>								<tr>									<td>2.</td>									<td><var>c</var></td>									<td>from 0</td>								</tr>								<tr>									<td>3.</td>									<td>exp(<var>E</var>)</td>									<td>from 1 and 2</td>								</tr>								<tr>									<td>4.</td>									<td>open(<var>y</var>)</td>									<td>from 0</td>								</tr>								<tr>									<td>5.</td>									<td>close(<var>x</var>)</td>									<td>from 0</td>								</tr>								<tr>									<td>6.</td>									<td>paren(<var>yEx</var>)</td>									<td>with (32) from 3, 4, 5</td>								</tr>								<tr>									<td>7.</td>									<td>prim(<var>yEx</var>)</td>									<td>with 30 from 6</td>								</tr>								<tr>									<td>8.</td>									<td>boprim(<var>yEx</var>)</td>									<td>with 5 from 7</td>								</tr>								<tr>									<td>9.</td>									<td><u>non</u> boparen(<var>yExz</var>)</td>									<td>with (46) from 6</td>								</tr>								<tr>									<td>10.</td>									<td><u>non</u> letter(<var>y</var>)</td>									<td>from 4</td>								</tr>								<tr>									<td>11.</td>									<td><u>non</u> boiden(<var>y</var>)</td>									<td>with (38) from 10</td>								</tr>								<tr>									<td>12.</td>									<td><u>non</u> boiden(<var>yExz</var>)</td>									<td>with (4) from 11</td>								</tr>								<tr>									<td>13.</td>									<td><u>non</u> boprim(<var>yExz</var>)</td>									<td>with (37) from 9 and 12</td>								</tr>								<tr>									<td>14.</td>									<td><var>c</var> = prim(<var>yEx</var>)</td>									<td>from 2 and 7</td>								</tr>								<tr>									<td valign="top">15.</td>									<td valign="top">Rp(<var>yEx, z, c</var>)</td>									<td valign="top">with (29) from 8, 13, and 4<br>										(End of Proof of Theorem 10.)</td>								</tr>							</table>							<p></p>							<table width="100%" border="0">								<tr>									<td colspan="3"><strong>Theorem 11.</strong> (open(<var>y</var>) <u>and</u> Re(<var>E, x, c</var>) <u>and</u> <u>non</u> <var>c</var>) &#x21D2; Rp(<var>yE, x, c</var>)</td>								</tr>								<tr>									<td><strong>Proof.</strong></td>									<td>Assumed:</td>									<td>&nbsp;</td>								</tr>								<tr>									<td>0.</td>									<td>open(<var>y</var>) <u>and</u> Re(<var>E, x, c</var>) <u>and</u> <u>non</u> <var>c</var></td>									<td>&nbsp;</td>								</tr>								<tr>									<td>&nbsp;</td>									<td>Derived:</td>									<td>&nbsp;</td>								</tr>								<tr>									<td>1.</td>									<td>boexp(<var>E</var>)</td>									<td>with (11) from 0</td>								</tr>								<tr>									<td>2.</td>									<td>open(<var>y</var>)</td>									<td>from 0</td>								</tr>								<tr>									<td>3.</td>									<td>boparen(<var>yE</var>)</td>									<td>with (44) from 1 and 2</td>								</tr>								<tr>									<td>4.</td>									<td>boprim(<var>yE</var>)</td>									<td>with (37) from 3</td>								</tr>								<tr>									<td>5.</td>									<td><u>non</u> letter(<var>y</var>)</td>									<td>from 2</td>								</tr>								<tr>									<td>6.</td>									<td><u>non</u> boiden(<var>y</var>)</td>									<td>with (38) from 5</td>								</tr>								<tr>									<td>7.</td>									<td><u>non</u> boiden(<var>yEx</var>)</td>									<td>with (4) from 6</td>								</tr>								<tr>									<td>8.</td>									<td><u>non</u> boexp(<var>Ex</var>)</td>									<td>with (11) from 0</td>								</tr>								<tr>									<td>9.</td>									<td><var>c</var> = exp(<var>E</var>)</td>									<td>with (11) from 0</td>								</tr>								<tr>									<td>10.</td>									<td><u>non</u> <var>c</var></td>									<td>from 0</td>								</tr>								<tr>									<td>11.</td>									<td><u>non</u> exp(<var>c</var>)</td>									<td>from 9 and 10</td>								</tr>								<tr>									<td>12.</td>									<td><u>non</u> paren(<var>yEx</var>)</td>									<td>from (32) from (2 and) 11</td>								</tr>								<tr>									<td>13.</td>									<td><u>non</u> boparen(<var>yEx</var>)</td>									<td>with (44) from 8 and 12</td>								</tr>								<tr>									<td>14.</td>									<td><u>non</u> boprim(<var>yEx</var>)</td>									<td>with (37) from 7 and 13</td>								</tr>								<tr>									<td>15.</td>									<td><u>non</u> boiden(<var>yE</var>)</td>									<td>with (4) from 6</td>								</tr>								<tr>									<td>16.</td>									<td><u>non</u> iden(<var>yE</var>)</td>									<td>with (5) from 15</td>								</tr>								<tr>									<td>17.</td>									<td><u>non</u> paren(<var>yE</var>)</td>									<td>with (45) from 1 and 2</td>								</tr>								<tr>									<td>18.</td>									<td><u>non</u> prim(<var>yE</var>)</td>									<td>with (30) from 16 and 17</td>								</tr>								<tr>									<td>19.</td>									<td><var>c</var> = prim(<var>yE</var>)</td>									<td>from 10 and 18</td>								</tr>								<tr>									<td valign="top">20.</td>									<td valign="top">Rp(<var>yE, x, c</var>)</td>									<td valign="top">with (29) from 4, 14 and 19<br>										(End of Proof of Theorem 11.)</td>								</tr>							</table>							<p></p>							<table width="100%" border="0">								<tr>									<td colspan="3"><strong>Theorem 12.</strong> (open(<var>y</var>) <u>and</u> Re(<var>E, x, c</var>) <u>and</u> <u>non</u> close(<var>x</var>)) &#x21D2; Rp(<var>yE, x, </var>false)</td>								</tr>								<tr>									<td><strong>Proof.</strong></td>									<td>Assumed:</td>									<td>&nbsp;</td>								</tr>								<tr>									<td>0.</td>									<td>open(<var>y</var>) <u>and</u> Re(<var>E, x, c</var>) <u>and</u> <u>non</u> close(<var>x</var>)</td>									<td>&nbsp;</td>								</tr>								<tr>									<td>&nbsp;</td>									<td>Derived:</td>									<td>&nbsp;</td>								</tr>								<tr>									<td>1.</td>									<td>boexp(<var>E</var>)</td>									<td>with (11) from 0</td>								</tr>								<tr>									<td>2.</td>									<td>open(<var>y</var>)</td>									<td>from 0</td>								</tr>								<tr>									<td>3.</td>									<td>boparen(<var>yE</var>)</td>									<td>with (44) from 1 and 2</td>								</tr>								<tr>									<td>4.</td>									<td>boprim(<var>yE</var>)</td>									<td>with (37) from 3</td>								</tr>								<tr>									<td>5.</td>									<td><u>non</u> letter(<var>y</var>)</td>									<td>from 2</td>								</tr>								<tr>									<td>6.</td>									<td><u>non</u> boiden(<var>y</var>)</td>									<td>with (38) from 5</td>								</tr>								<tr>									<td>7.</td>									<td><u>non</u> boiden(<var>yEx</var>)</td>									<td>with (4) from 6</td>								</tr>								<tr>									<td>8.</td>									<td><u>non</u> boexp(<var>Ex</var>)</td>									<td>with 11 from 0</td>								</tr>								<tr>									<td>9.</td>									<td><u>non</u> close(<var>x</var>)</td>									<td>from 0</td>								</tr>								<tr>									<td>10.</td>									<td><u>non</u> paren(<var>yEx</var>)</td>									<td>with (32) from 9</td>								</tr>								<tr>									<td>11.</td>									<td><u>non</u> boparen(<var>yEx</var>)</td>									<td>with (44) from 8 and 10</td>								</tr>								<tr>									<td>12.</td>									<td><u>non</u> boprim(<var>yEx</var>)</td>									<td>with (37) from 7 and 11</td>								</tr>								<tr>									<td>13.</td>									<td><u>non</u> boiden(<var>yE</var>)</td>									<td>with (4) from 6</td>								</tr>								<tr>									<td>14.</td>									<td><u>non</u> iden(<var>yE</var>)</td>									<td>with (5) from 13</td>								</tr>								<tr>									<td>15.</td>									<td><u>non</u> paren(<var>yE</var>)</td>									<td>with (45) from 1 and 2</td>								</tr>								<tr>									<td>16.</td>									<td>false = prim(<var>yE</var>)</td>									<td>with (30) from 14 and 15</td>								</tr>								<tr>									<td>17.</td>									<td>Rp(<var>yE, x, </var>false)</td>									<td>with (29) from 4, 12, and 16</td>								</tr>							</table>							<p class="noindent">Note 4. In proofs 9 through 12, I refer a number of times to formula&nbsp;(4), but it is not really that one that is needed, but the obvious generalization:</p>							<p><tt>bopqr(KL) &#x21D2; bopqr(K);</tt></p>							<p class="noindent">sometimes it is used in the inverted, but equivalent, form</p>							<p><tt><u>non</u> bopqr(K) &#x21D2; <u>non</u> bopqr(KL)</tt> .</p>							<p class="noindent">Furthermore I offer my apologies for the great similarity between the proofs of Theorem 11 and Theorem 12. The total text could have been shortened by first stating a Lemma 3 that captures the intersection of the two proofs. It is just too expensive to change in this respect this document, which is not intended to be submitted for publication. (End of Note 4.)</p>							<p>With Theorems 7 through 12 we have prepared the way for the following design of a body for <tt>primsearch</tt>.</p>							<p class="noindent"><tt><u>proc</u> primsearch: {P = empty string}<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> <u>non</u> (letter(x) <u>or</u> open(x)) &#x2192; {Rp(P, x, false)}<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c:= false {Rp(P, x, c)}<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2337; letter(x) &#x2192; move {P = yL <u>and</u> iden(P)};<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>do</u> letter(x) &#x2192; {P = yL <u>and</u> iden(Px)}<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move {P = yL <u>and</u> iden(P)}<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>od</u> {Rp(P, x, true)};<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c := true {Rp(P, x, c)}<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2337; open(x) &#x2192; move {P = y <u>and</u> open(y)};<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expsearch {P = yE <u>and</u> open(y)<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <u>and</u> Re(E, x, c)};<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>if</u> c &Aring;&raquo; close(x) &#x2192; {Rp(Px, z, c)}<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;move {Rp(P, x, c)}<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2337; <u>non</u> c &#x2192; skip {Rp(P, x, c)}<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2337; <u>non</u> close(x) &#x2192; {Rp(P, x, false)}<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c:= false {Rp(P, x, c)}<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>fi</u> {Rp(P, x, c)}<br>									&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<u>fi</u> {Rp(P, x, c)}<br>									<u>								corp</u></tt></p>							<p>Now our syntax has been &quot;closed&quot; by (30) through (35), we can at last fulfill our obligation of proving what up till now have been assumptions, viz.</p>							<blockquote>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td><tt>sent(L) &#x21D2; <u>non</u> (<u>E</u> y : bosent(Ly))</tt></td>										<td>											<div align="right">												(6)</div>										</td>									</tr>								</table>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td><tt>(term(L) <u>and</u> adop(y)) &#x21D2; <u>non</u> boterm(Ly))</tt></td>										<td>											<div align="right">												(17)</div>										</td>									</tr>								</table>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td><tt>(prim(L) <u>and</u> mult(y)) &#x21D2; <u>non</u> boprim(Ly))</tt></td>										<td>											<div align="right">												(28)</div>										</td>									</tr>								</table>							</blockquote>							<p class="noindent">Relation (6) follows from the fact that <tt>bosent(Ly)</tt> implies <tt>boexp(L)</tt>, and from our syntax for <tt>&lt;exp&gt;</tt>, <tt>&lt;term&gt;</tt>, <tt>&lt;prim&gt;</tt>, and <tt>&lt;iden&gt;</tt>, this implies that <tt>L</tt> does not contain a semicolon; <tt>sent(L)</tt> implies according to (8) that <tt>L</tt> does contain a semicolon. This is the contradiction that follows from the assumption that (6) does not hold; hence (6) has been proved. In order to prove (17) &#x2014;under the assumption of (28)!&#x2014; we observe that with</p>							<blockquote>								<p class="noindent"><tt>&lt;term&gt; ::= &lt;plier&gt; &lt;prim&gt;</tt></p>								<p class="continue"><tt>&lt;boterm&gt; ::= &lt;plier&gt; &lt;boprim&gt;</tt></p>							</blockquote>							<p class="noindent">the negation of (17)</p>							<blockquote>								<p class="noindent"><tt>term(L) <u>and</u> adop(y) <u>and</u> boterm(Ly)</tt></p>							</blockquote>							<p class="noindent">would imply that <tt>&lt;prim&gt;</tt> and <tt>&lt;adop&gt;</tt> could be of the form <tt>&lt;boprim&gt;</tt>. It therefore suffices to prove that</p>							<blockquote>								<p class="noindent"><tt>(prim(L) <u>and</u> op(y)) </tt>&#x21d2;<tt> <u>non</u> boprim(Ly))</tt>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with</p>								<p class="continue"><tt>&lt;op&gt; ::= &lt;adop&gt; | &lt;mult&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</tt> .</p>							</blockquote>							<p class="noindent">This last implication can be proved by deriving a contradiction from its negation:</p>							<blockquote>								<p class="noindent"><tt>prim(L) <u>and</u> op(y) <u>and</u> boprim(Ly)</tt>;</p>							</blockquote>							<p class="noindent">it can be done using Lemma 1 and Lemma 2, and I gladly leave this detail to the reader.</p>						</div>						<div align="center">							<p class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>								*</p>						</div>						<div align="left">							<p>In veiw of the length of this report, the transformation from infix to posfix notation &#x2014;on page <a href="#goal">EWD550-0</a> announced as &quot;our ultimate goal&quot;!&#x2014; will be postponed and left for some later moment.</p>							<p class="noindent"><u>History</u>.</p>							<p>Nearly three years ago I wrote a report, <a title="EWD 375" href="https://www.cs.utexas.edu/~EWD/ewd03xx/EWD375.PDF">EWD375</a> &quot;A non algebraic example of a constructive correctness proof.&quot; in which (essentially) the same problem has been tackled as here. Last January, while I was lecturing in La Jolla, Jack Mazola urged me to show a more complicated example; I tried to reconstruct the argument of EWD375 on the spot and failed.</p>							<p>Last February, when I was home again, I reread EWD375 and it left me greatly dissatisfied. I remembered that EWD375 had been a cause for great enthusiasm when it was written, and I could not understand that enthusiasm anymore. I found EWD375 very hard to read and hardly convincing: what three years ago I had considered as &quot;a proof&quot; now struck me at best as &quot;helpful heuristics&quot;. (A strange experience to be nearly ashamed of what had been a source of pride only a few years ago!)</p>							<p>It was now clear why, last January in La Jolla, I was unable to give on the spot a formal treatment of the syntax analyzer: it was not just a failure of memory, it was also a profound change in my standards of rigor (undoubtedly also caused by the fact that over the last few years I burned a few fingers!). I decided to forget EWD375 and to start again from scratch. This document is the result of that effort.</p>							<p>It has been surprisingly exceedingly hard to write. After the first six pages had been written &#x2014;I had only dealt with <tt>sentsearch&#x2014;</tt> there has been a long pause before I gathered the strength and the courage to tackle <tt>expsearch</tt>, and for a few weeks I put the unfinished document away. To undertake the treatment of <tt>primsearch</tt> proved to be another hurdle.</p>							<p>What the final document does not show is that the <em>notation</em> eventually used for the assertions, the theorems and the proofs is the result of many experiments. Before we invented, for instance, the trick to use the predicate <tt>prq(K)</tt> to denote that the string <tt>K</tt> belongs to the syntactic category <tt>&lt;pqr&gt;</tt> all our formulae became unwieldy; so they did, as long as we indicated concatenation of strings with an explicit operator instead of &#x2014;as eventually&#x2014; just by juxtaposision. I hesitated, when I wrote &#x2014;as on the middle of page EWD550-3&#x2014; <tt>sent(L;)</tt> because I saw problems coming by the time that I had to write such predicates for strings containing unmatched parentheses; the trick of introducing <tt>&lt;open&gt;</tt> and <tt>&lt;close&gt;</tt> solved that problem. Instead of (8) I should have written</p>							<blockquote>								<p class="continue"><tt>&lt;sent&gt; ::= &lt;exp&gt; &lt;semi&gt;</tt></p>								<p class="continue"><tt>&lt;semi&gt; ::= ;</tt></p>							</blockquote>							<p>Again, at the time of the writing, also this report has been a source of great excitement. This is somewhat amazing as it does not contain a single deep thought! Is it, because we now still remember how much more beautiful it is than all the rejected efforts? I wonder how I shall feel about it in a few years time!</p>							<p class="noindent"><u>Acknowledgement</u>.</p>							<p>I am greatly endebted to W.H.J.Feijen, M.Rem, A.J.Martin and C.S.Scholten, whose encouragement and active participation have been absolutely essential. And I am grateful to Jack Mazola for providing me with the incentive.</p>							<hr>							<p class="noindent"><font size="-1">transcribed by David J. Brantley<br>																		last revised <csobj format="MedDate" h="13" region="15" t="DateTime" w="99">Mon, 25 Aug 2008</csobj></font></p>						</div>					</div>				</div>				<div align="right">					<blockquote>						<p></p>						<p></p>						<p></p>					</blockquote>				</div>				<div align="center"></div>				<p></p>				<div align="right">					<p></p>					<p></p>				</div>				<p></p>				<p></p>				<p></p>				<p></p>				<p></p>				<div align="right"></div>				<p></p>				<p></p>				<p></p>				</p>																																																																																																																				</body></html></div>
</body>
</html>
