<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html>

	<head><link href="assets/transcriptions.css" rel="stylesheet" media="screen"><link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
		<meta http-equiv="content-type" content="text/html;charset=ISO-8859-1">
		<meta name="generator" content="convertArticle.pl">
		<title>E.W.Dijkstra Archive: On Understanding Programs. (EWD 264)</title>
	</head>

	<body bgcolor="#ffffff"><div id="title"><h1>On Understanding Programs.</h1></div>
		<div align="right">
			&nbsp;&nbsp;<a href="https://www.cs.utexas.edu/~EWD/ewd02xx/EWD264.PDF" target="_blank">EWD 264</a></div>
		<div align="left">
			<p><u>On Understanding Programs.</u></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;On a number of occasions I have stated the requirement that if we ever want to be able to compose really large programs reliably, we need a discipline such that the intellectual effort <i>E</i> (measured in some loose sense) needed to understand a program does not grow more rapidly than proportional to the program length <i>L</i> (measured in an equally loose sense) and that if the best we can attain is a growth of <i>E</i> proportional to, say <i>L</i><sup>2</sup>, we had better admit defeat. As an aside I used to express my fear that many programs were written in such a fashion that the functional dependence was more like an exponential growth!</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I now offer, for the reader's consideration, an example showing how the same program can be understood in two different ways: in the one way, <i>E</i> grows proportional to <i>L</i>, in the other way it grows (even worse than) exponentially.</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I express <i>E</i> in the number of &quot;steps of reasoning&quot; needed, a number which is determined as follows.</p>
			<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				Let us consider a &quot;stretched&quot; program of the form</p>
			<blockquote>
				<blockquote>
					<table width="466" border="0" cellspacing="2" cellpadding="0">
						<tr>
							<td>&quot;<i>S</i><sub>1</sub>; <i>S</i><sub>2</sub>; ...; <i>S<sub>N</sub></i>&quot;</td>
							<td>(1)</td>
						</tr>
					</table>
				</blockquote>
			</blockquote>
			<p>i.e. the corresponding computations are a time-succession of the executions of <i>S</i><sub>1</sub> through <i>S<sub>N</sub></i> in that order. When the nett effect of the execution of each individual statement <i>S<sub>i</sub></i> is given, my measuring convention states that it takes <i>N</i> steps to understand program (1), i.e. to establish that the cumulative effect of <i>N</i> successive actions satisfies the requirements imposed upon the computations evoked by program (1).</p>
			<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				In the case of a program of the form</p>
			<blockquote>
				<blockquote>
					<table width="466" border="0" cellspacing="2" cellpadding="0">
						<tr>
							<td>&quot;<u>if</u> <i>B</i> <u>then</u> <i>S</i><sub>1</sub> <u>else</u> <i>S</i><sub>2</sub>&quot;</td>
							<td>(2)</td>
						</tr>
					</table>
				</blockquote>
			</blockquote>
			<p>where, again, the nett effect of the execution of the statements <i>S</i><sub>1</sub> and <i>S</i><sub>2</sub> has been given, my measuring convention states that it takes 2 steps to understand program (2), viz. one step for the case <i>B</i> and another for the case <u>non</u> <i>B</i>.</p>
			<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				Consider now a program of the form</p>
			<blockquote>
				<blockquote>
					<table width="466" border="0" cellspacing="2" cellpadding="0">
						<tr>
							<td>&quot;<u>if</u> <i>B</i><sub>1</sub> <u>then</u> <i>S</i><sub>11</sub> <u>else</u> <i>S</i><sub>12</sub>;<br>
								&nbsp;<u>if</u> <i>B</i><sub>2</sub> <u>then</u> <i>S</i><sub>21</sub> <u>else</u> <i>S</i><sub>22</sub>;<br>
								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>
								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>
								&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>
								&nbsp;<u>if</u> <i>B<sub>N</sub></i> <u>then</u> <i>S<sub>N </sub></i><sub>1</sub> <u>else</u> <i>S<sub>N </sub></i><sub>2</sub>&quot;</td>
							<td valign="bottom">(3)</td>
						</tr>
					</table>
				</blockquote>
			</blockquote>
			<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				According to the measuring convention it takes 2 steps per alternative statement to understand it, i.e. to establish that the nett effect of</p>
			<blockquote>
				<blockquote>
					<table width="466" border="0" cellspacing="2" cellpadding="0">
						<tr>
							<td>&quot;<u>if</u> <i>B<sub>i</sub></i> <u>then</u> <i>S<sub> i </sub></i><sub>1</sub> <u>else</u> <i>S<sub> i </sub></i><sub>2</sub>&quot;</td>
							<td></td>
						</tr>
					</table>
				</blockquote>
			</blockquote>
			<p>is equivalent to that of the execution of an abstract statement <i>S<sub>&nbsp;i&nbsp;</sub></i>. Having <i>N</i> such alternative statements it takes us 2<i>N</i> steps to reduce program (3) to one of the form of program (1); to understand the latter form of the program takes us another <i>N</i> steps, giving 3<i>N</i> steps of reasoning in toto.</p>
			<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If we had not introduced the abstract statements <i>S<sub>&nbsp;i&nbsp;</sub></i>, but had tried to understand program (3) directly in terms of executions of the statements <i>S<sub>&nbsp;i&nbsp;j </sub></i>, each such computation would be the cumulative effect of <i>N</i> such statement executions and would as such require <i>N</i> steps to understand it. Trying to understand the algorithm in terms of the <i>S<sub>&nbsp;i&nbsp;j </sub></i>, however, implies that we have to distinguish between 2<i><sup>N</sup></i> different routings through the program and this would lead to <i>N</i>*2<i><sup>N</sup></i> steps of reasoning!</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; If by now the reader protests that the second way to try to understand program (3) is utterly foolish, then I have him exactly in the position where I want him to be, for then we could not agree more fully. The point is, that any effort to improve upon the second method yields a method more similar to the first one: one will find oneself introducing the abstract statements <i>S<sub>&nbsp;i</sub></i> (or combinations of them)!</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
				The whole demonstration is an urgent plea to use our powers of abstraction as consciously as possible (and to restrict ourselves in programming to those program structures in which these powers can be exploited at greatest advantage!)  The reader who has followed me thus far may wonder whether he has been confronted with something deep or something trivial.  So did I, when I discovered this example; I have, however, decided to submit it for publication when I felt that it was probably both.</p>
			<p>
				Edsger W.Dijkstra<br>
				Technological University<br>
				EINDHOVEN<br>
				The Netherlands</p>
		</div>
		<hr>
		<font size="-1">transcribed by Tristram Brelstaff<br>
			revised <csobj format="MedDate" h="12" region="15" t="DateTime" w="97">Thu, 14 Jul 2005</csobj></font>
	</body>

</html>