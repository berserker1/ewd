  <!DOCTYPE html>
  <html>
  <head>
    <title>A political pamphlet from the Middle Ages</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <link href="assets/tweet-selection.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.12.0.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="assets/tweet-selection.js"></script>
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: A political pamphlet from the Middle Ages" />
    <meta name="twitter:title" content="A political pamphlet from the Middle Ages" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>A political pamphlet from the Middle Ages</h1>
  <div class='body'>
	<p>This note concerns a very ugly paper [1]. Its authors seem to claim that trying to prove the correctness of programs is a futile effort and, therefore, a bad idea. To quote from the opening sentence:</p>
	<blockquote>
		&quot;program verification [...] is bound to fail in its primary purpose: to dramatically increase one's confidence in the correct functioning of a particular piece of software&quot;.</blockquote>
	As rendered above, this statement is obviously wrong: we all know of cases in which our confidence in the correct functioning of a particular piece of software has been increased dramatically by a proof of its correctness.
	<p>The style of the paper is revealed by what I omitted: in the place indicated by &quot;[...]&quot; they had written &quot;as perceived by a large segment of the computer science community&quot;. They give a complete caricature of program verification &mdash;suggesting, for instance, that on the average one line of program requires 66 (sic!) lines of formal correctness proof&mdash;, accuse without substantiation that &quot;a large segment of the computer science community&quot; accepts this nonsense as a fact of life, and then try to sell the great message that the computer science community has been misguided. That is what I call the style of a political pamphlet.</p>
	<p>They argue (rightly) that communication between mathematicians is an essential ingredient of our mathematical culture; they conclude that proofs of program correctness, not being communicated among colleagues, are therefore no good. How do they know that these proofs are not communicated and subjected to the judgement of others? Simply by painting them as so long, ugly, and boring that they are, now almost by definition, not fit for communication. They just ignore that how to prove &mdash;not in the silly ways they depict, but more elegantly&mdash; &quot;the correct functioning of particular pieces of software&quot; is the subject of a lively interchange of experiences between scientists active in the field. In short: again the unsubstantiated accusation that is characteristic for political pamphlets.</p>
				<p>They argue (rightly) that long formal proofs are unconvincing, and subsequently discredit formal techniques, with an appeal to the work of Albert Meyer, by remarking that &quot;For even the most trivial mathematical theories, there are simple statements whose finite proofs are impossibly long.&quot; As if that matters! In most mathematical theories there are even simple statements that cannot be proved at all, but who cares? It is the mathematician's task to arrange his arguments in such a fashion that avoidable formal manipulations are, indeed, avoided, and to discover those theorems that do admit a concise proof. They fail to argue why these &quot;simple statements whose finite proofs are impossibly long&quot; should be of any interest, neither do they substantiate their suggestion that the theorems needed for proving program correctness mst be so uncomfortably long. (They would have a hard time if they tried, for it is exactly in the area of proving program correctness that I have found formal techniques both indispensable and, when applied with good taste, eminently suitable.) Also such omissions are characteristic for political pamphlets.</p>
				<p>They suggest an antagonism between &quot;formal&quot; and &quot;understandable&quot; which is misleading. Eventually a nice formal treatment is always the most concise way of capturing our understanding and the most effective way of conveying the argument with all its convincing power to someone else. (By suggesting this antagonism, they seem to have fallen into the same trap as the author who wrote in his preface &quot;the standard symbols for the logical connectives have been avoided for the sake of clarity&quot;, unaware as he was that it was precisely for the sake of clarity that these symbols have been invented!) Such misrepresentations are characteristic for political pamphlets.</p>
				<p>They don't distinguish between love of perfection and claim of perfection, and blame people for the first by accusing them of the latter.</p>
				<p>Besides political, the paper is pre-scientific in the sense that even the shallowest analogy is accepted as justification. Referring to Rabin's algorithm for the probable primality of a large integer, they suggest that most theorems mathematicians work on are as unprovable as the primality of very large integers is untestable, but the only support they provide is obtained by ignoring the difference between Rabin's (mathematical notion of) &quot;probable&quot; and their own (wooly notion of) &quot;believable&quot;. The first one, however, has nothing to do with human fallibility, the second one (see their &quot;filters&quot;) everything</p>
				<p>They display the same pre-scientific attitude when they argue as if a bridge and a software system were significantly similar objects: reading the text one can only conclude that this opinion has been induced by the verbal similarity between the terms &quot;Mechanical Engineering&quot; and &quot;Software Engineering&quot;.</p>
				<p>Unaware that the &quot;problems of the <i>real</i> world&quot; are those you are left with when you refuse to apply their effective solutions, they confirm the impression of anti-intellectualistic reactionaries by sentences such as &quot;<i>real</i> programs deal with <i>real</i> human activity and are thus detailed and messy&quot; (their italics and their conclusion!). They boldly postulate that &quot;...the transition between specification and program <i>must</i> be left unformalized&quot;. It is as if they remembered examples of how programs were formally derived from their specification, for several lines further down, they quote in gratitude from a private communication that &quot;the input assertions for many numerical algorithms are not even formulatable&quot;. If the essential properties of these numerical algorithms cannot be formulated, we are left wondering how their usage can ever be justified (but presumably this is explained in the private communication quoted).</p>
				<div align="center">
					*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>
					*</div>
				<p>By this time the reader may feel that by not being more specific in my complaints I am committing the same sin as I have accused the authors of. The trouble is that it is very hard to be more specific; their text is slippery &mdash;they disagree with &quot;a large segment of the computer science community&quot;, but accept the average implementor's attitude when it suits their argument&mdash;; the text is written in sometimes very poor English &mdash;&quot;It is exactly those processes which mediate (sic) proofs of theorems in mathematics that <u>require</u> (sic) that...&quot;&mdash; and their arguments are rambling. Supposing that they had something sensible to say we can only regret that they have buried it under so much insinuating verbiage. As it stands it leaves the reader wondering why they have put so much venom in their text, because they seem to have gone much farther than the usual practitioner's backlash.</p>
	<p>None of the many papers about program verification and derivation that I have written or seen uses APL as a programming vehicle. This could be an accident, it could also be a consequence of the rich expression structure of APL. (They refer to proofs as &quot;...substitutions to be checked with the aid of simple algebraic identities&quot; which, in the case of APL-expressions are perhaps not so simple...) If the latter conjecture is correct, it would explain why APL-addicts might feel unhappy about (or threatened by) modern achievements in proving the correctness of (non-APL) programs. Does it help the understanding of this paper and its venom to know of the heavy involvement with APL of its authors? We can only guess and have our private opinions.</p>
	[1] DeMillo, Richard A., Lipton, Richard J., Perlis, Alan J., &quot;Social Processes and Proofs of Theorems and Programs&quot;, <i>Conference Record of the 4th Symposium on Principles of Programming Languages</i>, Los Angeles, January 17&ndash;19, 1977<br>
	<br>
	<br>
	<table width="100%" border="0">
					<tr valign="top">
			<td>Plataanstraat 5<br>
							5671 AL NEUNEN<br>
							The Netherlands</td>
			<td width="40%">prof.dr.Edsger W.Dijkstra<br>
							Burroughs Research Fellow</td>
		</tr>
				</table>
	<br>
	<hr>
	<font size="-1">transcribed by Kevin Hely.<br>
		latest revision <csobj format="MedDate" h="16" region="15" t="DateTime" w="95">Mon, 10 Apr 2006</csobj></font>
	<p></p>
</body>

</html></div>
  <script>
$('body').tweetSelection({
  height: 300,
  width: 600,
  minimumTextSelected: 3,
  shareClass: '.tweet-selection',
  ellipsis: '...',
  quoteLeft: '\'',
  quoteRight: '\'',
  via: 'raboofje'
});
  </script>
  </body>
  </html>
