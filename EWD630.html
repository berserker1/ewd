  <!DOCTYPE html>
  <html>
  <head>
    <title>On-the-fly garbage collection: an exercise in cooperation</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <link href="assets/tweet-selection.css" rel="stylesheet">
    <script src="https://code.jquery.com/jquery-1.12.0.min.js" type="text/javascript" charset="utf-8"></script>
    <script src="assets/tweet-selection.js"></script>
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@raboofje" />
    <meta name="twitter:description" content="From the Edsger Dijkstra EWD archive: On-the-fly garbage collection: an exercise in cooperation" />
    <meta name="twitter:title" content="On-the-fly garbage collection: an exercise in cooperation" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>On-the-fly garbage collection: an exercise in cooperation</h1>
  <div class='body'>
        <hr />
<p class="noindent">NOTE: This transcription was contributed by Martin P.M. van der Burgt, who has devised a process for producing 
transcripts automatically. Although its markup is incomplete, we believe it serves a useful purpose by virtue of its searchability and its 
accessibility to text-reading software. It will be replaced by a fully marked-up version when time permits. &mdash;HR</p>
<hr />
           <p class="noindent">
<p><b>On-the-fly garbage collection: an exercise in cooperation</b>.
<center>by</center>
<center>Edsger W.Dijkstra *) </center>
<center>Leslie Lamport **) </center>
<center>A.J.Martin ***)</center>
<center>C.S.Scholten ****)</center>
<center>E.F.M.Steffens ***)</center>
<p class=noindent>
<table width=100%><tr><td valign=top width=10% align=right>
*)</td><td>Burroughs, Plataanstraat 5, 5671 AL NUENEN, The Netherlands
</td></tr>
<tr><td valign=top align=right>
**)</td><td>Massachusetts Computer Associates Inc., 26 Princess Street,
WAKEFIELD, Mass. 01880, U.S.A.
</td></tr>
<tr><td valign=top align=right>
***)</td><td>Philips Research Laboratories, EINDHOVEN, The Netherlands
</td></tr>
<tr><td valign=top align=right>
****)</td><td>Philips-Electrologica B.V., APELDOORN, The Netherlands
</td>  </tr>  </table>
<p class=noindent><b>Abstract</b>. As an example of cooperation between sequential processes with very
little mutual interference despite frequent manipulations of a large shared
data space, a technique is developed which allows nearly all of the activity
needed for garbage detection and collection to be performed by an additional
processor operating concurrently with the processor devoted to the computation
proper. Exclusion and synchronization constraints have been kept as weak as
could be achieved; the severe complexities engendered by doing so are illustrated.
<p class=noindent>Key Words and Phrases: multiprocessing, Fine-grained interleaving, cooperation
between sequential processes with minimized mutual exclusion, program 
correctness for multiprogramming tasks, garbage collection.
<p class=noindent>CR Categories: 4.32, 4.34, 4.35, 4:39, 5.24 .
<p class=noindent>(For reference purposes a glossary of names has been added at the end of the
article.)
                    
<p><b>On-the-f1y garbage collection: an exercise in cooperation</b>.
<p class=noindent>1. <b>Introduction</b>.
<p>In any large-scale computer installation today, a considerable amount of
time of the (general purpose) processor is spent on &ldquo;operating the system&rdquo;. With
the advent of multiprocessor installations the question arises to what extent
such &ldquo;housekeeping activities&rdquo; can be carried out concurrently with the 
computation(s) proper. One of the problems that have to be dealt with is that of
organizing the cooperation of the concurrent processes in such a way as to
keep exclusion and synchronization constraints extremely weak, in spite of very
frequent manipulations (by all processes involved) of a large shared data space.
The problem of garbage collection was selected as one of the most challenging
problems in this respect (and hopefully a very instructive one). Our exercise
has not only been very instructive, but at times even humiliating, as we have
fallen into nearly every logical trap that we could possibly fall into. In
our presentation we have tried to blend a condensed design history &mdash;in order
not to hide the heuristics too much&mdash; with a rather detailed justification of
our final solution. We have tried to keep exclusion and synchronization 
constraints between the processes as weak as possible, and how to deal with the
complexities engendered by doing so is the main topic of this paper.
<p>It has hardly been our purpose to contribute specifically to the art of
garbage collection, and consequently no practical significance is claimed for
our solution. For that reason we felt justified in tackling a specific form of
the garbage collection problem as it presents itself in the traditional 
implementation environment of pure LISP. We are aware of the fact that we have left out
of consideration several aspects of the garbage collection problem that are 
important from other points of view (see, for instance, [2]).
<p>In our abstract form of the problem, we consider a directed graph of
varying structure but with a fixed number of nodes, in which each node has at
most two outgoing edges. More precisely, each node may have a 1eft-hand outgoing
edge and may have a right-hand outgoing edge, but either of them or both may
be missing. In this graph a fixed set of nodes exists, called &ldquo;the roots&rdquo;.
A node is called &ldquo;reachable&rdquo; if it is reachable from at least one root via
                   
 
a directed path along the edges. The subgraph consisting of all reachable nodes
and their interconnections is called &ldquo;the data structure&rdquo;; non-reachable nodes,
i.e. nodes that do not belong to the data structure, are called &ldquo;garbage nodes&rdquo;.
The data structure can be modified by actions of the following types:
<table width=100%><tr><td valign=top width=04%>
(1)</td><td>redirecting an outgoing edge of a reachable node towards an already
reachable one
</td></tr>
<tr><td valign=top>
(2)</td><td>redirecting an outgoing edge of a reachable node towards a not yet
reachable one without outgoing edges ,
</td></tr>
<tr><td valign=top>
(3)</td><td>adding &mdash;where an outgoing edge was missing&mdash; an edge pointing from a
reachable node towards an already reachable one
</td></tr>
<tr><td valign=top>
(4)</td><td>adding &mdash;where an outgoing edge was missing&mdash; an edge pointing from a
reachable node towards a not yet reachable one without outgoing edges
</td></tr>
<tr><td valign=top>
(5)</td><td>removing an outgoing edge of a reachable node.                  
</td>  </tr>  </table>
In actions (1), (2), and (5) nodes may be disconnected from the data structure
and thus become garbage. In actions (2) and (4) a garbage node is &ldquo;recycled&rdquo;,
i.e. made reachable again.
<p>The representation of the graph is such that each node can be identified
independently of the structure of the graph, and that finding the left- or 
right-hand successor of a node can be regarded as a primitive operation, whereas 
finding its predecessor nodes would imply a search through the complete collection
of nodes. Because of this representation, finding garbage is a non-trivial
task, which is delegated to a so-called &ldquo;garbage collector&rdquo;. The garbage
collector maintains a so-called &ldquo;free list&rdquo;, i.e. a collection of nodes that
have been identified as garbage and are available to be added to the data
structure.
<p>In classical LISP implementations the computation proper (i.e. the 
modifications of the data structure as described above)proceeds until the free
list is exhausted (or nearly so). Then the computation proper comes to a grinding
halt, after which garbage is collected: starting from the roots, all reachable         
nodes are marked; upon completion of this marking cycle all unmarked nodes can
be concluded to be garbage, and are appended to the free list, after which the
computation proper is resumed.
The minor disadvantage of this arrangement is the delay of the computation
            

proper; its major disadvantage is the unpredictability of these garbage 
collecting interludes, which makes it hard to design such systems so as to 
meet realtime requirements as well. It was therefore tempting to investigate whether
a second processor &mdash;called &ldquo;the collector&rdquo;&mdash; could collect garbage concurrently
with the activity of the other processor &mdash;for the purpose of this discussion
called &ldquo;the mutator&rdquo;&mdash; which would be dedicated to the computation proper.
In order to investigate an exemplary problem, we have imposed upon our 
solution a number of constraints (compare [2]).
<p>Firstly, we wanted the synchronization and exclusion constraints between the
mutator and the collector to be as weak as possible. (The classical 
implementation presents in this respect the other extreme: a garbage collecting interlude
can in its entirety be regarded as a single critical section that excludes all 
mutator activity!) We wanted in particular to avoid highly frequent mutual
exclusion of &ldquo;elaborate&rdquo; activities, as this would defy our aim of concurrent
activity: our ultimate aim was something like no more interference than the
mutual exclusion of a single read and/or write of the same single variable. One
synchronization measure is evidently unavoidable: when needing a new node from
the free list, the mutator may have to be delayed until the collector has appended
some nodes to the free list.
<p>Secondly, we wanted to keep the overhead on the activity of the mutator
(as required for the cooperation with the collector) as small as possible.
<p>Thirdly, we did not want the mutator&rsquo;s ongoing activity to impair the
collector&rsquo;s ability to identify garbage more than we could avoid. with a major
cycle of the collector consisting of a marking phase followed by an appending
phase, it is impossible to guarantee that the appending phase will append all
garbage existing at its beginning: new garbage could have been created between
an appending phase and the preceding marking phase. We do require, however,
that such garbage, existing at the beginning of an appending phase but not 
identified as such by the collector, will be appended in the next major cycle of
the collector. Moreover, we have rejected solutions in which garbage created
during a marking phase was guaranteed <b>not</b> to be appended during the next 
appending phase.
                
<p class=noindent>2. <b>The grain of action</b>.
<p>The fact that we require concurrent operation of two or more processes
raises the problem of defining the net effect of such concurrent operation. In
order to explain the problem we introduce the terms &ldquo;local variable&rdquo; for those
variables that are accessed by one process only, and &ldquo;shared variable&rdquo; for those
that are accessed by at least two processes.
<p>As long as our concurrent processes only operate on local variables, there
is no problem: we suppose that no one will have any doubt as to the net result
of the concurrent operation of the two programs S<sub>0</sub> and S<sub>1</sub> given by
<table width=100%><tr><td valign=top width=10%>
</td><td>S<sub>0</sub>: x:= 0 and S<sub>1</sub>: y:= 3 .
</td>  </tr>  </table>
<p>This, however, changes radically as soon as we consider shared variables.
With shared &ldquo;z&rdquo; , some readers may assume that the concurrent operation of
S<sub>2</sub> and S<sub>3</sub> given by
<table width=100%><tr><td valign=top width=10%>
</td><td>S<sub>2</sub>: z:= 0 and S<sub>3</sub> : z:= 3
</td>  </tr>  </table>
will yield either z = 0 or z = 3 , but in that case we must destroy that
illusion! We need only assume z to consist of two bits z<sub>0</sub> and z<sub>1</sub>
(z = 2z<sub>1</sub> + z<sub>0</sub> ) , and S<sub>2</sub> and S<sub>3</sub> on closer scrutiny to be composed as follows:
<table><tr>
<td>&nbsp; &nbsp; &nbsp; &nbsp; S2: </td><td>z<sub>0</sub>=: 0;</td><td> and</td><td> S3:</td><td> z<sub>0</sub>:= 1;</td></tr><tr>
<td> </td><td>z<sub>1</sub>=: 0</td><td></td><td></td><td> z<sub>1</sub>=: 1</td> </tr></table>
to reach the conclusion that z = 1 and z = 2 are also possible results.
<p>In order to express our intentions unambiguously, we introduce the notion
of &ldquo;atomic operations&rdquo;, denoted in our texts by a piece of program placed between
a pair of angle brackets (we don&rsquo;t allow nested use of such pairs). We further
require all accesses to shared variables to be part of an atomic operation and
postulate that the net effect of our concurrently operating processes is as if
atomic operations are mutually exclusive, i.e. the execution periods of atomic
operations don&rsquo;t overlap. (We note in passing that it is pointless to introduce
atomic operations accessing local variables only.) As a result it is now clear
that concurrent operation of
<table width=100%><tr><td valign=top width=10%>
</td><td>S<sub>2</sub>: &lt;z:=0&gt; and S<sub>3</sub>: &lt;z:=3&gt;
</td>  </tr>  </table>


will, indeed, yield either z = 0 or z = 3 (even if, upon closer scrutiny,
the assignments to z turn out to be composed of successive operations on the
individual bits).
<p>Having introduced atomic operations, we are now in a position to define
a (partial) ordering between programs based on the notions &ldquo;coarser-grained&rdquo; and
&ldquo;finer-grained&rdquo; (&ldquo;A is coarser-grained than B&rdquo; is equivalent with &ldquo;B is 
finer-grained than A&rdquo;). We say that A is coarser-grained than B (or alternatively,
&ldquo;has a coarser grain of action&rdquo;) if B is the result of replacing an atomic
operation of A by a piece of program containing at least two atomic operation
and having all by itself the same net effect as the original operation.
<p>Since a possible sequencing of the atomic operations in a coarse-grained 
solution of a problem can always be regarded as a possible sequencing of the
atomic operations in a finer-grained solution, the proof that the finer-grained
solution is correct implies the same for the coarse-grained solution. Hence,
the advantage of coarser-grained solutions is that their correctness proofs are
easier than those for finer-grained ones; their disadvantage, however, is that
their implementation usually requires more severe mutual exclusion measures,
which tend to defeat the aim of concurrency.
<p class=noindent>3. <b>A reformulation of the problem</b>.
<p>Our first step was to restate the problem in as simple a form as we
could. We found two important simplifications.
<p>First, we followed the not unusual practice of introducing a special
root node, called &ldquo;NIL&rdquo;, whose two outgoing edges point to itself, and 
representing a formerly missing edge now by an edge with the node NIL as its
target. (In order to shorten our discussions we use the terms &ldquo;source&rdquo; and
&ldquo;target&rdquo; of an edge: if an edge points from node A to node B , then A
is said to be the source and B is said to be the target of that edge.)
For us, the introduction of the node NIL was definitely much more than just
a coding trick. It allowed us to view data structure modifications of types
(3) and (5) as special cases of type (1), and those of type (4) as special cases
of type (2), so that we were left with two types of modification only. In
the sequel it will become clear that the reduced diversity thus achieved has
                

been absolutely essential for our purposes:
<p>A second simplification was obtained by viewing the nodes of the free
list no longer as garbage,but as part of the data structure. This was achieved
by introducing one or more special root nodes,and by linking the free nodes in
such a way that NIL and all free nodes, <b>but no others</b>, are reachable from
these special root nodes. This implies that from now on the nodes on the free
list are reachable, and thus considered to be part of the data structure. A
modification of type (2) is now replaced by a sequence of modifications of type
(1): first redirecting an edge towards a node in the free list, then redirecting
edges of free list nodes so as to remove that node from the free list. (Note
that the operations must be performed in such an order that the node in question
remains permanently reachable.) Making the free list part of the data structure
is again no mere coding trick. It allowed us to eliminate modifications of
type (2): now only <b>one</b> type of modification of the data structure is left to
the mutator, namely type (1) &ldquo;redirecting an outgoing edge of a reachable node
towards an already reachable one&rdquo;. (Even the actions of the collector, required
for appending an identified garbage node to the free list, are very close to
the one operation available to the mutator. The only difference is that we
have to allow the collector to redirect the outgoing edge of a reachable node
towards a not yet reachable one.
<p>The activities of mutator and collector can now be described as repeated
executions of:
<table width=100%><tr><td valign=top width=10%>
mutator:</td><td>&ldquo;redirect an outgoing edge of a reachable node towards an
already reachable one&rdquo;
</td></tr>
<tr><td valign=top>
collector:</td><td>marking phase:
</td></tr>
<tr><td valign=top>
</td><td>&nbsp; &nbsp; &nbsp; &ldquo;mark all reachable nodes&rdquo;;
</td></tr>
<tr><td valign=top>
</td><td>appending phase:
</td></tr>
<tr><td valign=top>
</td><td>&nbsp; &nbsp; &nbsp; &ldquo;append all unmarked nodes to the free list and remove
the markings from all marked nodes&rdquo; .
</td>  </tr>  </table>
The mutator and the collector must cooperate in such a fashion that the
following two correctness criteria are satisfied.
<table width=100%><tr><td valign=top width=10%>
CC1:</td><td>Every garbage node is eventually appended to the free list. More precisely,
every garbage node present at the beginning of an appending phase will
have been appended by the end of the next appending phase.
</td>  </tr>  </table>
                
 
<table width=100%><tr><td valign=top width=10%>
CC2:</td><td>Appending a garbage node to the free list is the collector&rsquo;s only 
modification of (the shape of) the data structure.
</td>  </tr>  </table>
<p>Our final goal was a fine-grained solution in which each atomic operation
would be something like a single read or write of a variable. More precisely,
we wanted in our final solution to accept the following atomic operations:
&ldquo;redirecting an edge&rdquo;, &ldquo;finding the (left- or right-hand) successor of a node&rdquo;,
and &ldquo;testing and/or setting certain attributes of a node&rdquo;. (The latter class
of operations is obviously needed for marking the nodes.) The implementation
of these atomic operations falls outside the scope of this paper.
<p>Moreover we allow ourselves the (not essential but convenient) luxury of
considering &ldquo;append node nr. i to the free list&rdquo; to be an atomic operation 
available to the collector. We felt entitled to do so because its finer-grained
implementation in terms of a succession of redirection of edges is simple
provided the free list remains long enough, for than the nodes involved
are not touched by the mutator. Nor do we describe how to prevent the free
list from getting too short, i.e. how to delay the mutator, if necessary,
when it is about to take a node from the free list. (The latter is the
familiar consumer/producer coupling, a fine-grained solution of which has
been given in [3].)
<p>We have taken the course of first finding a coarse-grained solution,
and than transforming it into a finer-grained one. This two-stage approach
has been of great heuristic value; it was, however, not without pitfalls.
<p class=noindent>4. <b>The first coarse-grained solution</b>.
<p>A counterexample taught us, that the goal &ldquo;no extra overhead for the
mutator&rdquo; is unattainable. Suppose that the nodes A and B are permanently.
reachable via a constant set of edges, while node B is initially reachable
only via an edge from A to C . Suppose furthermore that,from then on,the
mutator performs repeatedly a sequence of redirections with the following
results:
<br>1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;making an outgoing edge from B point to C
<br>2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;making the edge from A to E disappear
                
<br>3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;making an outgoing edge from A point to C
<br>4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;making the edge from B to C disappear. I
<br>Since the collector observes nodes one at a time, it may never discover that
C is reachable: while the collector is observing A for its successors, C
may be reachable via B only, and the other way round. We therefore expect
that the mutator may have to mark in some way the target nodes of edges it
redirects.
<p>Marking will be described in terms of colours. We start with all nodes
white, and will design the algorithm so that the combined activity of the
collector&rsquo;s marking phase and the mutator will make all reachable nodes black.
All nodes that are still white after the marking phase will thus be garbage.
For any repetitive process &mdash;and the marking phase certainly is one&mdash; we have 
always two concerns (see [1]): firstly, we must have a monotonicity argument
on which to base our proof of termination, and secondly, we must find an 
invariant relation which is initially true and not destroyed during the repetition,
so that it still holds upon termination. For the monotonicity argument we
choose (fairly obviously) that during the marking phase no node will go back
from black to white. Since we will soon introduce the colour &ldquo;grey&rdquo;, we
restate this more generally as: &ldquo;during the marking phase no node will become
lighter&rdquo;. (Grey is darker than white and lighter than black.) For the invariant
relation &mdash;which must be satisfied both before and after the collector&rsquo;s marking
cycle&mdash; we must generalize the initial and final states of the marking cycle.
Our first choice (perhaps less obvious, but not unnatural) was:
<table width=100%><tr><td valign=top width=10%>
P1:</td><td>&ldquo;no edge points from a black node to a white one&rdquo; .
</td>  </tr>  </table>
<p>Additional action is now required from the mutator when it is about to
introduce an edge from a black node to a white one, since just placing it would
cause a violation of F1 . The monotonicity argument requires that the black
source node of the new edge has to remain black, so F1 tells us that the
target node of the new edge cannot be allowed to remain white. But the mutator
cannot just make it black, because that could cause a violation of P1 between
the new target node and its immediate successors. we therefore introduce the
intermediate colour &ldquo;grey&rdquo;, and let the mutator change the new target&rsquo;s colour
from white to grey; for reasons of simplicity, the mutator shall do so 
independently of the colour of the new edge&rsquo;s source. Our choice was a coarse-grained
                 
 
mutator that repeatedly performs the following atomic operation, in
which &ldquo;shading a node&rdquo; means making it grey if it is white, and 1eaving it
unchanged if it is grey or black:
<table width=100%><tr><td valign=top width=10%>
M1:</td><td>&lt;Redirect an outgoing edge of a reachable node towards an already
reachable one, and shade the new target &gt; .
</td>  </tr>  </table>
<b>Note 1</b>. Disregarding P1 , the problem of node C from the counterexample at
the beginning of this section could also have been solved by having the mutator
shade the old target instead of the new one. This, however, would lead to a
solution in which garbage created during a marking phase is guaranteed not to
be collected during the next appending phase. Hence, we rejected this solution
in accordance with the last sentence of section 1. (End of note 1.)
<p>We have decided that the collector&rsquo;s marking phase should make all
reachable nodes black while keeping P1 invariant. This decision leads fairly
directly to a coarse-grained collector. Like the mutator, the collector&rsquo;s
marking phase uses the intermediate colour grey to preserve F1 . Grey nodes
are than ones which must be made black, but which might still have white
successors. Hence, whenever it encounters a grey node, the marking phase must
make it black and shade its successors. For our coarse-grained collector, let the
entire operation of blackening a grey node and shading its successors be a single
atomic operation. Since the marking phase must make all grey nodes black, it
can terminate only when there are no more grey nodes. The obvious way of trying
to guarantee the absence of grey nodes is to let the marking phase terminate
when the collector had observed all nodes in some order without finding any
grey ones. This produces the collector given below; it is described with the
&ldquo;<b>if</b>...<b>fi</b>&rdquo; and &ldquo;<b>do</b>...<b>od</b>&rdquo; constructs introduced in [1]. (The idea of &ldquo;B &rarr; S&rdquo; ,
a so-called &ldquo;guarded command&rdquo;, is that the statement list S is only eligible
for execution in those initial states for which B is true. Below we need
only a few simple cases. The repetitive construct &ldquo;<b>do</b> B &rarr; S <b>od</b>&rdquo; is semantically
equivalent to the now traditional &ldquo;<b>while</b> B <b>do</b> S <b>od</b>&rdquo;. The alternative
construct &ldquo;<b>if</b> B1 &rarr; S1 &#x25af; B2 &rarr; S2 <b>fi</b>&rdquo; requires B1 <b>or</b> B2 to hold to start
with; if B2 were <b>non</b> B1 , it would be semantically equivalent to the now
traditional &ldquo;<b>if</b> B1 <b>then</b> S1 <b>else</b> S2 <b>fi</b>&rdquo; .) As before, angle brackets are used
to enclose atomic operations. Comments have been inserted between braces, and
labels have been inserted for future reference.
                 
 
The collector has two local integer variables i and k , and a local
variable c of type colour; the nodes are assumed to be numbered from 0 through
M-1 . Our coarse-grained collector then repeatedly executes the following
program:
<table> <tr> <td colspan = 9>
marking phase:                                                                 </td> </tr> <tr> <td colspan = 9>
<b>begin</b> {there are no black nodes}                                        </td> </tr> <tr> <td></td> <td></td> <td>&nbsp; </td> <td colspan = 6>
      &ldquo;shade all the roots&rdquo; {P1 and there are no white roots};     </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 6>
      i:= 0; k:= M;                                                            </td> </tr> <tr> <td>&nbsp; &nbsp; &nbsp; </td> <td colspan = 8>
   marking cycle:                                                              </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 6>
      <b>do</b> k &gt; 0 &rarr; {P1 and there are no white roots};             </td> </tr> <tr> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 5>
           &lt; c:= colour of node nr.i &gt; ;                                 </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td colspan = 5>
           <b>if</b> c = grey &rarr; k:= M;                                    </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 3>
                  C1: &lt;shade the successors of node                         </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; &nbsp; &nbsp; </td> <td>
                      nr. i and make node nr. i black&gt;                      </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td colspan = 4>
            &#x25af; c &ne; grey &rarr; k:= k - 1                              </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td colspan = 5>
           <b>fi</b>                                                           </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td colspan = 5>
           i:= (i + 1) <b>mod</b> M                                            </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 6>
      <b>od</b>                                                                </td> </tr> <tr> <td colspan = 9>
end {P1 and there are no white roots and nogrey nodes,                         </td> </tr> <tr> <td></td> <td>&nbsp; &nbsp; </td> <td colspan = 7>
     hence &mdash;as is easily seen&mdash; all white nodes are garbage};       </td> </tr> <tr> <td colspan = 9>
appending phase;                                                               </td> </tr> <tr> <td colspan = 9>
<b>begin</b> i:= 0;                                                            </td> </tr> <tr> <td></td> <td colspan = 8>
   appending cycle:                                                            </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 6>
      <b>do</b> i &lt; M &rarr; { all nodes with a number &lt; i are nonblack; </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td>&nbsp; </td> <td colspan = 2>
                   all nodes with a number &ge; i are nongrey,                 </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td colspan = 2>
                   and are garbage, if white}                                  </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td colspan = 5>
           &lt; c:= colour of node nr.i &gt; ;                                 </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td colspan = 5>
           <b>if</b> c = white - &lt;Iappend-node nr.i to the free list &gt;   </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td colspan = 4>
            &#x25af; c = black &rarr; &lt; make node nr.i white &gt;           </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td colspan = 5>
           <b>fi</b>                                                           </td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td colspan = 5>
           i:= i+1                                                             </td> </tr> <tr> <td></td> <td></td> <td></td> <td colspan = 6>
      <b>od</b> {there are no black nodes}                                     </td> </tr> <tr> <td colspan = 9>
<b>end</b>                                                                     </td> </tr>
</table>
                 
 
<b>Note 2</b>. Appending node nr.i to the free list includes redirecting its outgoing
edges so that no other nodes than NIL or free nodes can be reached from it
(see our second simplification as described in section 3). (End of note 2.)
<p class=noindent><b>Note 3</b>. It does not matter in which order nodes are examined during the marking
phase, so we could have written a more general algorithm that does not specify
any fixed order. Such an algorithm would allow more efficient implementations
of the marking phase, in which the collector maintains a list of grey or probably
grey nodes. For the sake of simplicity, we have not done so. (End of note 3.)
<p>We shall now demonstrate that the correctness criteria CC1 and CC2
are met.
<p class=noindent><b>Proof</b>. In order to prove that CC2 is met, we observe that, because in the
marking phase the collector does not change (the shape of) the data structure,
it suffices to show that during the appending phase it appends only garbage
nodes to the free list. Because node nr.i is appended after having been observed
to be white, it suffices to show that the relation
<table width=100%><tr><td valign=top width=10%>
</td><td>&ldquo;a white node with a number 2 i is garbage&rdquo;
</td></tr>
<tr><td valign=top>
1)</td><td>is an invariant of the appending cycle&rsquo;s repeatable action
</td></tr>
<tr><td valign=top>
2)</td><td>holds when the collector enters its appending cycle.
</td>  </tr>  </table>
<p class=noindent> 
<br>1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We shall demonstrate the invariance first, and shall do so by first proving
it for the appending cycle&rsquo;s repeatable action in isolation, and then showing that
the mutator leaves that proof&rsquo;s assertions invariant.
<p>Because in the appending cycle&rsquo;s repeatable action i is increased, the
collector could only violate the relation by making a non-garbage node white
or by making a (white) garbage node into non-garbage. By the alternative
construct either violation is possible, but only with respect to node nr.i;
we can still guarantee &ldquo;a white node with a number &gt; i is garbage&rdquo;, from which
it follows that the subsequent increase i:= i+1 restores the original relation.
<p>Because i is a local variable of the collector, also the mutator could
only violate the assertions either by making a non-garbage node white &mdash;which
it doesn&rsquo;t, because M1 only shades&mdash; or by making a (white) garbage node into
                  
 
non-garbage &mdash;which it doesn&rsquo;t either, because M1 only redirects edges towards
already reachable nodes and, hence, leaves garbage garbage&mdash; . Therefore, the
mutator&rsquo;s actions do not invalidate the demonstration that the relation is an
invariant of the appending cycle&rsquo;s repeatable action.
<p class=noindent>2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;To show, next, that the relation holds at the beginning of the appending
cycle, we have to demonstrate (because i = 0 ) that the marking phase has
established that &ldquo;all white nodes are garbage&rdquo;, which shall be shown under the
assumption that, at the beginning of the marking phase, there were no black
nodes.
<p>Because the absence of black nodes implies P1 , and because M1 and C1
have been carefully designed so as to leave P1 invariant and not to introduce
white roots, &ldquo;P1 and there are no white roots&rdquo; is clearly established before
and kept invariant during the marking cycle. When furthermore all grey nodes
have disappeared, our target state, in which all reachable nodes are black and
all white nodes are garbage, has been reached.
<p>The marking cycle terminates with a scan past all nodes, during which no
grey nodes are encountered. If we had only the collector to consider, the 
conclusion that at the end of such a scan grey nodes are absent &mdash;and hence the target
state has been reached&mdash; would be trivial. Due to the ongoing activity of the
mutator &mdash;the shading activity of which can introduce grey nodes!&mdash; a more
subtle argument; which now follows, is required.
<p>Firstly, we observe that the target state, characterized by the absence of
grey nodes, is stable: the absence of white reachable nodes prevents the mutator
from introducing grey ones, and the absence of grey nodes prevents the collector
from doing so. 
<p>Secondly, we show that a collector scan past all nodes, during which no
grey nodes are encountered, implies that the stable target state has already
been reached at the beginning of that scan: because the mutator leaves grey
nodes grey and the collector did not colour any nodes during that scan, a grey
node existing at its beginning would, in contradiction to the assumption, have
been encountered during that scan. Hence we can conlude that upon termination
                   
of the marking phase all white nodes are, indeed, garbage.
<p>Because the appending phase makes all black nodes white, and the mutator
does not introduce black nodes, there are no black nodes at the end of the
appending phase; this justifies the assumption made above, that there would
be no black nodes at the beginning of the marking phase. Thus we have completed
the proof that starting the collector in the absence of black nodes ensures
that CC2 is met.
<p align="center" class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>*</p> 
<p>To prove that CC1 is met, we must first show that the collector&rsquo;s two
phases terminate properly.
<p>Proper termination of the appending phase is obvious, except for one thing:
node nr.i must be black or white, because the alternative construct does not
cater for the case &ldquo;p = grey&rdquo;. But we have already proved that at the end of
the marking phase, there are no grey nodes and every white node is garbage.
Since the mutator cannot shade a garbage node, and shading a black node has no
effect, it is clear that every node is either black or white when it is examined
during the appending phase.
<p>Termination of the marking phase follows from the fact that the integral
quantity 
<table> <tr> <td>
k + M *(the number of non-black nodes) </td> </tr>
</table>
&mdash;which, by definition, is non-negative&mdash; is left invariant by the activity of
the mutator, and is decreased by at least one in each iteration of the marking
cycle.
<p>Consider now the situation at the beginning of an appending phase. At that
moment, the nodes are partitioned into three sets:
<table width=100%><tr><td valign=top width=4%>
&mdash;</td><td>the set of reachable nodes (they are black)
</td></tr>
<tr><td valign=top>
&mdash;</td><td>the set of white garbage nodes (during the first appending phase to come,
they will be appended to the free list)
</td></tr>
<tr><td valign=top>
&mdash;</td><td>the set of black garbage nodes (during the first appending phase to come,
they will not be appended to the free list, but they will be made white).
</td>  </tr>  </table>
Calling the last set the set of &ldquo;D-nodes&rdquo;, we have to show that all D-nodes will
be appended during the second appending phase to come.
                                       
 
<p>We call an edge &ldquo;leading into B&rdquo; when its target is a D-node, but its
source is not. Because D-nodes are garbage, we can state that at the beginning
of the first appending phase, sources of edges leading into D are white garbage
nodes.
<p>Since the D-nodes are garbage, the mutator will not redirect edges so as
to make them point to a D-node, and since they are black to start with, during
the first appending phase the collector won&rsquo;t do so either. The collector,
however, will append all white garbage nodes, which includes &mdash;see Note 2&mdash;
redirecting outgoing edges of the nodes appended, so that, as a result, we
can state that at the end of the first appending phase
<table width=100%><tr><td valign=top width=04%>
&mdash;</td><td>all D-nodes are white garbage nodes
</td></tr>
<tr><td valign=top>
&mdash;</td><td>there are no edges leading into D .
</td>  </tr>  </table>
<p>The absence of edges leading into D is an invariant for the subsequent
marking phase: the mutator does not introduce them, because D-nodes are garbage,
and the collector does not redirect edges during its marking phase. The
continued absence of edges leading into D, plus the fact that all D-nodes
are white garbage to start with, implies that the D-nodes remain white
garbage nodes during the subsequent marking phase: because they are garbage,
the mutator leaves them as they are, and because they are all white, the
collector is prevented from shading them. (Shading the first D-node by the
collector would require the existence of an edge pointing to it from a grey
node; in view of the absence of edges leading into D, this grey node would
have to be a D-node, which is impossible.) Consequently, at the end of the
marking phase, all D-nodes are still white garbage and will be appended to
the tree list during the subsequent appending phase. Hence, CC1 is also met.
(End of proof.)
<p>By keeping P1 invariant during the marking cycle, we obtained our
coarse-grained solution. Encouraged by this success, we tried to keep P1
also invariant in a finer-grained solution &mdash;a solution in which the mutator&rsquo;s
action  M1  was split into two atomic operations: one for redirecting the edge
and one for shading the new target&mdash; . In order to keep P1 invariant, the
mutator had to shade the future target first,and then redirect the edge towards
the node just shaded. This finer-grained solution &mdash;although presented in
                   
a way sufficiently convincing to fool ourselves&mdash; contained the following bug,
discovered by N.Stenning and M.Woodger [5] , 
<p>Consider the following sequence of events:
<br>1)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;prior to introducing an edge from node A to node B , the mutator shades
node B (and goes to sleep)
<br>2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the collector goes through a complete marking phase, followed by an
appending phase (node B is now white, i.e. the mutator&rsquo;s shading has been
undone! We further note that there is no garbage) 
<br>3)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the collector goes through part of the next marking phase (and then goes
to sleep), during which it so happens that node A is made black and node B
is left white
<br>4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the mutator (wakes up and) introduces without making garbage the edge
from A to B (P1 is now violated)
<br>5)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the mutator removes all other ingoing edges of B &mdash;the absence of garbage
makes this possible&mdash; and goes to sleep again (node B is now only reachable
via the edge from A )
<br>6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the collector completes its marking phase (node B has remained white)
<br>7)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the collector goes through its appending phase, during which the reachable
node B is erroneously appended to the free list.
<p>This ill-fated effort convinced us that in the finer-grained solution we
were heading for, total absence of an edge from a black node to a white one
was a stronger relation than we could maintain. However, it still seemed
reasonable to retain the notion of &ldquo;grey&rdquo; as &ldquo;semi-marked&rdquo;, more precisely,
as representing an unfulfilled marking obligation. This meant that we could use
the same collector. However, we had to find a different coarse-grained mutator
that we could use as a stepping stone to our ultimate fine-grained solution.
<p class=noindent>5.<b> A new coarse-grained solution</b>.
<p>For our new coarse-grained solution, we had to replace P1 by a weaker
relation. (It was replaced by P2 and P3 , defined below.) In our first
solution, we had made essential use of the fact that during the marking cycle,
the validity of P1 allowed us to conclude that the existence of a white
reachable node implied the existence of a grey node. (It even implied the
                     
 
existence of a grey reachable node, but the reachability of the grey node was
not essential.) For our new solution we needed a weaker relation P2 , from
which the same conclusion could be drawn. We defined a &ldquo;propagation path&rdquo; to
be one consisting solely of edges with white targets, and starting from a grey
node, and chose the following relation
<table width=100%><tr><td valign=top width=10%>
P2:</td><td>&ldquo;for each white reachable node, there exists a propagation path leading
to it&rdquo; .
</td>  </tr>  </table>
<p class=noindent><b>Note</b> 4. The grey node of the propagation path is not necessarily reachable.
(End of note 4.)
<p class=noindent><b>Corollary 1</b>. If each root is grey or black, the absence of edges from black
to white clearly implies that relation P2 is satisfied. In particular, P2
is true at the beginning of the marking cycle, because all roots have been
shaded and there are no black nodes. (End of corollary 1.)
<p>In proving the correctness of our first solution, the invariance of P1
was only needed to prove that, during the marking cycle, the absence of grey
nodes implies that all white nodes are garbage. we can clearly use P2 instead
of P1 to draw the same conclusion. Therefore, to prove the correctness of our
new solution, we need only prove that both the mutator and the marking 
collector leave P2 invariant. However, P2 turned out to be too weak a relation
from which to conclude that its truth will not be destroyed. To keep P2 
invariant, we had to restrict the existence of black-to-white edges by the
following further relation &mdash;analogous to P1 , but weaker&mdash;
<table width=100%><tr><td valign=top width=10%>
P3:</td><td>&ldquo;only the last edge placed by the mutator may lead from a black node
to a white one&rdquo; .
</td>  </tr>  </table>
<p class=noindent><b>Corollary 2</b>. In the absence of black nodes, P3 is trivially satisfied. Hence
it holds at the beginning of the marking cycle. (End of corollary 2.)
<p>By corollaries 1 and 2 , F2 <b>and</b> P3 is true at the beginning of the
marking cycle. To show that the marking cycle of our coarse-grained collector
leaves P2 <b>and</b> P3 invariant, we must show that the atomic operation C1 cannot
destroy its truth. Shading a node can cause neither P2 nor P3 to become
                  
false; shading the successors of a node implies that its outgoing edges are no
longer part of any propagation path, so making that node black immediately
afterwards does not make P2 false either. Moreover, since its successors have
just been shaded, making the node black does not introduce a black-t0-white edge,
and, hence, cannot make P3 false either. Combining these results we conclude
that in its marking cycle the collector leaves P2 <b>and</b> P3 invariant.
<p>All that remains to be done now in order to construct a correct 
coarse-grained solution is to define a mutator operation that leaves P2 <b>and</b> P3 
invariant. When the mutator redefines an outgoing edge of a black node, it may
direct it towards a white node. This new black-to-white edge is the one 
permitted by P3 . We must prevent, however, the previously redirected edge from
also being a black-to-white edge, and we therefore consider for our coarse- 
grained mutator the following atomic operation:
<table width=100%><tr><td valign=top width=10%>
M2: </td><td>&lt; shade the target of the previously redirected edge, and redirect an
outgoing edge of a reachable node towards a reachable node &gt; .
</td>  </tr>  </table>
<b>Note 5.</b> For the very first time that the mutator redirects an edge, we can
assume that (for lack of a previously redirected edge) either the shading will
be suppressed or else an arbitrary reachable node will be shaded. The choice
does not matter for the sequel. (End of note 5.)
<p>Action M2 has been carefully chosen in such a way that it leaves P3
invariant. We now prove that it leaves the stronger relation P2 and P3 
invariant as well, thereby showing that the new mutator with our original collector
gives a correct solution.
<p class=noindent><b>Proof</b>. The action M2 cannot introduce new reachable nodes. Hence, every
white node which is reachable after the operation had a propagation path leading
to it before the operation. If the node whose successor is redefined is black,
then its outgoing edge was <b>not</b> part of any propagation path, so the edges of
the old propagation paths will be sufficient to provide the propagation paths
needed to maintain P2 . (We may not need all of them because of the shading
operation, and because some white reachable nodes may have been made unreachable.)
If the node whose successor is redefined was white or grey to start with, then
the net result of action M2 will be a graph without edges from a black node to
                  
a white one: if one existed, then its target has now been shaded, and no new
one has been introduced since the source of the new edge is not black. The
roots must still be grey or black, so by corollary 1 , P2 still holds. (End
of proof.)
<p class=noindent>6.<b> A fine-grained solution</b>.
<p>To complete our task, we now use the coarse-grained solution of section 5
as a stepping stone to a fine-grained one. For our fine-grained mutator, M2
is split up into the following succession of atomic operations:
<table width=100%><tr><td valign=top width=10%>
M2.1:</td><td>&lt; shade the target of the previously redirected edge &gt; ;
</td></tr>
<tr><td valign=top>
M2.2:</td><td>&lt; redirect an outgoing edge of a reachable node towards a reachable
node &gt; .
</td>  </tr>  </table>
In the collector, we break open C1 as the sequence of five atomic operations
( m1 and m2 being local variables of the collector);
<table width=100%><tr><td valign=top width=10%>
C1.1:</td><td>&lt; m1:= number of the left-hand successor of node nr.i &gt; ;
</td></tr>
<tr><td valign=top>
C1.2:</td><td>&lt; shade node nr.m1 &gt; ;
</td></tr>
<tr><td valign=top>
C1.3:</td><td>&lt; m2:= number of the right-hand successor of node nr.i &gt; ;
</td></tr>
<tr><td valign=top>
C1.4:</td><td>&lt; shade node nr.m2 &gt; ;
</td></tr>
<tr><td valign=top>
C1.5:</td><td>&lt; make node nr.i black &gt; .
</td>  </tr>  </table>
<p>We first observe that the collector&rsquo;s action of shading a node commutes
with any number of mutator actions M2.1 and M2.2 ; without loss of generality
we can, therefore, continue our discussion as if the four atomic operations
C1.1 through C1.4 were replaced by a succession of the following two atomic
operations:
<table width=100%><tr><td valign=top width=10%>
C1.1a:</td><td>&lt;shade the left-hand successor of node nr.i 2&gt;;
</td></tr>
<tr><td valign=top>
C1.3a:</td><td>&lt; shade the right-hand successor of node nr.i &gt;- .
</td>  </tr>  </table>
<p>Examining the proof for our coarse-grained solution, it is clear that in
order to prove the correctness of this fine-grained one, it suffices to prove
that P2 <b>and</b> P3 is still invariant during the (fine-grained) marking cycle.
We shall prove the invariance of P2 <b>and</b> P3 by proving the invariance of a
stronger relation.
               
 
<p>For the purpose of its definition, we first introduce the notion of 
so-called &ldquo;C-edges&rdquo;. Loosely formulated, C-edges are the edges the sources of which
have been detected as grey by the collector&rsquo;s marking cycle. More precisely,
the set of C-edges is empty at the beginning of the marking cycle, and the actions
C1.1a and C1.3a add to it the left-hand and right-hand outgoing edge of node
nr.i,respectively. Note that the formulation has been chosen so as to make it
clear that, from C1.1a onwards, being a C-edge is a property of the left-hand
outgoing edge of node nr.i, independent of the node it points to: In 
particular, being a C-edge is invariant with respect to redirection of that edge by
the mutator.
<p class=noident><b>Note 6</b>. We only define the set of C-edges for <b>our</b> benefit. The set is not
explicitly updated, although the collector could easily do so. In the jargon,
the term &ldquo;ghost variable&rdquo; is sometimes used for such an entity. (End of note 6.)
<p>The strengthened versions of P2 and P3 can now be formulated as follows:
<table width=100%><tr><td valign=top width=10%>
P2a:</td><td>&ldquo;every root is grey or black, and for each white reachable node there
exists a propagation path leading to it, containing no C-edges&rdquo;
</td></tr>
<tr><td valign=top>
P3a:</td><td>&ldquo;there exists at most one edge &ldquo;E&rdquo; satisfying
<table width=100%><tr><td valign=top width=4%>
pr:</td><td>&rdquo;( E is a black-to-white edge) <b>or</b>
</td></tr>
<tr><td valign=top>
</td><td>( E is a C-edge with a white target)&ldquo; ;
</td>  </tr>  </table>
the existence of such an E satisfying pr implies that the mutator
is between action M2.2 and the subsequent action M2.1, and that E
is identical with the edge most recently redirected by the mutator&rdquo; .
</td>  </tr>  </table>
We now prove that P2a <b>and</b> P3a holds when the collector executes its
marking cycle.
<p class=noindent><b>Proof</b>. We first observe that P2a holds at the beginning of the marking cycle,
thanks to corollary 1 and the fact that the set of C-edges is then empty. As
there are neither C-edges nor black nodes at the beginning of the marking cycle,
there is no edge E satisfying pr , so at the beginning of the marking cycle
P3a holds as well.
<p>We further make the general remark that none of the operations M2.1,
M2.2, C1.1a, C1.3a, and C1.5 introduces new white reachable nodes. Consequently,
               
when proving the invariance of P2a under these operations, it suffices to
show that the existence, before the operation, of a propagation,path without
C-edges, leading to a reachable node that is white before and after the operation,
implies the existence afterwards of such a propagation path leading to that node.
<p>The invariance of P2a <b>and</b> P3a with respect to the three shading operations
M2.1 , C1.1a , and C1.3a can be dealt with simultaneously. Propagation paths
leading to a reachable node that is white both before and after the shading
operation are either left intact or are shortened by it. If these propagation
paths did not contain C-edges before the shading operation, than they won&rsquo;t do
so afterwards. The shading operations of the collector do create new C-edges,
but these are C-edges with grey or black targets, and, therefore, cannot belong
to any propagation path. This proves the invariance of P2a . Relation P3a 
is invariant as well, because the collector&rsquo;s shading acts introduce neither
a black-to-white edge, nor a C-edge with a white target, and operation M2.1
only removes the edge E if it did exist.
<p>Action C1.5 leaves P2a invariant: because the outgoing edges of the
grey node nr.i are C-edges, they don&rsquo;t belong to existing propagation paths 
without C-edges, and hence making that node black leaves the existence of such paths
unaffected. Action C1.5 also leaves P3a invariant, as it introduces no new
solutions E of pr : it may introduce a black-to-white edge, but then that
edge was already a E-edge with a white target.
<p>Action M2.2 leaves P3a invariant because, if P3a held before M2.2 ,
no edge E satisfying pr existed, and the redirection can create at most one
such edge. We finally prove the invariance of P2a under M2.2 . If the edge
to be redirected is a C-edge or if its source is black, it does not belong to a
propagation path without C-edges. Since, furthermore, M2.2 does not create
C-edges, the existence of such paths remains in this case unaffected. In the
other case &mdash;i.e. if the edge to be redirected is not a C-edge and has a white               
or grey source&mdash; the already established invariance of P3a implies after M2.2
the absence of black-to-white edges and the absence of C-edges with a white
target. In view of Corollary 1, these absences imply for all white reachable
nodes the existence of propagation paths without C-edges. (End of proof.)
                  
<p class=noindent><b>In retrospect</b>.
<p>It has been surprisingly hard to find the published solution and 
justification. It was only too easy to design what looked &mdash;sometimes even for weeks
and to many people&mdash; like a perfectly valid solution, until the effort to prove
it to be correct revealed a (sometimes deep) bug. The reasoning we have used
contains most of the ideas needed for a formal proof in the style of [3] or [4] .
Because the inclusion of such a proof would result in a paper, possibly tedious,
but in any case very different from what we intended to write this time, we 
have confined ourselves to our informal justification (which we do not regard
as an adequate substitute for a formal correctness proof). Whether our stepwise
approach is more generally applicable, is at the moment of writing still an
open question.
<p>When it is objected that we still needed rather subtle arguments, we
can only agree whole-heartedly: all of us would have preferred a simpler
argument! Perhaps we should conclude that constructions that give rise to
such tricky problems are not to be recommended. One firm conclusion, however,
can be drawn: to believe that such solutions can be found without a very
careful justification is optimism on the verge of foolishness.
<p class=noindent><b>History and aknowledgements</b>. (As in this combination this is our first
exercise in international and inter-company cooperation, some internal credit
is given as well.) After careful consideration of a wider class of problems the
third and the fifth authors selected,and formulated this problem, and did most
of the preliminary investigations; the first author found a first solution during
a discussion with the fifth author, W.H.J.Feijen and M.Rem. It was independently
improved by the second author &mdash;to give the free list a root and mark its nodes
as well, was his suggestion&mdash; and, on a suggestion made by John M.Mazola, by
the first and the third author. The first and the fourth merged these 
embellishments, but introduced the bug that was found by N.Stenning and M.Woodger. The
final version and its justification are the result of several cross-Atlantic
iterations. The active and inspiring interest shown by David Gries is mentioned
                  
in gratitude. As with each new version of the manuscript the proofs became simpler,
we also express our indebtedness to R.Stockton Gaines whose comments on an earlier
version caused two further iterations.
<p class=noindent><b>References</b>.
<table width=100%><tr><td valign=top width=10%>
1.</td><td>Dijkstra, Edsger w., Guarded Commands, Nondeterminacy and Formal Derivation
of Programs. Comm. ACM 18, 8 (Aug. 1975): 453-457.
</td></tr>
<tr><td valign=top>
2.</td><td>Steele Jr., Guy L., Multiprocessing Compactifying Garbage Collection.
Comm. ACM 18. 9 (Sep. 1975), 495-508.
</td></tr>
<tr><td valign=top>
3.</td><td>Lamport, Leslie, Proving the Correctness of Multiprocess Programs. IEEE
Trans. on Software Engineering SE-3, 2 (Mar. 1977), 125-143.
</td></tr>
<tr><td valign=top>
4.</td><td>Gries, David, An Exercise in Proving Parallel Programs Correct. (Submitted
to the Comm. ACM.)
</td></tr>
<tr><td valign=top>
5.</td><td>Woodger, M., Private Communications.
</td>  </tr>  </table>
                                 
<p class=noindent><b>Glossary of names</b>.
<br>Correctness criteria:
<table width=100%><tr><td valign=top width=5%>
CC1:</td><td>Every garbage node is eventually appended to the free list. More precisely,
 every garbage node present at the beginning of an appending phase will
have been appended by the end of the next appending phase.
</td></tr>
<tr><td valign=top>
CC2:</td><td>Appending a garbage node to the free list is the collector&rsquo;s only 
modification of&rsquo; (the shape of) the data structure.
</td>  </tr>  </table>
Atomic operations of the mutator:
<table width=100%><tr><td valign=top width=5%>
M1:</td><td>&lt; redirect an outgoing edge of a reachable node towards an already
reachable one, and shade the new target &gt; .
</td></tr>
<tr><td valign=top>
M2:</td><td>&lt; shade the target of the previously redirected edge, and redirect an
outgoingiedge of arreachable node towards reachable node &gt; .
</td></tr>
<tr><td valign=top>
M2.1:</td><td>&lt; shade the target of the previously redirected edge &gt; .
</td></tr>
<tr><td valign=top>
M2.2:</td><td>&lt; redirect an outgoing edge of a reachable node towards a reachable
node &gt; .
</td>  </tr>  </table>
Atomic operations of the collector:
<table width=100%><tr><td valign=top width=5%>
C1:</td><td>&lt; shade the successors of node nr.i and make node nr.i black &gt; .
</td></tr>
<tr><td valign=top>
C1.1:</td><td>&lt; m1 := number of the left-hand successor of node nr.i &gt; .
</td></tr>
<tr><td valign=top>
C1.2:</td><td>&lt; shade node nr.m1 &gt; .
</td></tr>
<tr><td valign=top>
C1.3:</td><td>&lt; m2:= number of the right-handsuccessor of node nr.i &gt; .
</td></tr>
<tr><td valign=top>
C1.4:</td><td>&lt; shade node nr.m2 &gt; .
</td></tr>
<tr><td valign=top>
C1.5:</td><td>&lt; make node nr.i black &gt; .
</td></tr>
<tr><td valign=top>
C1.1a:</td><td>&lt; shade the left-hand successor of node nr.i &gt; .
</td></tr>
<tr><td valign=top>
C1.3a:</td><td>&lt; shade the right-hand successor of node nr.i &gt; .
</td>  </tr>  </table>
Invariant relations:
<table width=100%><tr><td valign=top width=5%>
P1:</td><td>No edge points from a black node to a white one.
</td></tr>
<tr><td valign=top>
P2:</td><td>For each white reachable node, there exists a propagation path leading
to it.
</td></tr>
<tr><td valign=top>
P3:</td><td>Only the last edge placed by the mutator may lead from a black node
to a white one.
</td></tr>
<tr><td valign=top>
P2a:</td><td>Every root is grey or black, and for each white reachable node there
exists a propagation path leading to it, containing no C-edges.
</td></tr>
<tr><td valign=top>
P3a:</td><td>There exists at most one edge &ldquo;E&rdquo; satisfying
<table width=100%><tr><td valign=top width=5%>
pr:</td><td>&ldquo;(E is a black-to-white edge) <b>or</b>
</td></tr>
<tr><td valign=top>
</td><td>(E is a C-edge with a white target)&rdquo; 
</td>  </tr>  </table>
the existence of such an E satisfying  pr implies that the mutator
is between action M2.2 and the subsequent action M2.1, and that E
is identical with the edge most recently redirected by the mutator.
</td>  </tr>  </table>

<hr />
   <p class="noindent"><font size="-1">Transcribed by Martin P.M. van der Burgt<br />
    Last revision
    <csobj format="MedDate" h="13" region="15" t="DateTime" w="90">
      <!-- #BeginDate format:IS1 -->2015-01-06<!-- #EndDate -->
    </csobj>
  .</font></p>
  <p>&nbsp;</p>
</body></html>
    <p>&nbsp;</p>
    <p>&nbsp;</p></div>
  <script>
$('.body').tweetSelection({
  ellipsis: '...',
  quoteLeft: '\'',
  quoteRight: '\'',
  via: 'raboofje'
});
  </script>
  </body>
  </html>
