<!DOCTYPE html>
<html>
<head>
  <title> Over formal locations</title>
  <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
  <link href="assets/common.css" rel="stylesheet">
  <link href="assets/transcriptions.css" rel="stylesheet">
  <meta name="generator" content="convertArticle.pl">
</head>
<body>
<div class="metabar">
  <div class="metabar-inner">
    <a href="index.html">HOME</a>
  </div>
</div>
<h1> Over formal locations</h1>
<div class='body'>				<p class="noindent">8 juni 1864</p>				<p class="noindent"><u>Over formal locations</u></p>				<p class="noindent">(R&eacute;sum&eacute; van de besprekingen van de werkgroep, gehouden op 8 juni 1964)</p>				<p class="noindent">Het volgende is een r&eacute;sum&eacute;, dat ik uit mijn blote hoofd opstel; in hoeverre het waarheidsgetrouw is, kan ik dus niet garanderen.</p>				<p class="noindent">We hebben bij de kop gevat het geval, dat de formele parameter gespecificeerd is als <u>real</u> of <u>integer</u>. We zullen dit noemen <u>&quot;arithmetic&quot;</u>: we hebben nl. besloten de vertaler tussen deze twee specificaties geen onderscheid te laten maken en altijd het type van de actuele parameter &#x2014; mits natuurlijk real of integer &#x2014; te laten prevaleren.</p>				<p class="noindent">De prijs die we bereid zijn te betalen, bestaat zo op het oog uit vrij omvangrijke formal locations en een analyse van de meegegeven actuele parameters bij binnenkomst in de procedure.</p>				<p class="noindent">Over de omvang van de formal locations: wij komen zo op het eerste gezicht op vier woorden per parameter.</p>				<p class="noindent">Over de test: wij stellen ons voor, dat de meegegeven actuele parameters getest worden, d.w.z. aan een controle onderworpen worden, die op grond van de specificaties aan gelegd kan worden (wij stellen specificaties verplicht). Tot nog toe hebben wij ons geen zorgen gemaakt over de snelheid, waarmee deze test aangelegd kan worden (&quot;Is het dit, of dat, of dat etc.&quot; Als je eerst vraagt naar het meest voorkomende type actuele parameter, dan is het waarschijnlijk nog niet eens zo tijdrovend.)</p>				<p class="noindent">Wij nemen ons voor om deze acceptabiliteitstest zover door te voeren, dat daarna de tests, die nog dynamisch uitgevoerd moeten worden, een soort van sinecure zijn.</p>				<p class="noindent">Omdat de type-overgangen speciale complicaties met zich meebrengen, gaan we het daar eerst over hebben.</p>				<p class="noindent">We stellen ons voor, dat de arithmetiek <u>altijd</u> in het drijvend register F wordt uitgevoerd. (Uitgezonderd misschien n := n + 1 of zoiets doms.)</p>				<p class="noindent">Om een integer als operand, als primary, in een expressie te betrekken, is dankzij de speciale representatie van drijvende getallen in de X8 geen probleem. Moeilijker is de assignment aan een integer variabele. Dit kan op twee manieren moeiljkheden opleveren: het getal kan niet geheel zijn, het getal kan (<u>na</u> evenetuele afronding!) te groot zijn.</p>				<p class="noindent">Als F ge&iuml;ntegreerd moet worden, lassen we in het programma in:<br>					<br>				</p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td width="10%"></td>						<td>U, A = M[57], Z kop F = 0?</td>					</tr>					<tr>						<td width="10%"></td>						<td>N, SUBCD(INTEGREER)</td>					</tr>				</table>				<p class="noindent">waarin de subroutine &quot;INTEGREER&quot; &#x2014; hiervoor moeten we een kortere naam bedenken &#x2014; luidt (begint met)<br>					<br>				</p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td width="10%">INTEGREER:</td>						<td width="30%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F + AFR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>						<td>AFR = 3 * 2 &#x2191; 38</td>					</tr>					<tr>						<td width="10%"></td>						<td width="30%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F - AFR</td>						<td></td>					</tr>					<tr>						<td width="10%"></td>						<td width="30%">U, A = M[57], Z</td>						<td></td>					</tr>					<tr>						<td width="10%"></td>						<td width="30%">Y, GOTOR(MC[-1]) &#x2192; </td>						<td>en terug</td>					</tr>					<tr>						<td width="10%"></td>						<td width="30%">________________________ </td>						<td>capaciteitsoverschrijding</td>					</tr>				</table>				<p></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="5%">Opm.</td>						<td valign="top">De constante AFR is zo gekozen, dat mits F van te voren niet te groot is (abs. &lt; 2 &#x2191; 38) de som F + AFR met de binaire komma naaar rechts geechelonneerd staat. En passant verzorgt dan het fatsoen van de rekencursist van de EL-X8 de correcte afronding. Vervolgens wordt AFT er weer afgetrokken. Nu is F in elk geval geheel. F kan nog te groot zijn (veel te groot zelfs); vandaar dat de kop van F weer aan een nultest onderworpen wordt.</td>					</tr>				</table>				<p class="noindent">Een en ander kost ons in het hoofdprogramma twee opdrachten per integer assignment aan plaatsruimte.</p>				<p class="noindent">Aan tijd</p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td width="10%"></td>						<td>in het normale geval (geen afronding nodig): 2 geh. cont</td>					</tr>					<tr>						<td width="10%"></td>						<td>als transferfunctie nodig (wel afronding): 12 geh. cont. + exces tijd voor drijvende optelling</td>					</tr>				</table>				<p class="noindent">Ik verwacht, dat afronding zo weinig voorkomt, dat ik er weinig voor voel om &#x2014; als standaardpraktijk tenminate &#x2014; ten koste van vier extra opdrachten in het objectprogramma de afronding vier geheugencontacten te versnellen.</p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td width="10%"></td>						<td>U, A = M[57], 4</td>					</tr>					<tr>						<td width="10%"></td>						<td>Y, JUMP (4)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2192;</td>					</tr>					<tr>						<td width="10%"></td>						<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F + AFR</td>					</tr>					<tr>						<td width="10%"></td>						<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F - AFR</td>					</tr>					<tr>						<td width="10%"></td>						<td>U, A = M[57], Z</td>					</tr>					<tr>						<td width="10%"></td>						<td>N, GOTO &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#x2192; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;capaciteitsoverschrijding</td>					</tr>					<tr>						<td width="10%">							<div align="right">								&#x2192;</div>						</td>						<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;--------------</td>					</tr>				</table>				 				<p class="noindent">Tot zover het probleem van afronding en range analyse. (In geval van capaciteitsoverschrijding zullen we de plaats waar ook nog wel een beetje moeten aangeven. Daar mogen we later dan over denken)</p>				<p class="noindent">We keren nu terug tot de formal locations.</p>				<p class="noindent">Het type van de actuele parameter deert ons, zoals bekend, weinig, wanneer de formele in de expressie-situatie uitgewerkt moet worden. Als hij aan de linkerkant van de assignment voorkomt, treedt er nog meer ellende op, zodra we een multiple assignment hebben. Immers:</p>				<p>als een formele linkerkant in zijn eentje voorkomt, heeft een integer actuele tot gevolg, dat er afgerond kan moeten worden;</p>				<p>als een formele linkerkant, samen met een real linkerkant voorkomt, moet een integer actuele tot gevolg hebben, dat er een foutindicatie gegeven wordt, omdat in een multiple assignment de linkerkanten van hetzelfde type moeten zijn;</p>				<p>als in een multiple assignment alle linkerkanten formeel zijn &#x2014; dankzij de binnenprocedure kunnen dit formelen van verschillende hoogte zijn! &#x2014; moet de foutindicatie bij verschillende types gegeven worden, en afronding moet bij (homogeen) integer actuelen ingelost worden.</p>				<p class="noindent">We hebben dus besloten om de multiple formal assignment voorlopig te laten voor wat hij is, d.w.z. het normale geval niet door het bestaan van de multiple formal assignment te laten vertragen. (We hebben voor de multiple formal assignment wel een oplossing, maar die is dan maar een beetje tijdrovend.)</p>				<p class="noindent">Vast staat, dat we de assignment aan de nonformele scalar exceptioneel zullen behandelen. Als de vertaler in een scan van links naar recht de assignment statement leest, worden de nonformele scalaire linkerkanten opgezouten en op homogeneiteit van type onderzocht (tezamen met de nonformele subscripted linkerkanten, die van hetzelfde type moeten zijn, maar wel meteen aanleiding tot &quot;programma&quot; geven.)</p>				<p class="noindent">Als de vertaler het programma gegenereerd heeft, dat de expressie uitrekent in het F-register, test hij, of het verzamelde type van de linkerkant van type integer is, zo ja, dan wordt de integratie ingelast. Vervolgens genereert de vertaler voor elke opgezouten nonformele linkerkant een Mp[q] := F of een Mp[q] := G, afhankelijk van het gevonden type. Tenslotte komen de subscripted left hand sides aan bod. (waarover later vast nog een hele hoop meer). Tot zover was er niets formeel.</p>				<p class="noindent">Nu gaan we bekijken geval van de single formal assignment.</p>				<p class="noindent">Hier staat de taal als actuele parameter toe:</p>				<p class="noindent">1e een real scalar<br>					2e een integer scalar<br>					3e een subscripted real<br>					4e een subscripted integer<br>					5e een formal.</p>				<p class="noindent">De laatste mogelijkheid confronteert ons echter met niets nieuws, want het meegeven van een reeds formele parameter als actuele is niet meer dan copieren van de formal locations; de laatste mogelijkheid geeft dus geen nieuwe vrijheidsgraad aan de formal locations.</p>				<p class="noindent">De eerste opmerking is, dat we bij een formele linkerkant eerst deze linkerkant moeten analyseren en zelfe moeten uitwerken, in het geval het een subscripted variable is. De uitwerking van de expressie kan immers als neveneffect hebben, dat de subscript evaluation na afloop andere waarden op zou leveren. (Denk maar aan &quot;R[read] := read&quot;.)</p>				<p class="noindent">Om die reden zullen we de formele linkerkant eerst moeten &quot;uitwerken&quot;, d.w.z. indentiteit van de variabele moeten vaststellen. (In geval van meer formele en/of subscripted linkerkanten werken we deze af in volgorde van links naar rechts.</p>				<p class="noindent">Het uitwerken van een formele linkerkant zal aanleiding geven tot een stapelvulling, onder controle waarvan de waarde van de expressie, wanneer deze eenmal in het F-register gevormd is, zal worden weggenschreven. En het is van deze kant, dat we het systeem opbouwen: eerst stellen we vast, wat een plezierige stapelvulling is, opdat dit wegschrijven vlot en snel zal gaan. Hierna stellen we vast, wat geschikte vullingen van formal locations zijn, om bij de uitwerking van de formele linkerkant deze gewenste stapelvulling tot stand te brengen. De stapelvulling ten gevolge van uitwerking van een formele linkerkant noemen we een &quot;linkerkantwaarde&quot;.</p>				<p class="noindent">Op het moment, dat de wegschrijving moet plaatsvinden, staat de waarde in F en de linkerkantwaarde is het top-element van de stapel.</p>				<p class="noindent">We zullen voor de verschillende gevallen vershillende gestructueerde linkerkantwaarden moeten introduceren. Deze verschillende structuren zijn echter gekoppeld door de eis, dat de feitelijke assignments moeten geschichten op grond van precies dezelfde indicatie in het (aan de body ontleende) objectprogramma. We kiezen deze indicatie zo, dat</p>				<blockquote>					<table width="100%" border="0" cellspacing="2" cellpadding="0">						<tr>							<td valign="top" width="5%">a) </td>							<td>de in beslag genomen ruimte in het objectprogramma niet te groot is<br>								<br>							</td>						</tr>						<tr>							<td valign="top" width="5%">b)</td>							<td>het meest voorkomende geval &#x2014; actuele een real in de stapel zo vlot mogelijk verwerkt wordt.</td>						</tr>					</table>				</blockquote>				<p class="noindent">&#x00c9;&eacute;n opdracht in het objectprogramma is kennelijk wel het minimum en we gaan exploreren, wat de gevolgen zijn, als we hiervoor kiezen</p>				<blockquote>					<p>&quot;DO(MC[-1])&quot;</p>				</blockquote>				<p class="noindent">d.w.z. een execute op de top van de stapel met impliciete aflaging van het B-register.</p>				<p class="noindent">We gaan nu na, wat in de verschillende gevallen de aangemeten linkerkantwaarde moet zijn.</p>				<p class="noindent"></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="4%">1.</td>						<td valign="top"><u>Een real op een vast physisch adres &quot;a&quot;</u>. Dit doet zich voor als de real een scalar in de stapel is, of een element van een klein array. Bladzijden van grote arrays zullen immers in het algemeen niet op heilige pagina's staan.</td>					</tr>				</table>				<p></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="8%"><u>1.1.</u></td>						<td valign="top"> a &lt; 32768<br>							<br>							In dit geval bestaat de linkerkantwaarde uit een enkel woord (bij de weergave van stapels is de stapelbodem boven!):							<blockquote>								<p class="continue">B - 1: M[a] := F<br>									B : ---------</p>							</blockquote>							<p class="continue">Tijsduur 4 geheugencontacten.</p>						</td>					</tr>				</table>				<p class="noindent"></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td align="left" valign="top" width="8%"><u>1.2.</u></td>						<td align="left" valign="top"> a &#x2265; 32768<br>							Dit geval, dat zich alleen voordoet als men beschikt over een geheugen, dat groter is dan 32K behandelen we volledigheidshalve wel. We kunnen dan niet volstaan met een linkerkantwaarde van een enkel woord. Dan moet dus b.v. B met meer dan 1 worden afgelaagd, dit kan door het topwoord van de linkerkantwaarde een subroutinesprong te laten zijn. Een mogelijke structuur van de linkerkantwaarde is:							<blockquote>								<p class="noindent">B - 2: &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ a<br>									B - 1: SUBCD(:q1)<br>									B &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: ----------</p>							</blockquote>							<p class="noindent">Waarbij adres :q1 de entry van het systeem is en wel<br>								<br>							</p>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td valign="top" width="10%">q1: </td>									<td valign="top" width="30%">S = MC[-2]<br>										MS[0] = F<br>										GOTOR(MC[0]) &#x21D2; </td>									<td valign="top">S := a, B := B - 1<br>										berg<br>										B := B - 1 en terug.</td>								</tr>							</table>						</td>					</tr>				</table>				<p class="noindent"></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="8%"><u>Opm</u>.</td>						<td valign="top"> Wij vestigen er de aandacht op, dat hier wel een stukje gemeen programmeren wordt weggeven. De DO-operatie laagt eerst B af; de uiteindelijke opdracht blijkt een stapelende subroutinesprong te zijn, die zichzelf met de link overschrijft en B weer met 1 ophoogt. De subroutine bestaat uit drie opdrachten, waarin twee stapelverwijzingen de twee nodige B-aflagingen impliciet bewerkstelligen.<br>							<br>							Tijdsduur: 10 geheugencontacten.</td>					</tr>				</table>				<p class="noindent"></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="4%">2. </td>						<td valign="top"><u>Een integer op adres a<br>							</u>Ook bij integers kan het geval a &lt; 32768 apart behandeld worden; het verschil is echter gemarkeerd.</td>					</tr>				</table>				<p class="noindent"></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="8%"><u>2.1.</u></td>						<td valign="top">a &lt; 32768<br>							De structuur van de linkerkantwaarde kan zijn							<blockquote>								<p class="noindent">B - 2 : M[a] = G<br>									B - 1 : SUBCD(:q2)<br>									B &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: ----------</p>							</blockquote>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td valign="top" width="15%">Met q2:</td>									<td valign="top" width="30%"> U, S = M[57], Z<br>										<br>										Y, DO(MC[-2])<br>										Y, GOTOR(MC[)])<br>										&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F + AFR<br>										&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F - AFR<br>										U, S = M[57], Z<br>										Y, DO(MC[-2])<br>										Y, GOTOR(MC[0]) <br>										-------------- </td>									<td valign="top"><br>										<br>										<br>										&#x2192; zonder meer acceptabel<br>										<br>										<br>										<br>										<br>										&#x2192; na afronding acceptabel<br>										&nbsp;&nbsp;&nbsp;&nbsp;capaciteitsoverschrijding</td>								</tr>							</table>							<p class="continue">Tijdsduur minimaal 9 geheugencontacten.</p>						</td>					</tr>				</table>				<p></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="8%"><u>2.2.</u></td>						<td valign="top">a &#x2265; 32768<br>							De structuur van de linkerkantwaarde kan zijn:							<blockquote>								<p class="noindent">B - 2 : + a<br>									B - 1 : SUBCD(:q3)<br>									B &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: ----------</p>							</blockquote>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td valign="top" width="6%">met q3:</td>									<td valign="top" width="30%">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S = MC[-2]<br>										U, S = M[57], Z<br>										Y, MS[0] = G<br>										Y, GOTOR(MC[0]) &#x2192; zonder meet acceptabel<br>										&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>										&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>										&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>										&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;. etc.<br>										&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>										&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.<br>									</td>								</tr>							</table>							<p class="continue">Tijdsduur minimaal 10 geheugencontacten.</p>						</td>					</tr>				</table>				<p></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="4%">3. </td>						<td valign="top"><u>Een real op een bladzijde</u><br>							De linkerkantwaarde beslaat weer twee woorden							<blockquote>								<p class="noindent">B - 2 : &nbsp;pakking van physisch adres van de BZV en regelnummer<br>B - 1 : &nbsp;SUBCD(:q4)<br>B &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: &nbsp;----------</p>							</blockquote>							<p class="noindent">De wijze, waarop de subroutine, die op :q4 begint toegang heeft tot de gepakte gegevens is na de vorige routines nu wel duidelijk. Wij merken op, dat wanneer het uit tijdsoverwegingen voldoende gunstiger uitkomt, we hier een linkerkant ook wel drie woorden kunnen laten beslaan, door nl. het physisch adres van de BZV en het regelnummer gescheiden, ieder in een eigen woord op te bergen.</p>						</td>					</tr>				</table>				<p></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="4%">4.</td>						<td valign="top"><u>Een integer op een bladzijde</u>							<blockquote>								<p class="noindent">B - 2 : pakking van physisch adres van de BZV en regelnummer<br>									B - 1 : SUBCD(:q5)<br>									B &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: ----------</p>							</blockquote>							<p class="noindent">De routine, die bij q5 begint, begint (zie 2) af te ronden, en verloopt verder analoog aan die van q4. Ook hier kunnen desgewenst de hier gepakte gegevens in twee aparte woorden geborgen.</p>						</td>					</tr>				</table>				<p class="noindent"><u>Uitwerking van formele variabelen</u></p>				<p class="noindent">Wij moeten nu, voor elk type van actuele parameter gaan vaststellen, welke structuur de formal locations zullen vertonen. De formal locations bepalen de actuele parameter, die in het algemeen op twee wijzen kan moeten worden uitgewerkt, nl. als linkerkant en als rechterkant. In het laatste geval stellen we als eis, dat de waarde in het F-register verschijnt, in het eerste geval, dat de linkerkantwaarde, als boven beschreven, aan de stapel wordt toegevoegd.</p>				<p class="noindent">We gaan uit van vier formal locations, in volgorde van opklimmend geheugenadres beschreven als f[0], f[1], f[2], en f[3]. We spreken af, dat uitwerking als rechterkant in het objectprogramma van de body gecodeerd zal worden als</p>				<blockquote>					<p class="noindent">DOS (f[0])</p>				</blockquote>				<p class="noindent">en uitwerking als linkerkant als</p>				<blockquote>					<p class="noindent">DOS (f[1])</p>				</blockquote>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="14%"><u>Opm. 1</u>.</td>						<td valign="top">De formal locations zullen, als grootheden in de stapel, via de dynamische adressering geadresseerd worden.</td>					</tr>					<tr>						<td valign="top" width="14%"><u>Opm. 2</u>.</td>						<td valign="top">Het meegeven van een formele parameter als actuele willen we effectueren, door &quot;ongezien&quot; copieren van de formal locations. We moeten er dus voor zorgen, dat de structuur van de formal locations zodanig is, dat ze tegen verplaatsing (nl. copiering elders) bestand zijn.</td>					</tr>				</table>				<p class="noindent">We volgen nu dezelfde indeling.</p>				<p class="noindent">1. <u>Een real op een vast physisch adres a</u></p>				<p class="noindent"></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="8%"><u>1.1.</u></td>						<td valign="top">a &lt; 32768							<p class="continue">f[0] : F = M[a]<br>								f[1] : SUBCD(:q6)<br>								f[2] : M[a] = F<br>								f[3] : voor alsnog ongebruikt.<br>								<br>							</p>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td valign="top" width="8%"><u>Opm</u>.</td>									<td valign="top">f[3] hebbe wel de goede pariteit in verband met copiering van de formal locations.</td>								</tr>							</table>							<p class="noindent">De subroutine, die op q6 begint, is even wat gecompliceerd, omdat de link boven op de stapel komt en het juist deze plaats is, die gevuld moet worden. Dit impliceert &quot;redden van de link&quot;.</p>							<p class="noindent">De systeemroutine luidt</p>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td width="15%">										<div align="right">											q6 :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>									</td>									<td>G = MS[1]</td>									<td></td>								</tr>								<tr>									<td width="15%"></td>									<td>S = M[B-1] </td>									<td>red link</td>								</tr>								<tr>									<td width="15%"></td>									<td>M[B-1] = G</td>									<td></td>								</tr>								<tr>									<td width="15%"></td>									<td>GOTOR(M[60])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &#x21D2;</td>									<td>terug via S-register.</td>								</tr>							</table>							<p class="noindent">Tijdsduur voor linkerkantuitwerking: 10 geheugencontacten.</p>							<p class="noindent">De rechterkantuitwerking spreekt voor zichzelf en duurt 4 geheugencontacten.</p>						</td>					</tr>				</table>				<p class="noindent"> </p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="8%"><u>1.2.</u></td>						<td valign="top"> a &#x2265; 32768							<p class="continue">Volledigheidshalve geven we de formal locations voor een vast gesitueerde real boven de 32 K:<br>								f[0] SUBCD(:q7)<br>								f[1] SUBCD(:q8)<br>								f[2] + a<br>								f[3] SUBCD(:q3)<br>								Hier geeft q8 de systeemroutine aan:<br>							</p>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td width="15%">										<div align="right">											q8 : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>									</td>									<td>F = MS[1]</td>									<td></td>								</tr>								<tr>									<td width="15%"></td>									<td>S = MC[-1]</td>									<td></td>								</tr>								<tr>									<td width="15%"></td>									<td>MC[0] = F</td>									<td></td>								</tr>								<tr>									<td width="15%"></td>									<td>GOTOR(M[60])</td>									<td></td>								</tr>							</table>							<p class="continue">een routine, die grote overeenkomst vertoont met q6; de netto verhoging van B met 1 wordt door - 1 + 2 bewerkstelligd. De tijdsduur voor linkerkantuitwerking is nu 12 geheugencontacten.<br>								<br>								De systeemroutine q7 luidt </p>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td width="15%">										<div align="right">											q7 : &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</div>									</td>									<td>S = MS[2]</td>									<td></td>								</tr>								<tr>									<td width="15%"></td>									<td>F = MS[0]</td>									<td></td>								</tr>								<tr>									<td width="15%"></td>									<td>GOTOR(MC[-1])</td>									<td></td>								</tr>							</table>							en vergt 10 geheugencontacten.</td>					</tr>				</table>				<p class="noindent">2. <u>Een integer op een vast physisch adres a</u></p>				<p class="noindent"></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="8%"><u>2.1.</u></td>						<td valign="top">a &lt; 32768<br>							<br>												f[0] G = M[a]<br>												f[1] SUBCD(:q8)<br>												f[2] M[a] = G<br>												f[3] SUBCD(:q2)<br>							<br>							Hierbij wordt dezelfde systeemroutine gebruikt (nl. q8) als in geval 1.2. Uitwerking van een linkerkant kost 12 geheugencontacten, uitwerking van een rechterkant 3</td>					</tr>				</table>				<p class="noindent"> </p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td align="left" valign="top" width="8%"><u>2.2.</u></td>						<td align="left" valign="top">a &#x2265; 32768<br>												Volledigheidshalve geven we dit geval weer<br>												f[0] SUBCD(:q9)<br>												f[1] SUBCD(:q8)<br>												f[2] + a<br>												f[3] SUBCD(:q3)<br>							<br>							waarbij q9 (analoog aan q7) luidt							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td valign="top" width="10%">										<div align="right">											q9 :&nbsp;&nbsp;&nbsp;</div>									</td>									<td valign="top" width="30%">S = MS[2]<br>															G = MS[0]<br>															GOTOR(MC[-1])</td>									<td valign="top"></td>								</tr>							</table>							Uitwerking van een rechterkant duurt dan 9 geheugencontacten, die van een linkerkant als gebrukelijk 12.</td>					</tr>				</table>				<p class="noindent">3. <u>Een real op een bladzijde</u></p>				<p class="noindent">De actuele parameter is dan een subscripted element. We nemen dat deze gegeven is door een impliciete IS, die (zo ongeveer) het element localiseert in termen van physisch adres van de BZV en regelnummer. Aanwezigheidsanalyse van de bladzijde wordt door de impliciete subroutine nog niet gepleegd.</p>				<p class="noindent">De impliciete subroutine wordt in de formal locations gekarakteriseerd door een &quot;invariant beginadres&quot;. We laten in het midden of hierin de BZV van de pagina gegeven is door zijn physische adres, dan wel door zijn adressering als locale van het buitenste blok (eigen bladzijde) of de bibliotheeklijst. Physisch adres is waarschijnlijk het snelste.</p>				<p class="noindent">De inhoud van de formal locations is dan</p>				<blockquote>					<p class="noindent">f[0] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SUBCD(q10 of q11)<br>						f[1]  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SUBCD(q12 of q13)<br>						f[2] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; invariant beginadres implicitie subroutine<br>						f[3]  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context D.</p>				</blockquote>				<p class="noindent">Routines q10 en q12 zijn bedoeld voor het geval, dat de IS simpel is, wat o.a. impliceert, dat de pagina van de body niet geprofaneerd hoeft te worden en er in de stapel per definitie voldoende anonieme ruimte zal zijn. In dit geval kan de machinelink als terugadres gehandhaafd worden en hoeft alleen de heersende D aan de terugkeergegevens toegevoegd te worden. Anders (q11 en q13) moet de link in invariant terugkeeradres terugvertaald worden en de pagina van de body geprofaneerd worden.</p>				<p class="noindent">Onder controle van S hebben deze routines toegang tot de IS en de context D, die ingevuld moet worden om de IS correct te kunnen uitvoeren. Verder moet de bladzijde waar de IS begint heilig aangevraagd worden. (Als hij al heilig aanwezig is, betekent dit al, dat HHT = 2 wordt!)</p>				<p class="noindent">Na afloop van de IS keert de besturing terug in de systeemroutine. Afhankelijk van linker of rechterkant wordt of alleen de pakking van BZV-adres en regelnummer &#x2014; door de IS afgeleverd &#x2014; op de top van de stapel gezet en dit afgedekt met de constante &quot;SUBCD(:q4)&quot; of wordt selectie gepleegd &#x2014; inclusief aanwezigheidscontrole &#x2014; en de gevraagde real in F gezet.</p>				<p class="noindent"></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="4%">4. </td>						<td valign="top"><u>Een integer op een bladzijde</u>							<p class="continue">De inhoud van de formal locations is dan</p>							<blockquote>								<p class="continue">f[0] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SUBCD(q14 of q15)<br>									f[1] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SUBCD(q16 of q17)<br>									f[2] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;invariant beginadres impliciete subroutine<br>									f[3] &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context D.</p>							</blockquote>							<p class="continue">Deze routines verschillen slechts van de vorige vier, doordat bij linkerkantuitwerking de pakking met &quot;SUBCD(:q5)&quot; wordt afgedekt en bij rechterkantuitwerking alleen het geselecteerde woord in G geplaaatst wordt.</p>							<table width="100%" border="0" cellspacing="2" cellpadding="0">								<tr>									<td valign="top" width="12%"><u>Opm. 1</u> </td>									<td valign="top">Zodra we ook &quot;kleine arrays&quot; in de stapel willen toestaan, dan zullen (kunnen) de laatste acht subroutines na terugkeer uit IS inspecteren, of het aangewezen element een van een klein array is. In dat geval is de linkerkantwaarde als van type 1 of 2, de rechterkantwaarde is dan triviaal.<br>										<br>									</td>								</tr>								<tr>									<td valign="top" width="12%"><u>Opm. 2</u></td>									<td valign="top">Deze acht subroutines lijken verdacht veel op elkaar en het ligt dus voor de hand om ze van gemeenschappelijke routines gebruik te laten maken. Men lette erop, dat <u>alle</u> status informatie dan op de stapel moet komen, omdat ze genest en parallel gearchiveerd kunnen worden &#x2014; d.w.z. door verschillende programma's door elkaar gebruikt kunnen worden.</td>								</tr>							</table>						</td>					</tr>				</table>				<p class="noindent">					Hiermede zijn alle actuele parameters, corresponderend met een specificatie <u>arithmetic</u> behandeld voorzover zij een bestaanbare linkerkantwaarde hebben. De overige zijn de constante, de expressie en de arithmetic procedure SS (Self Supporting, d.w.z. een procedure identifier behorend bij een procedure zonder parameter).</p>				<p class="noindent">Bij binnenkomst in de procedure zullen de formal locations op aanwaaardbaarheid getest moeten worden; hier wordt niet getest, of een arithmetic actual ook inderdaad een linkerkantwaarde heeft. Daarom zullen wij deze formal locations (met name f[1]) zo vullen, dat als de body probeert, hun linkerkantwaarde uit te werken, dit alsnog tot protest aanleiding geeft.</p>				<p class="noindent"></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="4%">5. </td>						<td valign="top"><u>De real constante</u>							<blockquote>								<div id="frame">									<div id="content">										<table width="100%" border="0" cellspacing="2" cellpadding="0">											<tr>												<td width="10%">f[0]<br>													f[1]</td>												<td>F = MS[2]&nbsp;<br>													Alarmsprong</td>											</tr>											<tr>												<td width="10%">f[2]&nbsp;&nbsp;&nbsp;&nbsp;&#x23B1;<br>f[3]&nbsp;&nbsp;&nbsp;&nbsp;&#x23B0;</td>												<td>&nbsp;waarde van de constante</td>											</tr>										</table>									</div>								</div>							</blockquote>							<div id="frame">								<div id="content">									<p class="noindent">Tijdsduur rechterkantuitwerking: 4 geheugencontacten.</p>								</div>							</div>						</td>					</tr>				</table>				<p></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="4%">6.</td>						<td valign="top"><u>De integer constante</u>							<p class="continue">(Dit is misschien een beetje te veel eer!)</p>							<blockquote>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td width="10%">f[0]<br>											f[1]<br>											f[2]<br>											f[3] </td>										<td>G = MS[3]<br>											 Alarmsprong<br>											 invariant beginadres impliciete subroutine<br>											waarde integer constante</td>									</tr>								</table>							</blockquote>							<p class="noindent">Tijdsduur rechterkantuitwerking: 3 geheugencontacten.</p>							<blockquote>								<div id="frame">									<div id="content">																			</div>								</div>							</blockquote>							<div id="frame">								<div id="content">																	</div>							</div>						</td>					</tr>				</table>				<p></p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="4%">7.</td>						<td valign="top"><u>De arithmetische expressie</u>							<blockquote>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td width="10%">f[0]<br>											f[1]<br>											f[2]<br>											f[3]</td>										<td>SUBCD(q18 of q19)<br>											Alarmsprong<br>											invariant beginadres impliciete subroutine<br>											context D.</td>									</tr>								</table>							</blockquote>							<p class="noindent">Het onderscheid tussen de systeemroutines q18 of q19 is weer of de impliciete subroutine simpel is of niet.</p>						</td>					</tr>				</table>				<p class="noindent"> </p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="4%">8.</td>						<td valign="top"><u>De enkele type procedure identifier, die als expressie op mag treden</u>							<p class="noindent">De inhoud van de formal location wordt, zodra we goed en wel ons in de body befinden</p>							<blockquote>								<table width="100%" border="0" cellspacing="2" cellpadding="0">									<tr>										<td width="10%">f[0]<br>											f[1]<br>											f[2]<br>											f[3]</td>										<td>SUBCD(:q20)<br>											Alarmsprong<br>											invariant beginadres van de procedure<br>											context D</td>									</tr>								</table>							</blockquote>							<p class="noindent">De moeilijkheid hier is, dat de procedure ook expliciet als procedure aangeroepen kan worden. Nu stellen wij one voor om bij de call de formal locations van de parameters te vullen, vervolgens dit aantal mee te geven en dan naar de (nog &quot;ongeziene&quot;) procedure te springen, die begint te testen of het aantal meegegeven parameters correct is. De body van de procedure zonder parameters begint dus te testen of hij inderdaad geen parameters heeft meegekregen.</p>						</td>					</tr>				</table>				<p class="noindent">De functie van de systeemroutine q20 is om het stukje calling sequence behelzends &quot;nulparameters&quot; dynamisch in te lassen, voordat volgens alle regels van de kunst de procedure geactiveerd wordt.</p>				<p class="noindent">De formal location vulling met SUBCD(:q20) kan echter slechts op twee manieren to stand komen</p>				<p>1e Door een arithmetic formal parameter &#x2014; waarbij de actuele een procedure identifier was &#x2014; als actuele parameter door te geven. Doorgeven is immers copieren van de formal locations.</p>				<p>2e Door een arithmetic procedure identifier als actuele parameter mee te geven, waar de formele als arithmetic gespecificeerd blijkt te zijn. Het meegeven van een procedure identifier als actuele parameter geschiedt door te vertaler:</p>				<table width="100%" border="0" cellspacing="2" cellpadding="0">					<tr>						<td valign="top" width="40%">							<div align="right">								1e&nbsp;&nbsp; </div>						</td>						<td valign="top">zonder bewustzijn van het aantal parameters, dat deze procedure vergt<br>							<br>						</td>					</tr>					<tr>						<td valign="top" width="40%">							<div align="right">								2e&nbsp;&nbsp;</div>						</td>						<td valign="top">zonder bewustzijn of de overeenkomstige formele als <u>procedure</u> of als <u>arithmetic</u> gespecificeerd is.</td>					</tr>				</table>				<p class="noindent">Als de formele als procedure gespecificeerd is, dan inspecteert de body de formal locations om te kijken of er een procedure van het goede type is meegegeven. Bij gebruik van deze als procedure gespecificeerde parameter zal de callside het feitelijk aantal parameters (kan = 0 zijn) expliciet aangeven.</p>				<p class="noindent">Als de formele parameter als arithmetic gespecificeerd is, dan wordt als overeenkomstige actuele een procedure identifier van het goede type geaccepteerd, maar de formal locations worden gewijzigd door de invulling van &quot;SUBCD(:q20)&quot; in f[0]. Dit proces vindt plaats ongeacht het aantal parameters, dat de meegegeven procedure graag zou willen hebben. Bij dynamisch gebruik wordt dit in de procedure getest; q20 zorgt nl. voor expliciete meegave van &quot;nulparameters&quot;. (Ook dan hoeft de Alarmsprong pas in de formal location ingevuld te worden: bij een procedure, die als zodanig gespecificeerd is, is een alarmsprong immers een open deur!)</p>				<hr>				<p class="noindent"><!-- name and date --></p>				<div id="footer">					<p class="noindent"><font size="-1">transcribed by Carl Ludwigson<br>							revised <csobj format="MedDate" h="13" region="15" t="DateTime" w="89">Thu, 4 Nov 2010</csobj></font></p>				</div>			</div>																									</body></html></div>
</body>
</html>
