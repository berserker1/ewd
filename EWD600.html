  <!DOCTYPE html>
  <html>
  <head>
    <title>A sequel to EWD592</title>
    <link href="https://fonts.googleapis.com/css?family=Lobster|Raleway" rel="stylesheet">
    <link href="assets/common.css" rel="stylesheet">
    <link href="assets/transcriptions.css" rel="stylesheet">
    <meta name="generator" content="convertArticle.pl">
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content="A sequel to EWD592" />
    <meta name="twitter:image" content="http://raboof.github.io/ewd/assets/dijkstra.jpeg" />
  </head>
  <body>
  <div class="metabar">
    <div class="metabar-inner">
      <a href="index.html">HOME</a>
    </div>
  </div>
  <h1>A sequel to EWD592</h1>
  <div class='body'>
        <hr />
<p class="noindent">NOTE: This transcription was contributed by Martin P.M. van der Burgt, who has devised a process for producing 
transcripts automatically. Although its markup is incomplete, we believe it serves a useful purpose by virtue of its searchability and its 
accessibility to text-reading software. It will be replaced by a fully marked-up version when time permits. &mdash;HR</p>
<hr />
           <p class="noindent">
<p class=noindent>5th January 1977 
<p><b>A sequel to EWD592</b>.
<p>Recently I lectured on the structure of proofs for termination in Munich.
Lack of time had prevented me from giving the argument why a variant function
that decreases monotonically, <b>must</b> exist, and the next morning miss dr. Mila
Majster, who had been in my audience, presented to me what she felt could be
a counterexample. Her example was essentially:
<table> <tr> <td>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </td> <td colspan = 2>
      <b>do</b> odd (x)<b>and</b> x &ge; 3 &rarr; x:= x + 1 </td> </tr> <tr> <td></td> <td>&nbsp; </td> <td>
       &#x25af; even(x)<b>and</b> x &ge; 2 &rarr; x:= x / 2 </td> </tr> <tr> <td></td> <td colspan = 2>
      <b>od</b>                                             </td> </tr>
</table>
(The condition x &ge; 2 has been added to prevent the value sequence 0, 0, 0, ....;
the condition x &ge; 3 has been added to prevent 1, 2, 1, 2, ... from occurring.)
<p>My first guess at a single t was wrong. I have posed the problem to
a number of my Dutch colleagues, and all first proposals were wrong. After
my failure I decided to apply the technique of EWD592m writing t = t1 + t2
such that t1 is decreaed by the first alternative and left invariant by the
second, and for t2 the other way round. My construction was ingenious &mdash;so
ingenious that I showed it proudly to a number of people!&mdash; but in St.Pierre
de Chartreuse .... I discovered that it was wrong!
<p>A next time I proceeded more carefully. Because I had the feeling that
the binary representation of x could provide a good handle and the second
alternative is in terms of the bits the simplest, I first looked for t2 .
<p>Well the quantity that is obviously decreased by 1 by x:= x / 2 is
the number of trailing zero&rsquo;s or, alternatively, the number of significant
digits. As first approxiamtion I took the latter; because it depends on the
position of the most-significant 1 , it has the advantage of being undefined
for x = 0, thereby justifying the constraint x &ge; 2 . The problem is that
the first alternative increases it by 1 if x:= x + 1 forms a power of 2.
Because being a power of 2 is invariant under x:= x / 2 , a good proposal is 
t2 = the number of significant digits of x , decreased by 1 iff x is a power of 2 .
<p>Searching for a t1 took me more time. Because t1 must be invariant
under x:= x / 2 , it should be a function of the digit pattern as it extends
itself from the most- to the least-significant 1 in x . Because adding 1
          
will turn a number of trainling 1&rsquo;s into 0&rsquo;s and then a 0 into a 1, my first
guess was something like the number of &ldquo;internal zero&rdquo; (i.e. between 
the most and the least-significant 1&rsquo;s). I then realized, that the number of internal
zero&rsquo;s fails to be decreased by 1 if by x:= x + 1 a power of 2 is formed.
Hence I concocted
<p class=noindent>t1 = the number of internal 0&rsquo;s of x , increased by 1 iff x is not a power of 2 .
<p class=noindent>This t1 has the advantage of excluding x = 1, hence the condition x &ge; 3 .
<br>Adding t1 + t2 I derived:
<p class=noindent>t = 1 + the number of significant digits + the number of internal 0&rsquo;s,
decreased by 2 iff x is a power of 2 .
<table width=100%><tr><td valign=top width=20%>
x (in binary)</td><td> t(x)
</td></tr>
<tr><td valign=top>
10</td><td> 1 + 2 + 0 - 2 = 1
</td></tr>
<tr><td valign=top>
11</td><td>1 + 2 + 0 = 3
</td></tr>
<tr><td valign=top>
100</td><td>1 + 3 + 0 - 2 = 2
</td></tr>
<tr><td valign=top>
101</td><td>1 + 3 + 1 = 5
</td></tr>
<tr><td valign=top>
110</td><td>1 + 3 + 0 = 4
</td></tr>
<tr><td valign=top>
111</td><td>1 + 3 + 0 = 4
</td></tr>
<tr><td valign=top>
1000</td><td>1 + 4 + 0 - 2 = 3
</td></tr>
<tr><td valign=top>
1001</td><td>1 + 4 + 2 = 7 etc.
</td>  </tr>  </table>
<p>The best thing that can be said for my t is that t1 is <b>exactly</b> the
number of times the first alternative will be chosen, and t2 is <b>exactly</b> the
number of times the second alternative will be chosen: it gives you all the
timing information. But if we are only interested in termination, the amount
of work we have spent seems excessive, and there is clearly room for techniques
of proving the <b>existence</b> of a variant function without actually constructing
one.  
<p align="center" class="noindent">*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*<br>*</p> 
<p>In St.Pierre de Chartreuse M.Sintzoff showed me another way of proving
the termination of repetitive constructs. As yet I have no feeling for the
significance of his method, but it intruged me enough to try to reconstruct 
what he had shown me, and I think that in any case the method deserves to be
recorded. In order to prove for a given repetitive construct
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
DO: <b>do</b> B1 &rarr; S1 &#x25af; ... &#x25af; Bj &rarr; Sj &#x25af; ... &#x25af; Bn ... Sn <b>od</b></td><td align=right>(1)
</td></tr>
<tr><td valign=top>  </td><td valign=top>
we have for a certain P and R P = wp(DO, R)</td><td align=right>(2)
</td>  </tr>  </table>
               
we don&rsquo;t prove that directly, but construct a sequence of repetitive constructs
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
DO<sub>i</sub>: <b>do</b> B1<sub>i</sub> &rarr; S1 &#x25af; ... &#x25af; Bj<sub>i</sub> &rarr; Sj &#x25af; ... &#x25af; Bn<sub>i</sub> ... Sn <b>od</b></td><td align=right>(3)
</td></tr>
<tr><td valign=top>  </td><td valign=top>
for 1 = 0, 1, 2, ... such that P<sub>i</sub> = wp(DO<sub>i</sub>, R)</td><td align=right>(4)
</td>  </tr>  </table>
If for some value of &rsquo;i &mdash;or in the limit for i to infinity&mdash; we have P = P<sub>i</sub>
and DO = DO<sub>i</sub> , then (2) has been proved.
<p>With the abreviations for BB<sub>i</sub> and P<sub>i</sub>
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
BB<sub>i</sub> = (<u>E</u> j: 1 &le; j &le; n: Bj<sub>i</sub>) and P<sub>i</sub> = BB<sub>i</sub> <b>or</b> R</td><td align=right>(5)
</td>  </tr>  </table>
the method can be described as follows. Choose for i = 0 : BB<sub>0</sub> = F &mdash;i.e.
all guards false&mdash; ; as a consequence we have P<sub>0</sub> = R . To perform the step
from i to i+1 we choose for the Bj<sub>i+1</sub> solutions of the equations (1 &le; j &le; n):
<table width=100%>
<tr><td valign=top width=10%>  </td><td valign=top>
(Bj<sub>i</sub> &rArr; Bj<sub>i+1</sub>) <b>and</b> (Bj<sub>i+1</sub> &rArr;(Bj<sub>i</sub> <b>or</b> (wp(Sj, P<sub>i</sub>) <b>and</b> <b>non</b> P<sub>i</sub>)))</td><td align=right>(6)
</td>  </tr>  </table>
If for a given value of i the only solution of (6) is Bj<sub>i+1</sub> = Bj<sub>i</sub> for all j ,
then the game clearly stops; otherwise we choose for at least one value of j
Bj<sub>i+1</sub> &ne; Bj<sub>i</sub> . The result is that if P<sub>i</sub> holds initially, DO<sub>k</sub> for k &ge; i
is certain to establish R in at most i steps. Formula (6) can be discovered
by working backwards from the final state that should satisfy R; the last 
term &rdquo;<b>and</b> <b>non</b> P<sub>i</sub>&ldquo; excludes that the weakening of Bj<sub>i</sub> to Bj<sub>i+1</sub> introduces
the possibility of nontermination.
<p>The charm of Sintzoff&rsquo;s method is that it is so constructive. With
S1: x:= x + 1 , S2: x:= x - 1 , S3: x:= x - 2 we derived with
R: x = 0 and P: x &ge; 0 without problems the following programs
<table> <tr> <td>
<b>do</b> false &rarr; x:= x + 1 &#x25af; x = l &rarr; x:= x - 1 &#x25af; x &ge; 2 &rarr; x:= x - 2 <b>od</b>     </td> </tr> <tr> <td>
<b>do</b> false &rarr; x:= x + l &#x25af; podd(x) &rarr; x:= x - l &#x25af; x &ge; 2 &rarr; x:= x - 2 <b>od</b>   </td> </tr> <tr> <td>
<b>do</b> podd(x) &rarr; x:= x + l &#x25af; podd(x) &rarr; x:= x - l &#x25af; peven(x) &rarr; x:= x - 2 <b>od</b> </td> </tr>
</table>
 
The first program is deterministic, the second program is not, but the number
of steps needed is a unique function of the initial value of x ; in the last
program, the number of steps is not (always) uniquely determined by the initial
value of x . I spent a few hours with Sintzoff&rsquo;s method, and I think that
they were well spent.
<p class=noindent><table width=100%><tr><td valign=top width=50%>
Plataanstraat 5 .</td><td>prof.dr.Edsger W.Dijkstra
</td></tr>
<tr><td valign=top>
NUENEN - 4565</td><td>Burroughs Research Fellow
</td></tr>
<tr><td valign=top>
The Netherlands</td><td>
</td>  </tr>  </table>

<hr />
   <p class="noindent"><font size="-1">Transcribed by Martin P.M. van der Burgt<br />
    Last revision
    <csobj format="MedDate" h="13" region="15" t="DateTime" w="90">
      <!-- #BeginDate format:IS1 -->2015-01-23<!-- #EndDate -->
    </csobj>
  .</font></p>
  <p>&nbsp;</p>
</body></html></div>
  </body>
  </html>
